// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
var _Db_defaultOpts, _Db_httpClient, _Db_keyspace, _Db_id, _Db_region;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { Collection } from '../documents/collections/index.js';
import { DEFAULT_KEYSPACE } from '../lib/api/index.js';
import { AstraDbAdmin } from '../administration/astra-db-admin.js';
import { extractDbComponentsFromAstraUrl } from '../documents/utils.js';
import { DataAPIDbAdmin } from '../administration/data-api-db-admin.js';
import { DataAPIHttpClient, EmissionStrategy } from '../lib/api/clients/data-api-http-client.js';
import { Table } from '../documents/index.js';
import { DEFAULT_DATA_API_PATHS } from '../lib/api/constants.js';
import { $CustomInspect } from '../lib/constants.js';
import { InvalidEnvironmentError } from '../db/errors.js';
import { CollSerDes } from '../documents/collections/ser-des/ser-des.js';
import { TableSerDes } from '../documents/tables/ser-des/ser-des.js';
import { AdminOptsHandler } from '../client/opts-handlers/admin-opts-handler.js';
import { DbOptsHandler } from '../client/opts-handlers/db-opts-handler.js';
import { EnvironmentCfgHandler } from '../client/opts-handlers/environment-cfg-handler.js';
import { HierarchicalLogger, TokenProvider } from '../lib/index.js';
export class Db extends HierarchicalLogger {
        constructor(rootOpts, endpoint, dbOpts) {
        var _a, _b;
        const defaultOpts = {
            ...rootOpts,
            dbOptions: DbOptsHandler.concat([rootOpts.dbOptions, dbOpts]),
            adminOptions: AdminOptsHandler.concatParse([rootOpts.adminOptions], {
                adminToken: TokenProvider.opts.parseWithin(dbOpts, 'token'),
            }),
        };
        super(rootOpts.client, defaultOpts.dbOptions.logging);
        _Db_defaultOpts.set(this, void 0);
        _Db_httpClient.set(this, void 0);
        _Db_keyspace.set(this, void 0);
        _Db_id.set(this, void 0);
        _Db_region.set(this, void 0);
                Object.defineProperty(this, "endpoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        __classPrivateFieldSet(this, _Db_defaultOpts, defaultOpts, "f");
        __classPrivateFieldSet(this, _Db_keyspace, {
            ref: (rootOpts.environment === 'astra')
                ? __classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.keyspace ?? DEFAULT_KEYSPACE
                : __classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.keyspace ?? undefined,
        }, "f");
        endpoint = (endpoint.endsWith('/'))
            ? endpoint.replace(/\/+$/, "")
            : endpoint;
        __classPrivateFieldSet(this, _Db_httpClient, new DataAPIHttpClient({
            baseUrl: endpoint,
            tokenProvider: __classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.token,
            baseApiPath: __classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.dataApiPath || DEFAULT_DATA_API_PATHS[rootOpts.environment],
            logger: this,
            fetchCtx: rootOpts.fetchCtx,
            keyspace: __classPrivateFieldGet(this, _Db_keyspace, "f"),
            caller: rootOpts.caller,
            emissionStrategy: EmissionStrategy.Normal,
            additionalHeaders: __classPrivateFieldGet(this, _Db_defaultOpts, "f").additionalHeaders,
            timeoutDefaults: __classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.timeoutDefaults,
        }), "f");
        _a = this, _b = this, [({ set value(_c) { __classPrivateFieldSet(_a, _Db_id, _c, "f"); } }).value, ({ set value(_c) { __classPrivateFieldSet(_b, _Db_region, _c, "f"); } }).value] = extractDbComponentsFromAstraUrl(endpoint);
        Object.defineProperty(this, 'endpoint', {
            value: endpoint,
        });
        Object.defineProperty(this, $CustomInspect, {
            value: () => `Db(endpoint="${this.endpoint}",keyspace="${this.keyspace}")`,
        });
    }
        get keyspace() {
        if (!__classPrivateFieldGet(this, _Db_keyspace, "f").ref) {
            throw new Error('No keyspace set for DB (can\'t do db.keyspace, or perform any operation requiring it). Use `db.useKeyspace`, or pass the keyspace as an option parameter explicitly.');
        }
        return __classPrivateFieldGet(this, _Db_keyspace, "f").ref;
    }
        get id() {
        if (__classPrivateFieldGet(this, _Db_defaultOpts, "f").environment !== 'astra') {
            throw new InvalidEnvironmentError('db.id', __classPrivateFieldGet(this, _Db_defaultOpts, "f").environment, ['astra'], 'non-Astra databases have no appropriate ID');
        }
        if (!__classPrivateFieldGet(this, _Db_id, "f")) {
            throw new Error(`Unexpected AstraDB endpoint URL '${this.endpoint}'—database ID unable to be parsed`);
        }
        return __classPrivateFieldGet(this, _Db_id, "f");
    }
        get region() {
        if (__classPrivateFieldGet(this, _Db_defaultOpts, "f").environment !== 'astra') {
            throw new InvalidEnvironmentError('db.region', __classPrivateFieldGet(this, _Db_defaultOpts, "f").environment, ['astra'], 'non-Astra databases have no appropriate region');
        }
        if (!__classPrivateFieldGet(this, _Db_region, "f")) {
            throw new Error(`Unexpected AstraDB endpoint URL '${this.endpoint}'—database region unable to be parsed`);
        }
        return __classPrivateFieldGet(this, _Db_region, "f");
    }
        useKeyspace(keyspace) {
        __classPrivateFieldGet(this, _Db_keyspace, "f").ref = keyspace;
    }
    admin(options) {
        const environment = EnvironmentCfgHandler.parseWithin(options, 'options.environment');
        const parsedOpts = AdminOptsHandler.parse(options, 'options');
        if (__classPrivateFieldGet(this, _Db_defaultOpts, "f").environment !== environment) {
            throw new InvalidEnvironmentError('db.admin()', environment, [__classPrivateFieldGet(this, _Db_defaultOpts, "f").environment], 'environment option is not the same as set in the DataAPIClient');
        }
        if (environment === 'astra') {
            return new AstraDbAdmin(this, __classPrivateFieldGet(this, _Db_defaultOpts, "f"), parsedOpts, __classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.token, this.endpoint);
        }
        if (extractDbComponentsFromAstraUrl(this.endpoint).length !== 0) {
            throw new InvalidEnvironmentError('db.admin()', environment, [__classPrivateFieldGet(this, _Db_defaultOpts, "f").environment], 'environment option must be "astra" or unset for this database');
        }
        return new DataAPIDbAdmin(this, __classPrivateFieldGet(this, _Db_defaultOpts, "f").client, __classPrivateFieldGet(this, _Db_httpClient, "f"), __classPrivateFieldGet(this, _Db_defaultOpts, "f"), parsedOpts);
    }
        async info(options) {
        if (__classPrivateFieldGet(this, _Db_defaultOpts, "f").environment !== 'astra') {
            throw new InvalidEnvironmentError('db.info()', __classPrivateFieldGet(this, _Db_defaultOpts, "f").environment, ['astra'], 'info() is only available for Astra databases');
        }
        const data = await this.admin().info(options);
        const region = this.endpoint
            .split('.')[0]
            .split('https://')[1]
            .split('-')
            .slice(5)
            .join('-');
        return {
            id: data.id,
            name: data.name,
            keyspaces: data.keyspaces,
            status: data.status,
            environment: data.environment,
            cloudProvider: data.cloudProvider,
            region: region,
            apiEndpoint: this.endpoint,
            raw: data.raw.info,
        };
    }
        collection(name, options) {
        return new Collection(this, __classPrivateFieldGet(this, _Db_httpClient, "f"), name, __classPrivateFieldGet(this, _Db_defaultOpts, "f"), {
            ...options,
            serdes: CollSerDes.cfg.concatParse([__classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.collSerdes], options?.serdes),
        });
    }
        table(name, options) {
        return new Table(this, __classPrivateFieldGet(this, _Db_httpClient, "f"), name, __classPrivateFieldGet(this, _Db_defaultOpts, "f"), {
            ...options,
            serdes: TableSerDes.cfg.concatParse([__classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.tableSerdes], options?.serdes),
        });
    }
        async createCollection(name, options) {
        const command = {
            createCollection: {
                name: name,
                options: {
                    defaultId: options?.defaultId,
                    indexing: options?.indexing,
                    vector: options?.vector,
                },
            },
        };
        await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand(command, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('collectionAdminTimeoutMs', {
                timeout: {
                    collectionAdminTimeoutMs: (typeof options?.timeout === 'number') ? options.timeout : options?.timeout?.collectionAdminTimeoutMs,
                    requestTimeoutMs: 0,
                },
            }),
            keyspace: options?.keyspace,
            extraLogInfo: { name },
        });
        return this.collection(name, options);
    }
    async createTable(name, options) {
        const command = {
            createTable: {
                name: name,
                definition: options.definition,
                options: {
                    ifNotExists: options.ifNotExists,
                },
            },
        };
        await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand(command, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('tableAdminTimeoutMs', options),
            extraLogInfo: { name, ifNotExists: options.ifNotExists ?? false },
            keyspace: options?.keyspace,
        });
        return this.table(name, options);
    }
        async dropCollection(name, options) {
        await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand({ deleteCollection: { name } }, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('collectionAdminTimeoutMs', options),
            keyspace: options?.keyspace,
            extraLogInfo: { name },
        });
    }
        async dropTable(name, options) {
        await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand({ dropTable: { name, options: { ifExists: options?.ifExists } } }, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('tableAdminTimeoutMs', options),
            extraLogInfo: { name, ifExists: options?.ifExists ?? false },
            keyspace: options?.keyspace,
        });
    }
        async dropTableIndex(name, options) {
        const dropOpts = (options?.ifExists)
            ? { ifExists: true }
            : undefined;
        await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand({ dropIndex: { name, options: dropOpts } }, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('tableAdminTimeoutMs', options),
            extraLogInfo: { name, ifExists: options?.ifExists ?? false },
            keyspace: options?.keyspace,
        });
    }
    async listCollections(options) {
        const explain = options?.nameOnly !== true;
        const command = {
            findCollections: {
                options: { explain },
            },
        };
        const resp = await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand(command, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('collectionAdminTimeoutMs', options),
            extraLogInfo: { nameOnly: !explain },
            keyspace: options?.keyspace,
        });
        const colls = resp.status.collections;
        if (explain) {
            for (let i = 0, n = colls.length; i < n; i++) {
                colls[i].definition = colls[i].options;
                delete colls[i].options;
            }
        }
        return colls;
    }
    async listTables(options) {
        const explain = options?.nameOnly !== true;
        const command = {
            listTables: {
                options: { explain },
            },
        };
        const resp = await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand(command, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('tableAdminTimeoutMs', options),
            extraLogInfo: { nameOnly: !explain },
            keyspace: options?.keyspace,
        });
        return resp.status.tables;
    }
        async command(command, options) {
        return await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand(command, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('generalMethodTimeoutMs', options),
            keyspace: options?.keyspace,
            collection: options?.collection,
            extraLogInfo: options?.extraLogInfo ?? { source: 'db.command' },
            table: options?.table,
        });
    }
        get _httpClient() {
        return __classPrivateFieldGet(this, _Db_httpClient, "f");
    }
}
_Db_defaultOpts = new WeakMap(), _Db_httpClient = new WeakMap(), _Db_keyspace = new WeakMap(), _Db_id = new WeakMap(), _Db_region = new WeakMap();
