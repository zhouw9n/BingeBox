// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
import { TimeoutCfgHandler } from '../../../lib/api/timeouts/cfg-handler.js';
export const EffectivelyInfinity = 2 ** 31 - 1;
export class Timeouts {
    constructor(_mkTimeoutError, baseTimeouts) {
        Object.defineProperty(this, "_mkTimeoutError", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _mkTimeoutError
        });
        Object.defineProperty(this, "baseTimeouts", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.baseTimeouts = TimeoutCfgHandler.concat([Timeouts.Default, baseTimeouts]);
    }
    single(key, override) {
        if (typeof override?.timeout === 'number') {
            const timeout = override.timeout || EffectivelyInfinity;
            const initial = {
                requestTimeoutMs: timeout,
                [key]: timeout,
            };
            return this.custom(initial, () => {
                return [timeout, 'provided'];
            });
        }
        const timeouts = {
            requestTimeoutMs: (override?.timeout?.requestTimeoutMs ?? this.baseTimeouts.requestTimeoutMs) || EffectivelyInfinity,
            [key]: (override?.timeout?.[key] ?? this.baseTimeouts[key]) || EffectivelyInfinity,
        };
        const timeout = Math.min(timeouts.requestTimeoutMs, timeouts[key]);
        const type = (timeouts.requestTimeoutMs === timeouts[key])
            ? ['requestTimeoutMs', key] :
            (timeouts.requestTimeoutMs < timeouts[key])
                ? ['requestTimeoutMs']
                : [key];
        return this.custom(timeouts, () => {
            return [timeout, type];
        });
    }
    multipart(key, override) {
        const _requestTimeout = (typeof override?.timeout === 'object')
            ? override.timeout?.requestTimeoutMs ?? this.baseTimeouts.requestTimeoutMs
            : this.baseTimeouts.requestTimeoutMs;
        const _overallTimeout = (typeof override?.timeout === 'object')
            ? override.timeout?.[key] ?? this.baseTimeouts[key] :
            (typeof override?.timeout === 'number')
                ? override.timeout
                : this.baseTimeouts[key];
        const requestTimeout = _requestTimeout || EffectivelyInfinity;
        const overallTimeout = _overallTimeout || EffectivelyInfinity;
        const initial = {
            requestTimeoutMs: requestTimeout,
            [key]: overallTimeout,
        };
        let started;
        return this.custom(initial, () => {
            if (!started) {
                started = Date.now();
            }
            const overallLeft = overallTimeout - (Date.now() - started);
            if (overallLeft < requestTimeout) {
                return [overallLeft, [key]];
            }
            else if (overallLeft > requestTimeout) {
                return [requestTimeout, ['requestTimeoutMs']];
            }
            else {
                return [overallLeft, ['requestTimeoutMs', key]];
            }
        });
    }
    custom(peek, advance) {
        return {
            initial() {
                return peek;
            },
            advance: (info) => {
                const advanced = advance();
                const timeoutType = advanced[1];
                advanced[1] = () => this._mkTimeoutError(info, timeoutType);
                return advanced;
            },
        };
    }
}
Object.defineProperty(Timeouts, "cfg", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: TimeoutCfgHandler
});
Object.defineProperty(Timeouts, "Default", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: Timeouts.cfg.parse({
        requestTimeoutMs: 15000,
        generalMethodTimeoutMs: 30000,
        collectionAdminTimeoutMs: 60000,
        tableAdminTimeoutMs: 30000,
        databaseAdminTimeoutMs: 600000,
        keyspaceAdminTimeoutMs: 30000,
    })
});
Object.defineProperty(Timeouts, "fmtTimeoutMsg", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: (tm, timeoutTypes) => {
        const timeout = (timeoutTypes === 'provided')
            ? Object.values(tm.initial())[0]
            : tm.initial()[timeoutTypes[0]];
        const types = (timeoutTypes === 'provided')
            ? `The timeout provided via \`{ timeout: <number> }\` timed out` :
            (timeoutTypes.length > 1)
                ? timeoutTypes.join(' and ') + ' simultaneously timed out'
                : `${timeoutTypes[0]} timed out`;
        return `Command timed out after ${timeout}ms (${types})`;
    }
});
