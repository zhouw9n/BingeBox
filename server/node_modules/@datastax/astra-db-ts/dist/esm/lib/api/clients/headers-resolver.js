// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
import { HeadersProvider, PureHeadersProvider } from '../../../lib/index.js';
export class HeadersResolver {
    constructor(target, additionalHeaders, baseHeaders) {
        Object.defineProperty(this, "_resolveStrategy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const queue = this._mkResolveQueue(target, additionalHeaders);
        if (queue.length <= 1 && !(queue[0] instanceof HeadersProvider)) {
            this._resolveStrategy = new StaticHeadersResolveStrategy({ ...baseHeaders, ...queue[0] });
        }
        else {
            this._resolveStrategy = new DynamicHeadersResolveStrategy(target, baseHeaders, queue);
        }
    }
    resolve() {
        return this._resolveStrategy.resolve();
    }
    _mkResolveQueue(target, headerProviders) {
        const ctx = { for: target };
        const ret = [];
        let acc = {};
        for (const provider of headerProviders.providers) {
            // noinspection SuspiciousTypeOfGuard -- the lsp is wrong here
            if (provider instanceof PureHeadersProvider) {
                assignNonUndefined(acc, provider.getHeaders(ctx));
            }
            else {
                ret.push(acc);
                acc = {};
                ret.push(provider);
            }
        }
        if (Object.keys(acc).length > 0) {
            ret.push(acc);
        }
        return ret;
    }
}
class StaticHeadersResolveStrategy {
    constructor(_headers) {
        Object.defineProperty(this, "_headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _headers
        });
    }
    resolve() {
        return this._headers;
    }
}
class DynamicHeadersResolveStrategy {
    constructor(_target, _baseHeaders, _resolveQueue) {
        Object.defineProperty(this, "_target", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _target
        });
        Object.defineProperty(this, "_baseHeaders", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _baseHeaders
        });
        Object.defineProperty(this, "_resolveQueue", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _resolveQueue
        });
    }
    async resolve() {
        const headers = { ...this._baseHeaders };
        for (const item of this._resolveQueue) {
            if (item instanceof HeadersProvider) {
                assignNonUndefined(headers, await item.getHeaders({ for: this._target }));
            }
            else {
                assignNonUndefined(headers, item);
            }
        }
        return headers;
    }
}
function assignNonUndefined(target, source) {
    for (const key in source) {
        if (source[key] !== undefined) {
            target[key] = source[key];
        }
    }
}
