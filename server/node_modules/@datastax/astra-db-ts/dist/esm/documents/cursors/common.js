// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
import { CursorError } from '../../documents/cursors/abstract-cursor.js';
import { SerDesTarget } from '../../lib/api/ser-des/ctx.js';
export const cloneFLC = (cursor, filter, options, mapping) => {
    return new cursor.constructor(cursor.dataSource, cursor._serdes, filter, options, mapping);
};
export const buildFLCOption = (cursor, key, value) => {
    if (cursor.state !== 'idle') {
        throw new CursorError(`Cannot set a new ${key} on a running/closed cursor`, cursor);
    }
    return cloneFLC(cursor, cursor._filter, { ...cursor._options, [key]: value }, cursor._mapping);
};
export const buildFLCPreMapOption = (cursor, key, value) => {
    if (cursor._mapping) {
        throw new CursorError(`Cannot set a new ${key} after already using cursor.map(...)`, cursor);
    }
    return buildFLCOption(cursor, key, value);
};
export const buildFLCMap = (cursor, map) => {
    if (cursor.state !== 'idle') {
        throw new CursorError('Cannot set a new mapping on a running/closed cursor', cursor);
    }
    const mapping = cursor._mapping
        ? (doc) => map(cursor._mapping(doc))
        : map;
    return cloneFLC(cursor, cursor._filter, cursor._options, mapping);
};
export const buildFLCFilter = (cursor, filter) => {
    if (cursor.state !== 'idle') {
        throw new CursorError(`Cannot set a new filter on a running/closed cursor`, cursor);
    }
    return cloneFLC(cursor, cursor._serdes.serialize(filter, SerDesTarget.Filter), cursor._options, cursor._mapping);
};
export const buildFLCSort = (cursor, sort) => {
    return buildFLCOption(cursor, 'sort', cursor._serdes.serialize(sort, SerDesTarget.Sort)[0]);
};
