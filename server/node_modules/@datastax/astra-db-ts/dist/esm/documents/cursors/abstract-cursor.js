// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
import { DataAPIError } from '../../documents/errors.js';
import { QueryState } from '../../lib/utils.js';
export class CursorError extends DataAPIError {
        constructor(message, cursor) {
        super(message);
                Object.defineProperty(this, "cursor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = 'CursorError';
        this.cursor = cursor;
        this.state = cursor.state;
    }
}
export class AbstractCursor {
        constructor(options, mapping) {
                Object.defineProperty(this, "_consumed", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
                Object.defineProperty(this, "_buffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
                Object.defineProperty(this, "_state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'idle'
        });
                Object.defineProperty(this, "_nextPageState", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new QueryState()
        });
                Object.defineProperty(this, "_mapping", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "_options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._options = options;
        this._mapping = mapping;
    }
        get state() {
        return this._state;
    }
        buffered() {
        return this._buffer.length;
    }
        consumed() {
        return this._consumed;
    }
        consumeBuffer(max) {
        const ret = this._buffer.splice(0, max ?? this._buffer.length);
        this._consumed += ret.length;
        return ret;
    }
        rewind() {
        this._buffer.length = 0;
        this._nextPageState = new QueryState();
        this._state = 'idle';
        this._consumed = 0;
    }
        close() {
        this._state = 'closed';
        this._buffer.length = 0;
    }
        [Symbol.asyncIterator]() {
        return this._iterator('[asyncIterator]');
    }
        next() {
        return this._next(false, '.next');
    }
        async hasNext() {
        return await this._next(true, '.hasNext') !== null;
    }
        async forEach(consumer) {
        for await (const doc of this._iterator('.forEach')) {
            const resp = consumer(doc);
            const stop = (resp === undefined) ? resp : await resp;
            if (stop === false) {
                break;
            }
        }
    }
        async toArray() {
        const docs = [];
        const tm = this._tm().multipart('generalMethodTimeoutMs', this._options);
        for await (const doc of this._iterator('.toArray', tm)) {
            docs.push(doc);
        }
        return docs;
    }
        async *_iterator(method, tm) {
        if (this._state === 'closed') {
            throw new CursorError('Cannot iterate over a closed cursor', this);
        }
        try {
            for (let doc; (doc = await this._next(false, method, tm));) {
                yield doc;
            }
        }
        finally {
            this.close();
        }
    }
        async _next(peek, method, tm) {
        if (this._state === 'closed') {
            return null;
        }
        try {
            while (this._buffer.length === 0) {
                if (this._nextPageState.state === QueryState.NotFound) {
                    this.close();
                    return null;
                }
                this._buffer = await this._nextPage({ method }, tm);
            }
            if (peek) {
                return true;
            }
            this._state = 'started';
            const doc = this._buffer.shift();
            if (doc) {
                this._consumed++;
            }
            return (doc && this._mapping)
                ? this._mapping(doc)
                : doc;
        }
        catch (e) {
            this.close();
            throw e;
        }
    }
}
