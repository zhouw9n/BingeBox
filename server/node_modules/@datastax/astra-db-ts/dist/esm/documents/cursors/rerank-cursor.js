// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
import { vector } from '../../documents/index.js';
import { AbstractCursor } from '../../documents/cursors/abstract-cursor.js';
import { $CustomInspect } from '../../lib/constants.js';
import { SerDesTarget } from '../../lib/api/ser-des/ctx.js';
import { buildFLCFilter, buildFLCMap, buildFLCOption, buildFLCPreMapOption, buildFLCSort, cloneFLC, } from '../../documents/cursors/common.js';
import { QueryState } from '../../lib/utils.js';
export class RerankedResult {
    constructor(document, scores) {
                Object.defineProperty(this, "document", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "scores", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.document = document;
        this.scores = scores;
    }
}
export class FindAndRerankCursor extends AbstractCursor {
        constructor(parent, serdes, filter, options, mapping) {
        super(options ?? {}, mapping);
                Object.defineProperty(this, "_httpClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "_serdes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "_parent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "_filter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "_sortVector", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new QueryState()
        });
        this._parent = parent;
        this._httpClient = parent._httpClient;
        this._serdes = serdes;
        this._filter = filter;
    }
        [$CustomInspect]() {
        return `${this.constructor.name}(source="${this._parent.keyspace}.${this._parent.name}",state="${this._state}",consumed=${this.consumed()},buffered=${this.buffered()})`;
    }
        filter(filter) {
        return buildFLCFilter(this, filter);
    }
        sort(sort) {
        return buildFLCSort(this, sort);
    }
        limit(limit) {
        return buildFLCOption(this, 'limit', limit || undefined);
    }
        hybridLimits(hybridLimits) {
        return buildFLCOption(this, 'hybridLimits', hybridLimits);
    }
        rerankOn(rerankOn) {
        return buildFLCOption(this, 'rerankOn', rerankOn);
    }
        rerankQuery(rerankQuery) {
        return buildFLCOption(this, 'rerankQuery', rerankQuery);
    }
        includeScores(includeScores) {
        return buildFLCOption(this, 'includeScores', includeScores ?? true);
    }
        includeSortVector(includeSortVector) {
        return buildFLCOption(this, 'includeSortVector', includeSortVector ?? true);
    }
        project(projection) {
        return buildFLCPreMapOption(this, 'projection', projection);
    }
        map(map) {
        return buildFLCMap(this, map);
    }
        async getSortVector() {
        if (this._sortVector.state === QueryState.Unattempted && this._options.includeSortVector) {
            const reset2idle = this._state === 'idle';
            await this._next(true, '.getSortVector');
            if (reset2idle) {
                this._state = 'idle';
            }
        }
        return this._sortVector.unwrap();
    }
        clone() {
        return cloneFLC(this, this._filter, this._options, this._mapping);
    }
        async _nextPage(extra, tm) {
        const command = {
            findAndRerank: {
                filter: this._filter[0],
                projection: this._options.projection,
                sort: this._options.sort,
                options: {
                    limit: this._options.limit,
                    hybridLimits: this._options.hybridLimits,
                    rerankOn: this._options.rerankOn,
                    rerankQuery: this._options.rerankQuery,
                    includeScores: this._options.includeScores,
                    includeSortVector: this._options.includeSortVector,
                },
            },
        };
        const raw = await this._httpClient.executeCommand(command, {
            timeoutManager: tm ?? this._httpClient.tm.single('generalMethodTimeoutMs', this._options),
            bigNumsPresent: this._filter[1],
            extraLogInfo: extra,
        });
        this._nextPageState.swap(raw.data?.nextPageState);
                const buffer = raw.data?.documents ?? [];
        for (let i = 0, n = buffer.length; i < n; i++) {
            const deserialized = this._serdes.deserialize(buffer[i], raw, SerDesTarget.Record);
            buffer[i] = new RerankedResult(deserialized, raw.status?.documentResponses?.[i]?.scores ?? {});
        }
        const sortVector = raw.status?.sortVector;
        this._sortVector.swap(sortVector ? vector(sortVector) : sortVector);
        this._options.includeSortVector = false;
        return buffer;
    }
        _tm() {
        return this._httpClient.tm;
    }
}
