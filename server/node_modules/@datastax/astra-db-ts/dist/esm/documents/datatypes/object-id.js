// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
import { isNullish } from '../../lib/utils.js';
import { $CustomInspect } from '../../lib/constants.js';
import { $SerializeForTable } from '../../documents/tables/ser-des/constants.js';
import { $DeserializeForCollection, $SerializeForCollection } from '../../documents/collections/ser-des/constants.js';
import { mkTypeUnsupportedForTablesError } from '../../lib/api/ser-des/utils.js';
const objectIdRegex = new RegExp('^[0-9a-fA-F]{24}$');
export const oid = (id) => (id instanceof ObjectId) ? id : new ObjectId(id);
export class ObjectId {
        [$SerializeForTable]() {
        throw mkTypeUnsupportedForTablesError('ObjectId', [
            'Use another object ID representation, such as a string',
        ]);
    }
    ;
        [$SerializeForCollection](ctx) {
        return ctx.done({ $objectId: this._raw });
    }
    ;
        static [$DeserializeForCollection](value, ctx) {
        return ctx.done(new ObjectId(value.$objectId, false));
    }
        constructor(id, validate = true) {
        Object.defineProperty(this, "_raw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (validate) {
            if (typeof id === 'string') {
                if (id.length !== 24 || !objectIdRegex.test(id)) {
                    throw new Error('ObjectId must be a 24-character hex string');
                }
            }
            else if (typeof id !== 'number' && !isNullish(id) && !(id instanceof ObjectId)) {
                throw new Error('ObjectId must be a string, number, nullish, or another ObjectId instance');
            }
        }
        Object.defineProperty(this, '_raw', {
            value: (typeof id === 'string') ? id.toLowerCase() : (id instanceof ObjectId) ? id._raw : genObjectId(id, ObjectIDGenIndex),
        });
        Object.defineProperty(this, $CustomInspect, {
            value: () => `ObjectId("${this._raw}")`,
        });
    }
        equals(other) {
        if (typeof other === 'string') {
            return this._raw.localeCompare(other, undefined, { sensitivity: 'accent' }) === 0;
        }
        if (other instanceof ObjectId) {
            return this._raw.localeCompare(other._raw, undefined, { sensitivity: 'accent' }) === 0;
        }
        return false;
    }
        getTimestamp() {
        const time = parseInt(this._raw.slice(0, 8), 16);
        return new Date(~~time * 1000);
    }
        toString() {
        return this._raw;
    }
}
const RAND_ID = ~~(Math.random() * 0xFFFFFF);
const PID = ~~(Math.random() * 100000) % 0xFFFF;
const HexTable = Array.from({ length: 256 }, (_, i) => {
    return (i <= 15 ? '0' : '') + i.toString(16);
});
let ObjectIDGenIndex = ~~(Math.random() * 0xFFFFFF);
/**
 * @internal
 */
export function genObjectId(time, genIndex) {
    time ?? (time = ~~(Date.now() / 1000));
    time = time % 0xFFFFFFFF;
    ObjectIDGenIndex = (genIndex + 1) % 0xFFFFFF;
    let hexString = '';
    hexString += HexTable[((time >> 24) & 0xFF)];
    hexString += HexTable[((time >> 16) & 0xFF)];
    hexString += HexTable[((time >> 8) & 0xFF)];
    hexString += HexTable[(time & 0xFF)];
    hexString += HexTable[((RAND_ID >> 16) & 0xFF)];
    hexString += HexTable[((RAND_ID >> 8) & 0xFF)];
    hexString += HexTable[(RAND_ID & 0xFF)];
    hexString += HexTable[((PID >> 8) & 0xFF)];
    hexString += HexTable[(PID & 0xFF)];
    hexString += HexTable[((ObjectIDGenIndex >> 16) & 0xFF)];
    hexString += HexTable[((ObjectIDGenIndex >> 8) & 0xFF)];
    hexString += HexTable[(ObjectIDGenIndex & 0xFF)];
    return hexString;
}
