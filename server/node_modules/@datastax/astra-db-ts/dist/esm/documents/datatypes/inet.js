// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
import { $CustomInspect } from '../../lib/constants.js';
import { $SerializeForCollection } from '../../documents/collections/ser-des/constants.js';
import { $DeserializeForTable, $SerializeForTable } from '../../documents/tables/ser-des/constants.js';
import { mkTypeUnsupportedForCollectionsError } from '../../lib/api/ser-des/utils.js';
export const inet = (address, version) => new DataAPIInet(address, version);
export class DataAPIInet {
        [$SerializeForCollection]() {
        throw mkTypeUnsupportedForCollectionsError('DataAPIInet', '_inet', [
            'Use another inet representation, such as a string, or an object containing the inet address, and the version',
        ]);
    }
    ;
        [$SerializeForTable](ctx) {
        return ctx.done(this._raw);
    }
    ;
        static [$DeserializeForTable](value, ctx) {
        return ctx.done(new DataAPIInet(value, null, false));
    }
        static isIPv6(raw) {
        if (raw.length < IPv6Lengths.min || IPv6Lengths.max < raw.length) {
            return false;
        }
        return IPv6Regex.test(raw);
    }
        static isIPv4(raw) {
        if (raw.length < IPv4Lengths.min || IPv4Lengths.max < raw.length) {
            return false;
        }
        return IPv4Regex.test(raw);
    }
        constructor(address, version, validate = true) {
        Object.defineProperty(this, "_raw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const addressStr = (address instanceof DataAPIInet) ? address._raw : address;
        if (validate) {
            switch (version) {
                case 4:
                    if (!DataAPIInet.isIPv4(addressStr)) {
                        throw new Error(`'${address}' is not a valid IPv4 address`);
                    }
                    break;
                case 6:
                    if (!DataAPIInet.isIPv6(addressStr)) {
                        throw new Error(`'${address}' is not a valid IPv6 address`);
                    }
                    break;
                default:
                    if (!(version = DataAPIInet.isIPv4(addressStr) ? 4 : DataAPIInet.isIPv6(addressStr) ? 6 : null)) {
                        throw new Error(`'${address}' is not a valid IPv4 or IPv6 address`);
                    }
            }
        }
        this._raw = addressStr.toLowerCase();
        this._version = version;
        Object.defineProperty(this, $CustomInspect, {
            value: () => `DataAPIInet<${this.version}>("${this._raw}")`,
        });
    }
        get version() {
        if (!this._version) {
            this._version = DataAPIInet.isIPv4(this._raw) ? 4 : 6;
        }
        return this._version;
    }
        toString() {
        return this._raw;
    }
}
const IPv4Lengths = { max: 15, min: 7 };
const IPv6Lengths = { max: 45, min: 2 };
// =====================================================================================================================
// Vendored from https://github.com/sindresorhus/ip-regex/blob/main/index.js
// Was getting errors trying to import it while as a dependency, so just decided not to deal with it for the time being
const v4 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';
const v6segment = '[a-fA-F\\d]{1,4}';
const v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim();
const IPv4Regex = new RegExp(`^${v4}$`);
const IPv6Regex = new RegExp(`^${v6}$`);
// =====================================================================================================================
