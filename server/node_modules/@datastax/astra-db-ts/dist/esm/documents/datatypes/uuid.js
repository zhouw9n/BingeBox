// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
import * as _uuid from 'uuid';
import { $CustomInspect } from '../../lib/constants.js';
import { $DeserializeForCollection, $SerializeForCollection } from '../../documents/collections/ser-des/constants.js';
import { $DeserializeForTable, $SerializeForTable } from '../../documents/tables/ser-des/constants.js';
export class UUID {
        [$SerializeForTable](ctx) {
        return ctx.done(this._raw);
    }
    ;
        [$SerializeForCollection](ctx) {
        return ctx.done({ $uuid: this._raw });
    }
    ;
        static [$DeserializeForTable](value, ctx) {
        return ctx.done(new UUID(value, false));
    }
        static [$DeserializeForCollection](value, ctx) {
        return ctx.done(new UUID(value.$uuid, false));
    }
        constructor(uuid, validate = true, version = 0) {
                Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_raw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (validate) {
            if (typeof uuid === 'string') {
                if (!_uuid.validate(uuid)) {
                    throw new Error(`UUID '${uuid}' is not a valid UUID`);
                }
            }
            else if (!(uuid instanceof UUID)) {
                throw new Error(`UUID '${uuid}' must be a string or another UUID instance`);
            }
        }
        Object.defineProperty(this, '_raw', {
            value: (typeof uuid === 'string') ? uuid.toLowerCase() : uuid._raw,
        });
        Object.defineProperty(this, 'version', {
            value: version || parseInt(this._raw[14], 16),
        });
        Object.defineProperty(this, $CustomInspect, {
            value: () => `UUID<${this.version}>("${this._raw}")`,
        });
    }
        equals(other) {
        if (typeof other === 'string') {
            return this._raw === other.toLowerCase();
        }
        if (other instanceof UUID) {
            return this._raw === other._raw;
        }
        return false;
    }
        getTimestamp() {
        switch (this.version) {
            case 1:
                return uuidV1Timestamp(this);
            case 7:
                return uuidV7Timestamp(this);
            default:
                return undefined;
        }
    }
        toString() {
        return this._raw;
    }
        static v1(msecs, nsecs) {
        return new UUID(_uuid.v1({ msecs, nsecs }), false, 1);
    }
        static v4() {
        return new UUID(_uuid.v4(), false, 4);
    }
        static v6(msecs, nsecs) {
        return new UUID(_uuid.v6({ msecs, nsecs }), false, 6);
    }
        static v7(msecs) {
        return new UUID(_uuid.v7({ msecs }), false, 7);
    }
}
export const uuid = Object.assign((uuid) => (uuid instanceof UUID) ? uuid : new UUID(uuid), {
    v1: UUID.v1,
    v4: UUID.v4,
    v6: UUID.v6,
    v7: UUID.v7,
});
const MAGIC_NUMBER = 1221929280000000 * 100;
function uuidV1Timestamp(uuid) {
    const arr = uuid.toString().split('-');
    const timeStr = [arr[2].substring(1), arr[1], arr[0]].join('');
    const timeInt = parseInt(timeStr, 16);
    return new Date(~~((timeInt - MAGIC_NUMBER) / 10000));
}
function uuidV7Timestamp(uuid) {
    const timestampBytes = new Uint8Array(8);
    timestampBytes.set(new Uint8Array(_uuid.parse(uuid.toString()).buffer.slice(0, 6)), 2);
    const timestampMs = new DataView(timestampBytes.buffer).getBigUint64(0);
    return new Date(Number(timestampMs));
}
