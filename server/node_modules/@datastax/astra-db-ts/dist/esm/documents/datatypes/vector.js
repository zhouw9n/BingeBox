// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
import { $CustomInspect } from '../../lib/constants.js';
import { $DeserializeForCollection, $SerializeForCollection } from '../../documents/collections/ser-des/constants.js';
import { $DeserializeForTable, $SerializeForTable } from '../../documents/tables/ser-des/constants.js';
import { forJSEnv } from '../../lib/utils.js';
import { betterTypeOf } from '../../documents/utils.js';
export const vector = (v) => (v instanceof DataAPIVector) ? v : new DataAPIVector(v);
export class DataAPIVector {
        [$SerializeForTable](ctx) {
        return ctx.done(this.serialize());
    }
    ;
        [$SerializeForCollection](ctx) {
        return ctx.done(this.serialize());
    }
    ;
        static [$DeserializeForTable](value, ctx) {
        return ctx.done(new DataAPIVector(value, false));
    }
        static [$DeserializeForCollection](value, ctx) {
        return ctx.done(new DataAPIVector(value, false));
    }
        constructor(vector, validate = true) {
        Object.defineProperty(this, "_vector", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (validate && !DataAPIVector.isVectorLike(vector)) {
            throw new Error(`Invalid vector type; expected number[], { $binary: string }, Float32Array, or DataAPIVector; got '${betterTypeOf(vector)}'`);
        }
        Object.defineProperty(this, '_vector', {
            value: (vector instanceof DataAPIVector)
                ? vector.raw()
                : vector,
        });
        Object.defineProperty(this, $CustomInspect, {
            value: this.toString.bind(this),
        });
    }
        get length() {
        if ('$binary' in this._vector) {
            return ~~((this._vector.$binary.replace(/=+$/, '').length * 3) / 4 / 4);
        }
        return this._vector.length;
    }
    /**
     * Gets the raw underlying implementation of the vector.
     *
     * @returns The raw vector
     */
    raw() {
        return this._vector;
    }
    /**
     * Returns the vector as a `number[]`, converting between types if necessary.
     *
     * @returns The vector as a `number[]`
     */
    asArray() {
        if (this._vector instanceof Float32Array) {
            return Array.from(this._vector);
        }
        if ('$binary' in this._vector) {
            const deserialized = deserializeToNumberArray(this._vector.$binary);
            if (!deserialized) {
                throw new Error('Could not to deserialize vector from base64 => number[]; unknown environment. Please manually deserialize the binary from `vector.getAsBase64()`');
            }
            return deserialized;
        }
        return this._vector;
    }
        asFloat32Array() {
        if (this._vector instanceof Float32Array) {
            return this._vector;
        }
        if ('$binary' in this._vector) {
            const deserialized = deserializeToF32Array(this._vector.$binary);
            if (!deserialized) {
                throw new Error('Could not to deserialize vector from base64 => Float32Array; unknown environment. Please manually deserialize the binary from `vector.getAsBase64()`');
            }
            return deserialized;
        }
        return new Float32Array(this._vector);
    }
        asBase64() {
        const serialized = this.serialize();
        if (!('$binary' in serialized)) {
            if (Array.isArray(this._vector)) {
                throw new Error('Could not convert vector from number[] => base64; unknown environment. Please manually serialize the binary from `vector.raw()`/`vector.getAsArray()`');
            }
            else {
                throw new Error('Could not convert vector from Float32Array => base64; unknown environment. Please manually serialize the binary from `vector.raw()`/`vector.getAsFloat32Array()`');
            }
        }
        return serialized.$binary;
    }
        toString() {
        const type = ('$binary' in this._vector && 'base64') || (this._vector instanceof Float32Array && 'Float32Array') || 'number[]';
        const partial = ('$binary' in this._vector)
            ? `"${this._vector.$binary.slice(0, 12)}${this._vector.$binary.length > 12 ? '...' : ''}"`
            : `[${this._vector.slice(0, 2).join(', ')}${this._vector.length > 2 ? ', ...' : ''}]`;
        return `DataAPIVector<${this.length}>(typeof raw=${type}, preview=${partial})`;
    }
        static isVectorLike(value) {
        return !!value && typeof value === 'object' && ((Array.isArray(value) && typeof value[0] === 'number') || value instanceof Float32Array || ('$binary' in value && typeof value.$binary === 'string') || value instanceof DataAPIVector);
    }
        serialize() {
        if ('$binary' in this._vector) {
            return this._vector;
        }
        return serializeFromArray(this._vector);
    }
}
const serializeFromArray = forJSEnv({
    server: (vector) => {
        const buffer = Buffer.allocUnsafe(vector.length * 4);
        for (let i = 0; i < vector.length; i++) {
            buffer.writeFloatBE(vector[i], i * 4);
        }
        return { $binary: buffer.toString('base64') };
    },
    browser: (vector) => {
        const buffer = new Uint8Array(vector.length * 4);
        const view = new DataView(buffer.buffer);
        for (let i = 0; i < vector.length; i++) {
            view.setFloat32(i * 4, vector[i], false);
        }
        let binary = '';
        for (const byte of buffer) {
            binary += String.fromCharCode(byte);
        }
        return { $binary: window.btoa(binary) };
    },
    unknown: (vector) => {
        if (vector instanceof Float32Array) {
            return Array.from(vector);
        }
        return vector;
    },
});
const deserializeToNumberArray = forJSEnv({
    server: (serialized) => {
        const buffer = Buffer.from(serialized, 'base64');
        const vector = Array.from({ length: buffer.length / 4 });
        for (let i = 0; i < vector.length; i++) {
            vector[i] = buffer.readFloatBE(i * 4);
        }
        return vector;
    },
    browser: (serialized) => {
        const deserialized = deserializeToF32Array(serialized);
        return Array.from(deserialized);
    },
    unknown: () => {
        return undefined;
    },
});
const deserializeToF32Array = forJSEnv({
    server: (serialized) => {
        const buffer = Buffer.from(serialized, 'base64');
        const vector = new Float32Array(buffer.length / 4);
        for (let i = 0; i < vector.length; i++) {
            vector[i] = buffer.readFloatBE(i * 4);
        }
        return vector;
    },
    browser: (serialized) => {
        const binary = window.atob(serialized);
        const buffer = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            buffer[i] = binary.charCodeAt(i);
        }
        const vector = new Float32Array(buffer.buffer);
        const view = new DataView(buffer.buffer);
        for (let i = 0; i < vector.length; i++) {
            vector[i] = view.getFloat32(i * 4, false);
        }
        return vector;
    },
    unknown: () => {
        return undefined;
    },
});
