// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
import { $CustomInspect } from '../../lib/constants.js';
import { $SerializeForCollection } from '../../documents/collections/ser-des/constants.js';
import { $DeserializeForTable, $SerializeForTable } from '../../documents/tables/ser-des/constants.js';
import { forJSEnv } from '../../lib/utils.js';
import { SerDesTarget } from '../../lib/api/ser-des/ctx.js';
import { mkInvArgsError } from '../../documents/utils.js';
import { mkTypeUnsupportedForCollectionsError } from '../../lib/api/ser-des/utils.js';
export const blob = (blob) => (blob instanceof DataAPIBlob) ? blob : new DataAPIBlob(blob);
export class DataAPIBlob {
        [$SerializeForCollection]() {
        throw mkTypeUnsupportedForCollectionsError('DataAPIBlob', '_blob', [
            'Use another blob representation, such as a base64 string',
        ]);
    }
    ;
        [$SerializeForTable](ctx) {
        return ctx.done({ $binary: this.asBase64() });
    }
    ;
        static [$DeserializeForTable](value, ctx) {
        return ctx.done(new DataAPIBlob((ctx.target === SerDesTarget.InsertedId) ? { $binary: value } : value, false));
    }
        constructor(blob, validate = true) {
        Object.defineProperty(this, "_raw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (validate && !DataAPIBlob.isBlobLike(blob)) {
            throw mkInvArgsError('new DataAPIBlob', [['blob', 'DataAPIBlob | ArrayBuffer | Buffer | { $binary: string }']], blob);
        }
        Object.defineProperty(this, '_raw', {
            value: (blob instanceof DataAPIBlob)
                ? blob._raw
                : blob,
        });
        Object.defineProperty(this, $CustomInspect, {
            value: this.toString.bind(this),
        });
    }
        get byteLength() {
        if (this._raw instanceof ArrayBuffer) {
            return this._raw.byteLength;
        }
        if ('$binary' in this._raw) {
            return ~~((this._raw.$binary.replace(/=+$/, '').length * 3) / 4);
        }
        return this._raw.length;
    }
    /**
     * Gets the raw underlying implementation of the blob.
     *
     * @returns The raw blob
     */
    raw() {
        return this._raw;
    }
    /**
     * Returns the blob as an `ArrayBuffer`, converting between types if necessary.
     *
     * @returns The blob as an `ArrayBuffer`
     */
    asArrayBuffer() {
        if (this._raw instanceof ArrayBuffer) {
            return this._raw;
        }
        if ('$binary' in this._raw) {
            return base64ToArrayBuffer(this._raw.$binary);
        }
        return bufferToArrayBuffer(this._raw);
    }
        asBuffer() {
        if (typeof Buffer === 'undefined') {
            throw new Error("Buffer is not available in this environment");
        }
        if (this._raw instanceof Buffer) {
            return this._raw;
        }
        if (this._raw instanceof ArrayBuffer) {
            return Buffer.from(this._raw);
        }
        return Buffer.from(this._raw.$binary, 'base64');
    }
        asBase64() {
        if (this._raw instanceof ArrayBuffer) {
            return arrayBufferToBase64(this._raw);
        }
        if ('$binary' in this._raw) {
            return this._raw.$binary;
        }
        return this._raw.toString('base64');
    }
        toString() {
        const type = (this._raw instanceof ArrayBuffer && 'ArrayBuffer') || (this._raw instanceof Buffer && 'Buffer') || 'base64';
        return `DataAPIBlob(typeof raw=${type}, byteLength=${this.byteLength})`;
    }
        static isBlobLike(value) {
        return !!value && typeof value === 'object' && (value instanceof DataAPIBlob || ('$binary' in value && typeof value.$binary === 'string') || value instanceof ArrayBuffer || value instanceof Buffer);
    }
}
const base64ToArrayBuffer = forJSEnv({
    server: (base64) => {
        return bufferToArrayBuffer(Buffer.from(base64, 'base64'));
    },
    browser: (base64) => {
        const binaryString = window.atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    },
    unknown: () => {
        throw new Error("Cannot convert base64 to Buffer/ArrayBuffer in this environment; please do so manually");
    },
});
const arrayBufferToBase64 = forJSEnv({
    server: (buffer) => {
        return Buffer.from(buffer).toString('base64');
    },
    browser: (buffer) => {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        for (const byte of bytes) {
            binary += String.fromCharCode(byte);
        }
        return window.btoa(binary);
    },
    unknown: () => {
        throw new Error("Cannot convert Buffer/ArrayBuffer to base64 in this environment; please do so manually");
    },
});
function bufferToArrayBuffer(b) {
    return b.buffer.slice(b.byteOffset, b.byteOffset + b.byteLength);
}
