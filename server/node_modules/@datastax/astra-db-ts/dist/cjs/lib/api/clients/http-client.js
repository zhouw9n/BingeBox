"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = void 0;
const timeouts_js_1 = require("../../../lib/api/timeouts/timeouts.js");
const headers_resolver_js_1 = require("../../../lib/api/clients/headers-resolver.js");
class HttpClient {
    constructor(target, options) {
        Object.defineProperty(this, "baseUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fetchCtx", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "headersResolver", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tm", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.baseUrl = options.baseUrl;
        this.logger = options.logger;
        this.fetchCtx = options.fetchCtx;
        if (options.baseApiPath) {
            this.baseUrl += '/' + options.baseApiPath;
        }
        // this.baseHeaders = { ...options.additionalHeaders };
        // this.baseHeaders['User-Agent'] = options.caller.userAgent;
        // this.baseHeaders['Content-Type'] = 'application/json';
        //
        // this.headerProviders = headerProviders;
        this.headersResolver = new headers_resolver_js_1.HeadersResolver(target, options.additionalHeaders, {
            'User-Agent': options.caller.userAgent,
            'Content-Type': 'application/json',
        });
        this.tm = new timeouts_js_1.Timeouts(options.mkTimeoutError, options.timeoutDefaults);
    }
    async _request(info) {
        if (this.fetchCtx.closed.ref) {
            throw new Error('Can\'t make requests on a closed client');
        }
        const [msRemaining, mkTimeoutError] = info.timeoutManager.advance(info);
        if (msRemaining <= 0) {
            throw mkTimeoutError();
        }
        const params = info.params ?? {};
        const url = (Object.keys(params).length > 0)
            ? `${info.url}?${new URLSearchParams(params).toString()}`
            : info.url;
        const maybePromiseHeaders = this.headersResolver.resolve();
        const headers = (maybePromiseHeaders instanceof Promise)
            ? await maybePromiseHeaders
            : maybePromiseHeaders;
        return await this.fetchCtx.ctx.fetch({
            url: url,
            body: info.data,
            method: info.method,
            headers: headers,
            forceHttp1: !!info.forceHttp1,
            timeout: msRemaining,
            mkTimeoutError,
        });
    }
}
exports.HttpClient = HttpClient;
