"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.mkTypeUnsupportedForTablesError = exports.mkTypeUnsupportedForCollectionsError = exports.assertHasDeserializeFor = exports.assertHasSerializeFor = void 0;
exports.withJbiNullProtoFix = withJbiNullProtoFix;
exports.pathArraysEqual = pathArraysEqual;
exports.pathMatches = pathMatches;
const bignumber_js_1 = require("bignumber.js");
const utils_js_1 = require("../../../lib/utils.js");
const assertHasSerializeFor = (clazz, sym, synName) => {
    if (!(sym in clazz.prototype)) {
        throw new Error(`Invalid codec class: '${clazz.name}' - missing ${clazz.name}.prototype.[${synName}]

Did you define [${synName}] as a class property instead of a prototype method?

Don't do this:
> class Bad { [${synName}] = () => ...; }

Or this:
> Bad[${synName}] = () => ...;

Do this:
> class Good { [${synName}]() { ... } }

Or this:
> Good.prototype[${synName}] = () => ...;`);
    }
};
exports.assertHasSerializeFor = assertHasSerializeFor;
const assertHasDeserializeFor = (clazz, sym, synName) => {
    if (!(sym in clazz)) {
        throw new Error(`Invalid codec class: '${clazz.name}' - missing ${clazz.name}.[${synName}]

Did you forget to define [${synName}] on the class?

Don't do this:
> class Bad { [${synName}] = () => ...; }

Do this:
> class Good { [${synName}]() { ... } }

Or this:
> Good[${synName}] = () => ...;`);
    }
};
exports.assertHasDeserializeFor = assertHasDeserializeFor;
const mkTypeUnsupportedForCollectionsError = (type, fauxTypeName, alternatives) => {
    return new Error([
        `${type} may not be used with collections by default.`,
        '',
        'Please use one of the following alternatives:',
        ...[...alternatives, 'Write a custom codec for ${type} (beta)'].map((alt, i) => `${i + 1}. ${alt}`),
        '',
        'See the `CollectionCodecs` class for more information about writing your own collection codec.',
        '',
        `Keep in mind that you may need to use CollectionCodecs.forType(...) to create a faux custom type (e.g. { ${fauxTypeName}: <${type}> }) representing a ${type} so that the value may be identifiable as needing to be deserialized back into a ${type} as well`,
    ].join('\n'));
};
exports.mkTypeUnsupportedForCollectionsError = mkTypeUnsupportedForCollectionsError;
const mkTypeUnsupportedForTablesError = (type, alternatives) => {
    return new Error([
        `${type} may not be used with tables by default.`,
        '',
        'Please use one of the following alternatives:',
        ...[...alternatives, 'Write a custom codec for ${type} (beta)'].map((alt, i) => `${i + 1}. ${alt}`),
        '',
        'See the `TablesCodec` class for more information about writing your own table codec.',
    ].join('\n'));
};
exports.mkTypeUnsupportedForTablesError = mkTypeUnsupportedForTablesError;
function withJbiNullProtoFix(jbi) {
    return {
        parse: (str) => nullProtoFix(jbi.parse(str)),
        stringify: jbi.stringify,
    };
}
function nullProtoFix(doc) {
    if (!doc || typeof doc !== 'object') {
        return doc;
    }
    if ((0, utils_js_1.isBigNumber)(doc)) {
        return (0, bignumber_js_1.BigNumber)(doc);
    }
    if (Array.isArray(doc)) {
        for (let i = 0; i < doc.length; i++) {
            doc[i] = nullProtoFix(doc[i]);
        }
    }
    else {
        Object.setPrototypeOf(doc, Object.prototype);
        for (const key of Object.keys(doc)) {
            doc[key] = nullProtoFix(doc[key]);
        }
    }
    return doc;
}
function pathArraysEqual(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
function pathMatches(exp, acc) {
    if (exp.length !== acc.length) {
        return false;
    }
    for (let i = 0; i < acc.length; i++) {
        if (exp[i] !== '*' && exp[i] !== acc[i]) {
            return false;
        }
    }
    return true;
}
