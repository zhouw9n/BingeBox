"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.processCodecs = void 0;
const utils_js_1 = require("../../../lib/api/ser-des/utils.js");
const processCodecs = (raw) => {
    const serializers = { forName: Object.create(null), forPath: Object.create(null), forClass: [], forGuard: [] };
    const deserializers = { forName: Object.create(null), forPath: Object.create(null), forType: Object.create(null), forGuard: [] };
    for (const codec of raw) {
        appendCodec[codec.tag](codec, serializers, deserializers);
    }
    return [serializers, deserializers];
};
exports.processCodecs = processCodecs;
const appendCodec = {
    forName(codec, serializers, deserializers) {
        var _a, _b, _c, _d;
        if (codec.opts.serialize) {
            ((_a = serializers.forName)[_b = codec.name] ?? (_a[_b] = [])).push(codec.opts.serialize);
        }
        if (codec.opts.deserialize) {
            ((_c = deserializers.forName)[_d = codec.name] ?? (_c[_d] = [])).push(codec.opts.deserialize);
        }
    },
    forPath(codec, serializers, deserializers) {
        if (codec.opts.serialize) {
            findOrInsertPath(serializers.forPath, codec.path, codec.opts.serialize);
        }
        if (codec.opts.deserialize) {
            findOrInsertPath(deserializers.forPath, codec.path, codec.opts.deserialize);
        }
    },
    forType(codec, serializers, deserializers) {
        var _a, _b;
        appendCodec.customSer(codec, serializers);
        if (codec.opts.deserialize) {
            ((_a = deserializers.forType)[_b = codec.type] ?? (_a[_b] = [])).push(codec.opts.deserialize);
        }
    },
    custom(codec, serializers, deserializers) {
        appendCodec.customSer(codec, serializers);
        if ('deserializeGuard' in codec.opts) {
            deserializers.forGuard.push({ guard: codec.opts.deserializeGuard, fn: codec.opts.deserialize });
        }
    },
    customSer(codec, serializers) {
        if ('serializeGuard' in codec.opts && !codec.opts.serializeClass) {
            serializers.forGuard.push({ guard: codec.opts.serializeGuard, fn: codec.opts.serialize });
        }
        else if ('serializeClass' in codec.opts && !codec.opts.serializeGuard) {
            findOrInsertClass(serializers.forClass, codec.opts.serializeClass, codec.opts.serialize);
        }
    },
};
const findOrInsertPath = (arr, newPath, fn) => {
    var _a;
    const arrForDepth = arr[_a = newPath.length] ?? (arr[_a] = []);
    for (const { path, fns } of arrForDepth) {
        if ((0, utils_js_1.pathArraysEqual)(path, newPath)) {
            fns.push(fn);
            return;
        }
    }
    arrForDepth.push({ path: newPath, fns: [fn] });
    arrForDepth.sort((a, b) => comparePathGeneralities(a.path, b.path));
};
const comparePathGeneralities = (a, b) => {
    const aIndex = a.indexOf('*');
    const diff = aIndex - b.indexOf('*');
    if (diff === 0 && aIndex !== -1 && aIndex + 1 < a.length) {
        return comparePathGeneralities(a.slice(aIndex + 1), b.slice(aIndex + 1));
    }
    return diff;
};
const findOrInsertClass = (arr, newClass, fn) => {
    for (const { class: clazz, fns } of arr) {
        if (clazz === newClass) {
            fns.push(fn);
            return;
        }
    }
    arr.push({ class: newClass, fns: [fn] });
};
