"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectId = exports.oid = void 0;
exports.genObjectId = genObjectId;
const utils_js_1 = require("../../lib/utils.js");
const constants_js_1 = require("../../lib/constants.js");
const constants_js_2 = require("../../documents/tables/ser-des/constants.js");
const constants_js_3 = require("../../documents/collections/ser-des/constants.js");
const utils_js_2 = require("../../lib/api/ser-des/utils.js");
const objectIdRegex = new RegExp('^[0-9a-fA-F]{24}$');
const oid = (id) => (id instanceof ObjectId) ? id : new ObjectId(id);
exports.oid = oid;
class ObjectId {
        [constants_js_2.$SerializeForTable]() {
        throw (0, utils_js_2.mkTypeUnsupportedForTablesError)('ObjectId', [
            'Use another object ID representation, such as a string',
        ]);
    }
    ;
        [constants_js_3.$SerializeForCollection](ctx) {
        return ctx.done({ $objectId: this._raw });
    }
    ;
        static [constants_js_3.$DeserializeForCollection](value, ctx) {
        return ctx.done(new ObjectId(value.$objectId, false));
    }
        constructor(id, validate = true) {
        Object.defineProperty(this, "_raw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        if (validate) {
            if (typeof id === 'string') {
                if (id.length !== 24 || !objectIdRegex.test(id)) {
                    throw new Error('ObjectId must be a 24-character hex string');
                }
            }
            else if (typeof id !== 'number' && !(0, utils_js_1.isNullish)(id) && !(id instanceof ObjectId)) {
                throw new Error('ObjectId must be a string, number, nullish, or another ObjectId instance');
            }
        }
        Object.defineProperty(this, '_raw', {
            value: (typeof id === 'string') ? id.toLowerCase() : (id instanceof ObjectId) ? id._raw : genObjectId(id, ObjectIDGenIndex),
        });
        Object.defineProperty(this, constants_js_1.$CustomInspect, {
            value: () => `ObjectId("${this._raw}")`,
        });
    }
        equals(other) {
        if (typeof other === 'string') {
            return this._raw.localeCompare(other, undefined, { sensitivity: 'accent' }) === 0;
        }
        if (other instanceof ObjectId) {
            return this._raw.localeCompare(other._raw, undefined, { sensitivity: 'accent' }) === 0;
        }
        return false;
    }
        getTimestamp() {
        const time = parseInt(this._raw.slice(0, 8), 16);
        return new Date(~~time * 1000);
    }
        toString() {
        return this._raw;
    }
}
exports.ObjectId = ObjectId;
const RAND_ID = ~~(Math.random() * 0xFFFFFF);
const PID = ~~(Math.random() * 100000) % 0xFFFF;
const HexTable = Array.from({ length: 256 }, (_, i) => {
    return (i <= 15 ? '0' : '') + i.toString(16);
});
let ObjectIDGenIndex = ~~(Math.random() * 0xFFFFFF);
/**
 * @internal
 */
function genObjectId(time, genIndex) {
    time ?? (time = ~~(Date.now() / 1000));
    time = time % 0xFFFFFFFF;
    ObjectIDGenIndex = (genIndex + 1) % 0xFFFFFF;
    let hexString = '';
    hexString += HexTable[((time >> 24) & 0xFF)];
    hexString += HexTable[((time >> 16) & 0xFF)];
    hexString += HexTable[((time >> 8) & 0xFF)];
    hexString += HexTable[(time & 0xFF)];
    hexString += HexTable[((RAND_ID >> 16) & 0xFF)];
    hexString += HexTable[((RAND_ID >> 8) & 0xFF)];
    hexString += HexTable[(RAND_ID & 0xFF)];
    hexString += HexTable[((PID >> 8) & 0xFF)];
    hexString += HexTable[(PID & 0xFF)];
    hexString += HexTable[((ObjectIDGenIndex >> 16) & 0xFF)];
    hexString += HexTable[((ObjectIDGenIndex >> 8) & 0xFF)];
    hexString += HexTable[(ObjectIDGenIndex & 0xFF)];
    return hexString;
}
