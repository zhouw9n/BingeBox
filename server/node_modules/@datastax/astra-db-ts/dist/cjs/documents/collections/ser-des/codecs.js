"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionCodecs = void 0;
// Important to import from specific paths here to avoid circular dependencies
const uuid_js_1 = require("../../../documents/datatypes/uuid.js");
const object_id_js_1 = require("../../../documents/datatypes/object-id.js");
const vector_js_1 = require("../../../documents/datatypes/vector.js");
const index_js_1 = require("../../../lib/index.js");
const utils_js_1 = require("../../../lib/api/ser-des/utils.js");
const constants_js_1 = require("../../../documents/collections/ser-des/constants.js");
const ctx_js_1 = require("../../../lib/api/ser-des/ctx.js");
const utils_js_2 = require("../../../documents/utils.js");
class CollectionCodecs {
    static forId(clazz) {
        assertIsCodecClass(clazz);
        const { [constants_js_1.$DeserializeForCollection]: deserialize } = clazz;
        return [
            CollectionCodecs.forName('', {
                deserialize: (val, ctx) => ctx.target === ctx_js_1.SerDesTarget.InsertedId ? deserialize(val, ctx) : ctx.nevermind(),
            }),
            CollectionCodecs.forPath(['_id'], {
                deserialize: (val, ctx) => ctx.target === ctx_js_1.SerDesTarget.Record ? deserialize(val, ctx) : ctx.nevermind(),
            }),
        ].flat();
    }
    static forName(name, optsOrClass) {
        validateIfCodecClass(optsOrClass);
        return [{
                tag: 'forName',
                name: name,
                opts: (constants_js_1.$DeserializeForCollection in optsOrClass) ? { deserialize: optsOrClass[constants_js_1.$DeserializeForCollection] } : optsOrClass,
            }];
    }
        static forPath(path, optsOrClass) {
        validateIfCodecClass(optsOrClass);
        return [{
                tag: 'forPath',
                path: path,
                opts: (constants_js_1.$DeserializeForCollection in optsOrClass) ? { deserialize: optsOrClass[constants_js_1.$DeserializeForCollection] } : optsOrClass,
            }];
    }
    static forType(type, optsOrClass) {
        validateIfCodecClass(optsOrClass);
        return [{
                tag: 'forType',
                type: type,
                opts: (constants_js_1.$DeserializeForCollection in optsOrClass) ? { deserialize: optsOrClass[constants_js_1.$DeserializeForCollection] } : optsOrClass,
            }];
    }
    static custom(opts) {
        return [{ tag: 'custom', opts: opts }];
    }
    static asCodecClass(clazz, fns) {
        if (fns) {
            if (!('prototype' in clazz)) {
                throw new Error(`Cannot attach ser/des functions to non-class ${clazz}`);
            }
            clazz[constants_js_1.$DeserializeForCollection] = fns.deserializeForCollection;
            (clazz.prototype)[constants_js_1.$SerializeForCollection] = fns.serializeForCollection;
        }
        assertIsCodecClass(clazz);
        return clazz;
    }
}
exports.CollectionCodecs = CollectionCodecs;
Object.defineProperty(CollectionCodecs, "Defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {
        $date: CollectionCodecs.forType('$date', {
            serializeClass: Date,
            serialize(date, ctx) {
                if (isNaN(date.valueOf())) {
                    throw new Error(`Can not serialize an invalid date (at '${(0, index_js_1.escapeFieldNames)(ctx.path)}')`);
                }
                return ctx.done({ $date: date.valueOf() });
            },
            deserialize(value, ctx) {
                return ctx.done(new Date(Number(value.$date)));
            },
        }),
        $vector: CollectionCodecs.forName('$vector', {
            serialize: (val, ctx) => (vector_js_1.DataAPIVector.isVectorLike(val)) ? (0, vector_js_1.vector)(val)[constants_js_1.$SerializeForCollection](ctx) : ctx.nevermind(),
            deserialize: vector_js_1.DataAPIVector[constants_js_1.$DeserializeForCollection],
        }),
        $uuid: CollectionCodecs.forType('$uuid', uuid_js_1.UUID),
        $objectId: CollectionCodecs.forType('$objectId', object_id_js_1.ObjectId),
    }
});
function assertIsCodecClass(clazz) {
    if (typeof clazz !== 'function') {
        throw new TypeError(`Invalid codec class: expected a constructor; got ${(0, utils_js_2.betterTypeOf)(clazz)}`);
    }
    (0, utils_js_1.assertHasSerializeFor)(clazz, constants_js_1.$SerializeForCollection, '$SerializeForCollection');
    (0, utils_js_1.assertHasDeserializeFor)(clazz, constants_js_1.$DeserializeForCollection, '$DeserializeForCollection');
}
function validateIfCodecClass(val) {
    if (typeof val === 'function') {
        // We can't check for $SerializeForCollection here because it may not be on the prototype, depending on how it's
        // implemented in the class. This at least helps catch cases when a completely wrong class is passed.
        (0, utils_js_1.assertHasDeserializeFor)(val, constants_js_1.$DeserializeForCollection, '$DeserializeForCollection');
    }
}
