"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildFLCSort = exports.buildFLCFilter = exports.buildFLCMap = exports.buildFLCPreMapOption = exports.buildFLCOption = exports.cloneFLC = void 0;
const abstract_cursor_js_1 = require("../../documents/cursors/abstract-cursor.js");
const ctx_js_1 = require("../../lib/api/ser-des/ctx.js");
const cloneFLC = (cursor, filter, options, mapping) => {
    return new cursor.constructor(cursor.dataSource, cursor._serdes, filter, options, mapping);
};
exports.cloneFLC = cloneFLC;
const buildFLCOption = (cursor, key, value) => {
    if (cursor.state !== 'idle') {
        throw new abstract_cursor_js_1.CursorError(`Cannot set a new ${key} on a running/closed cursor`, cursor);
    }
    return (0, exports.cloneFLC)(cursor, cursor._filter, { ...cursor._options, [key]: value }, cursor._mapping);
};
exports.buildFLCOption = buildFLCOption;
const buildFLCPreMapOption = (cursor, key, value) => {
    if (cursor._mapping) {
        throw new abstract_cursor_js_1.CursorError(`Cannot set a new ${key} after already using cursor.map(...)`, cursor);
    }
    return (0, exports.buildFLCOption)(cursor, key, value);
};
exports.buildFLCPreMapOption = buildFLCPreMapOption;
const buildFLCMap = (cursor, map) => {
    if (cursor.state !== 'idle') {
        throw new abstract_cursor_js_1.CursorError('Cannot set a new mapping on a running/closed cursor', cursor);
    }
    const mapping = cursor._mapping
        ? (doc) => map(cursor._mapping(doc))
        : map;
    return (0, exports.cloneFLC)(cursor, cursor._filter, cursor._options, mapping);
};
exports.buildFLCMap = buildFLCMap;
const buildFLCFilter = (cursor, filter) => {
    if (cursor.state !== 'idle') {
        throw new abstract_cursor_js_1.CursorError(`Cannot set a new filter on a running/closed cursor`, cursor);
    }
    return (0, exports.cloneFLC)(cursor, cursor._serdes.serialize(filter, ctx_js_1.SerDesTarget.Filter), cursor._options, cursor._mapping);
};
exports.buildFLCFilter = buildFLCFilter;
const buildFLCSort = (cursor, sort) => {
    return (0, exports.buildFLCOption)(cursor, 'sort', cursor._serdes.serialize(sort, ctx_js_1.SerDesTarget.Sort)[0]);
};
exports.buildFLCSort = buildFLCSort;
