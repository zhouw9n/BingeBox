"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandWarningsEvent = exports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = exports.CommandEvent = void 0;
const base_event_js_1 = require("../lib/logging/base-event.js");
const errors_js_1 = require("../documents/errors.js");
const mkCommandEventTarget = (info) => {
    const target = { url: info.url };
    if (info.keyspace) {
        target.keyspace = info.keyspace;
    }
    if (info.tOrCType) {
        target[info.tOrCType] = info.tOrC;
    }
    return target;
};
class CommandEvent extends base_event_js_1.BaseClientEvent {
        constructor(name, requestId, info, extra) {
        super(name, requestId, extra);
                Object.defineProperty(this, "command", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "target", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.command = info.command;
        this.target = mkCommandEventTarget(info);
    }
        get commandName() {
        return Object.keys(this.command)[0];
    }
    getMessagePrefix() {
        const source = this.target.collection || this.target.table;
        return (source === undefined)
            ? `${this.target.keyspace ?? '<no_keyspace>'}::${this.commandName}`
            : `${source}::${this.commandName}`;
    }
        _extraLogInfoAsString() {
        return this.extraLogInfo ? `{${Object.entries(this.extraLogInfo).map(([k, v]) => `${k}=${v}`).join(',')}} ` : '';
    }
    /**
     * @internal
     */
    _modifyEventForFormatVerbose(event) {
        event.target = event.target.url;
    }
}
exports.CommandEvent = CommandEvent;
/**
 * Emitted when a command is started, before the initial HTTP request is made.
 *
 * **Note that these emit *real* commands, not any abstracted commands like "insertMany" or "updateMany",
 * which may be split into multiple of those commands under the hood.**
 *
 * See {@link CommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
class CommandStartedEvent extends CommandEvent {
    /**
     * Should not be instantiated by the user.
     *
     * @internal
     */
    constructor(requestId, info, extra) {
        super('CommandStarted', requestId, info, extra);
                Object.defineProperty(this, "timeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.timeout = info.timeoutManager.initial();
    }
    getMessage() {
        return this._extraLogInfoAsString();
    }
}
exports.CommandStartedEvent = CommandStartedEvent;
class CommandSucceededEvent extends CommandEvent {
        constructor(requestId, info, extra, reply, started) {
        super('CommandSucceeded', requestId, info, extra);
                Object.defineProperty(this, "duration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.duration = performance.now() - started;
        this.response = reply;
    }
    getMessage() {
        return `${this._extraLogInfoAsString()}(${~~this.duration}ms)`;
    }
}
exports.CommandSucceededEvent = CommandSucceededEvent;
class CommandFailedEvent extends CommandEvent {
        constructor(requestId, info, extra, reply, error, started) {
        super('CommandFailed', requestId, info, extra);
                Object.defineProperty(this, "duration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "error", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.duration = performance.now() - started;
        this.response = reply;
        this.error = error;
    }
    getMessage() {
        return `${this._extraLogInfoAsString()}(${~~this.duration}ms) ERROR: ${JSON.stringify(this.error.message)}`;
    }
    trimDuplicateFields() {
        if (this.error instanceof errors_js_1.DataAPIError) {
            return { ...this, error: this.error.withTransientDupesForEvents() };
        }
        return this;
    }
}
exports.CommandFailedEvent = CommandFailedEvent;
class CommandWarningsEvent extends CommandEvent {
        constructor(requestId, info, extra, warnings) {
        super('CommandWarnings', requestId, info, extra);
                Object.defineProperty(this, "warnings", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.warnings = warnings;
    }
    getMessage() {
        return `${this._extraLogInfoAsString()}WARNINGS: ${this.warnings.map(w => JSON.stringify(w.message)).join(', ')}`;
    }
}
exports.CommandWarningsEvent = CommandWarningsEvent;
