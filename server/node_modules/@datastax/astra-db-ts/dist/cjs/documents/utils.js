"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.mkWrongTypeError = exports.mkInvArgsError = exports.betterTypeOf = void 0;
exports.extractDbComponentsFromAstraUrl = extractDbComponentsFromAstraUrl;
const DBComponentsRegex = /^([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})-([a-z0-9_-]+)\.apps\.astra(?:-(?:dev|test))?\.datastax\.com/i;
function extractDbComponentsFromAstraUrl(uri) {
    try {
        const match = DBComponentsRegex.exec(new URL(uri).hostname);
        if (!match) {
            return [];
        }
        return [match[1].toLowerCase(), match[2].toLowerCase()];
    }
    catch (_) {
        return [];
    }
}
const betterTypeOf = (value) => {
    if (value === null) {
        return 'null';
    }
    if (typeof value === 'object') {
        return value.constructor?.name ?? 'Object[NullProto]';
    }
    return typeof value;
};
exports.betterTypeOf = betterTypeOf;
const mkInvArgsError = (exp, params, ...got) => {
    const names = params.map(([name]) => name).join(', ');
    const types = params.map(([, type]) => type).join(', ');
    return new TypeError(`Invalid argument(s) for \`${exp}(${names})\`; expected (${types}), got (${got.map(exports.betterTypeOf).join(', ')})`);
};
exports.mkInvArgsError = mkInvArgsError;
const mkWrongTypeError = (fieldName, expected, got) => {
    return new TypeError(`Expected '${fieldName}' to be of type '${expected}', but got '${(0, exports.betterTypeOf)(got)}' (${got})`);
};
exports.mkWrongTypeError = mkWrongTypeError;
