// Copyright DataStax, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

declare function astraDbTsRequiresTypeScriptV5OrGreater<const AstraDbTsRequiresTypeScriptV5OrGreater>(_: AstraDbTsRequiresTypeScriptV5OrGreater): void;

import { BigNumber } from 'bignumber.js';
/* Excluded from this release type: $CustomInspect */

/**
 * @public
 */
export declare const $DeserializeForCollection: unique symbol;

/**
 * @public
 */
export declare const $DeserializeForTable: unique symbol;

declare const $ERROR: unique symbol;

/**
 * @public
 */
export declare const $SerializeForCollection: unique symbol;

/**
 * @public
 */
export declare const $SerializeForTable: unique symbol;

/* Excluded from this release type: __parsed */

/**
 * ##### Overview
 *
 * Represents some lazy, abstract iterable cursor over any arbitrary data, which may or may not be paginated.
 *
 * > **⚠️Warning**: Shouldn't be directly instantiated, but rather spawned via {@link Collection.findAndRerank}/{@link Collection.find}, or their {@link Table} alternatives.
 *
 * ---
 *
 * ##### Typing
 *
 * > **🚨Important:** For most intents and purposes, you may treat the cursor as if it is typed simply as `Cursor<T>`.
 * >
 * > If you're using a projection, it is heavily recommended to provide an explicit type representing the type of the document after projection.
 *
 * In full, the cursor is typed as `AbstractCursor<T, TRaw>`, where
 * - `T` is the type of the mapped records, and
 * - `TRaw` is the type of the raw records before any mapping.
 *
 * If no mapping function is provided, `T` and `TRaw` will be the same type. Mapping is done using the {@link AbstractCursor.map} method.
 *
 * @see CollectionFindCursor
 * @see CollectionFindAndRerankCursor
 * @see TableFindCursor
 *
 * @public
 */
export declare abstract class AbstractCursor<T, TRaw extends SomeDoc = SomeDoc> {
    /* Excluded from this release type: _consumed */
    /* Excluded from this release type: _buffer */
    /* Excluded from this release type: _state */
    /* Excluded from this release type: _nextPageState */
    /* Excluded from this release type: _mapping */
    /* Excluded from this release type: _options */
    /* Excluded from this release type: __constructor */
    /**
     * The current status of the cursor.
     */
    get state(): CursorState;
    /**
     * The number of raw records in the buffer.
     *
     * Unless the cursor was closed before the buffer was completely read, the total number of records retrieved from the
     * server is equal to ({@link FindCursor.consumed} + {@link FindCursor.buffered}).
     */
    buffered(): number;
    /**
     * The number of records that have been read be the user from the cursor.
     *
     * Unless the cursor was closed before the buffer was completely read, the total number of records retrieved from the
     * server is equal to ({@link FindCursor.consumed} + {@link FindCursor.buffered}).
     */
    consumed(): number;
    /**
     * Consumes up to `max` records from the buffer, or all records if `max` is not provided.
     *
     * **Note that this actually consumes the buffer; it doesn't just peek at it.**
     *
     * @param max - The maximum number of records to read from the buffer. If not provided, all records will be read.
     *
     * @returns The records read from the buffer.
     */
    consumeBuffer(max?: number): TRaw[];
    /**
     * Rewinds the cursor to its uninitialized state, clearing the buffer and any state.
     *
     * Any configuration set on the cursor will remain, but iteration will start from the beginning, sending new queries
     * to the server, even if the resultant data was already fetched by this cursor.
     */
    rewind(): void;
    /**
     * Closes the cursor. The cursor will be unusable after this method is called, or until {@link FindCursor.rewind} is called.
     */
    close(): void;
    abstract clone(): this;
    abstract map<R>(map: (doc: T) => R): AbstractCursor<R, TRaw>;
    /**
     * An async iterator that lazily iterates over all records in the cursor.
     *
     * **Note that there'll only be partial results if the cursor has been previously iterated over. You may use {@link FindCursor.rewind}
     * to reset the cursor.**
     *
     * If the cursor is uninitialized, it will be initialized. If the cursor is closed, this method will return immediately.
     *
     * It will close the cursor when iteration is complete, even if it was broken early.
     *
     * @example
     * ```typescript
     * for await (const doc of cursor) {
     *   console.log(doc);
     * }
     * ```
     */
    [Symbol.asyncIterator](): AsyncGenerator<T, void, void>;
    /**
     * Fetches the next record from the cursor. Returns `null` if there are no more records to fetch.
     *
     * If the cursor is uninitialized, it will be initialized. If the cursor is closed, this method will return `null`.
     *
     * @returns The next record, or `null` if there are no more records.
     */
    next(): Promise<T | null>;
    /**
     * Tests if there is a next record in the cursor.
     *
     * If the cursor is uninitialized, it will be initialized. If the cursor is closed, this method will return `false`.
     *
     * @returns Whether or not there is a next record.
     */
    hasNext(): Promise<boolean>;
    /**
     * Iterates over all records in the cursor, calling the provided consumer for each record.
     *
     * If the consumer returns `false`, iteration will stop.
     *
     * Note that there'll only be partial results if the cursor has been previously iterated over. You may use {@link FindCursor.rewind}
     * to reset the cursor.
     *
     * If the cursor is uninitialized, it will be initialized. If the cursor is closed, this method will return immediately.
     *
     * It will close the cursor when iteration is complete, even if it was stopped early.
     *
     * @param consumer - The consumer to call for each record.
     *
     * @returns A promise that resolves when iteration is complete.
     *
     * @remarks
     * If you get an IDE error "Promise returned from forEach argument is ignored", it is a known [WebStorm bug](https://youtrack.jetbrains.com/issue/WEB-55512/False-positive-for-Promise-returned-from-forEach-argument-is-ignored-with-custom-forEach-function).
     */
    forEach(consumer: ((doc: T) => boolean | Promise<boolean>) | ((doc: T) => void | Promise<void>)): Promise<void>;
    /**
     * Returns an array of all matching records in the cursor. The user should ensure that there is enough memory to
     * store all records in the cursor.
     *
     * Note that there'll only be partial results if the cursor has been previously iterated over. You may use {@link FindCursor.rewind}
     * to reset the cursor.
     *
     * If the cursor is uninitialized, it will be initialized. If the cursor is closed, this method will return an empty array.
     *
     * @returns An array of all records in the cursor.
     */
    toArray(): Promise<T[]>;
    /* Excluded from this release type: _nextPage */
    /* Excluded from this release type: _tm */
    /* Excluded from this release type: _iterator */
    /* Excluded from this release type: _next */
    /* Excluded from this release type: _next */
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - `.bufferedCount()` has been renamed to simply be `.buffered()`.
     */
    bufferedCount: 'ERROR: `.bufferedCount()` has been renamed to be simply `.buffered()`';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - `.readBufferedDocuments()` has been renamed to be `.consumeBuffer()`.
     */
    readBufferedDocuments: 'ERROR: `.readBufferedDocuments()` has been renamed to be `.consumeBuffer()`';
}

/**
 * An operation to add columns to the table.
 *
 * @public
 */
export declare interface AddColumnOperation {
    /**
     * The columns to add to the table, of the same format as in `createTable`
     */
    columns: CreateTableColumnDefinitions;
}

export declare type AdditionalHeaders = OneOrMany<HeadersProvider | Record<string, string | undefined>>;

/**
 * @public
 */
export declare interface AddRerankingOperation {
    service: RerankServiceOptions;
}

/**
 * An operation to enable vectorize (auto-embedding-generation) on existing vector columns on the table.
 *
 * @public
 */
export declare interface AddVectorizeOperation<Schema extends SomeRow> {
    /**
     * The options for vectorize-ing each column.
     */
    columns: Partial<Record<keyof Schema & string, VectorizeServiceOptions>>;
}

/**
 * Common base class for all admin command events.
 *
 * @public
 */
export declare abstract class AdminCommandEvent extends BaseClientEvent {
    /**
     * The path for the request, not including the Base URL.
     */
    readonly url: string;
    /**
     * The HTTP method for the request.
     */
    readonly requestMethod: 'GET' | 'POST' | 'DELETE';
    /**
     * The request body, if any.
     */
    readonly requestBody?: Record<string, any>;
    /**
     * The query parameters, if any.
     */
    readonly requestParams?: Record<string, any>;
    /**
     * Whether the command is long-running or not, i.e. requires polling.
     */
    readonly isLongRunning: boolean;
    /**
     * The method which invoked the request
     */
    readonly invokingMethod: string;
    /* Excluded from this release type: __constructor */
    getMessagePrefix(): string;
    /* Excluded from this release type: _modifyEventForFormatVerbose */
}

/**
 * The events emitted by the {@link DataAPIClient}. These events are emitted at various stages of the
 * admin command's lifecycle. Intended for use for monitoring and logging purposes.
 *
 * @public
 */
export declare type AdminCommandEventMap = {
    /**
     * Emitted when an admin command is started, before the initial HTTP request is made.
     */
    adminCommandStarted: AdminCommandStartedEvent;
    /**
     * Emitted when a command is polling in a long-running operation (i.e. create database).
     */
    adminCommandPolling: AdminCommandPollingEvent;
    /**
     * Emitted when an admin command has succeeded, after any necessary polling.
     */
    adminCommandSucceeded: AdminCommandSucceededEvent;
    /**
     * Emitted when an admin command has errored.
     */
    adminCommandFailed: AdminCommandFailedEvent;
    /**
     * Emitted when an admin command has warnings.
     */
    adminCommandWarnings: AdminCommandWarningsEvent;
};

/**
 * Event emitted when an admin command has errored.
 *
 * See {@link AdminCommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class AdminCommandFailedEvent extends AdminCommandEvent {
    /* Excluded from this release type: _permits */
    /**
     * The duration of the command, in milliseconds.
     */
    readonly duration: number;
    /**
     * The error that occurred.
     *
     * Typically, some {@link DevOpsAPIError}, commonly a {@link DevOpsAPIResponseError} or sometimes a
     * {@link DevOpsAPITimeoutError}
     */
    readonly error: Error;
    /* Excluded from this release type: __constructor */
    getMessage(): string;
}

/**
 * Event emitted when a command is polling in a long-running operation (i.e. create database).
 *
 * Emits every time the command polls.
 *
 * See {@link AdminCommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class AdminCommandPollingEvent extends AdminCommandEvent {
    /* Excluded from this release type: _permits */
    /**
     * The elapsed time since the command was started, in milliseconds.
     */
    readonly elapsed: number;
    /**
     * The polling interval, in milliseconds.
     */
    readonly pollInterval: number;
    /**
     * The number of times polled so far
     */
    readonly pollCount: number;
    /* Excluded from this release type: __constructor */
    getMessage(): string;
}

/**
 * Event emitted when an admin command is started. This is emitted before the initial HTTP request is made.
 *
 * See {@link AdminCommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class AdminCommandStartedEvent extends AdminCommandEvent {
    /* Excluded from this release type: _permits */
    /**
     * The timeout for the request, in milliseconds.
     */
    readonly timeout: Partial<TimeoutDescriptor>;
    /* Excluded from this release type: __constructor */
    getMessage(): string;
}

/**
 * Event emitted when an admin command has succeeded, after any necessary polling.
 *
 * See {@link AdminCommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class AdminCommandSucceededEvent extends AdminCommandEvent {
    /* Excluded from this release type: _permits */
    /**
     * The duration of the command, in milliseconds.
     */
    readonly duration: number;
    /**
     * The response body of the command, if any.
     */
    readonly responseBody?: Record<string, any>;
    /* Excluded from this release type: __constructor */
    getMessage(): string;
}

/**
 * Event emitted when the Data API returned a warning for an admin command.
 *
 * See {@link AdminCommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class AdminCommandWarningsEvent extends AdminCommandEvent {
    /* Excluded from this release type: _permits */
    /**
     * The warnings that occurred.
     */
    readonly warnings: ReadonlyNonEmpty<DataAPIWarningDescriptor>;
    /* Excluded from this release type: __constructor */
    getMessage(): string;
}

/**
 * The options available spawning a new {@link AstraAdmin} instance.
 *
 * **Note that this is only available when using Astra as the underlying database.**
 *
 * If any of these options are not provided, the client will use the default options provided by the {@link DataAPIClient}.
 *
 * @public
 */
export declare interface AdminOptions {
    /**
     * The configuration for logging events emitted by the {@link DataAPIClient}.
     *
     * This can be set at any level of the major class hierarchy, and will be inherited by all child classes.
     *
     * See {@link LoggingConfig} for *much* more information on configuration, outputs, and inheritance.
     */
    logging?: LoggingConfig;
    /**
     * The access token for the DevOps API, typically of the format `'AstraCS:...'`.
     *
     * If never provided, this will default to the token provided when creating the {@link DataAPIClient}.
     *
     * May be useful for if you want to use a stronger token for the DevOps API than the Data API.
     *
     * @example
     * ```typescript
     * const client = new DataAPIClient('weak-token');
     *
     * // Using 'weak-token' as the token
     * const db = client.db();
     *
     * // Using 'strong-token' instead of 'weak-token'
     * const admin = client.admin({ adminToken: 'strong-token' });
     * ```
     */
    adminToken?: string | TokenProvider | null;
    /**
     * The base URL for the devops API, which is typically always going to be the following:
     * ```
     * https://api.astra.datastax.com/v2
     * ```
     */
    endpointUrl?: string;
    /**
     * The Astra environment to use when interacting with the DevOps API.
     *
     * In the case of {@link AstraDbAdmin}, if a database endpoint is provided, and its environment does NOT match
     * this value (if it is set), it will throw an error.
     *
     * In the case of {@link DataAPIDbAdmin}, it will simply ignore this value.
     */
    astraEnv?: 'dev' | 'prod' | 'test';
    /**
     * ##### Overview
     *
     * The default timeout options for any operation on this admin instance.
     *
     * See {@link TimeoutDescriptor} for much more information about timeouts.
     *
     * @example
     * ```ts
     * // The request timeout for all operations is set to 1000ms.
     * const client = new DataAPIClient('...', {
     *   timeoutDefaults: { requestTimeoutMs: 1000 },
     * });
     *
     * // The request timeout for all operations borne from this Db is set to 2000ms.
     * const db = client.db('...', {
     *   timeoutDefaults: { requestTimeoutMs: 2000 },
     * });
     * ```
     *
     * ##### Inheritance
     *
     * The timeout options are inherited by all child classes, and can be overridden at any level, including the individual method level.
     *
     * Individual-method-level overrides can vary in behavior depending on the method; again, see {@link TimeoutDescriptor}.
     *
     * ##### Defaults
     *
     * The default timeout options are as follows:
     * - `requestTimeoutMs`: 15000
     * - `generalMethodTimeoutMs`: 30000
     * - `collectionAdminTimeoutMs`: 60000
     * - `tableAdminTimeoutMs`: 30000
     * - `databaseAdminTimeoutMs`: 600000
     * - `keyspaceAdminTimeoutMs`: 30000
     *
     * @see TimeoutDescriptor
     */
    timeoutDefaults?: Partial<TimeoutDescriptor>;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - `monitorCommands` has been overhauled, and replaced with the `logging` option. Please see its documentation for more information.
     */
    monitorCommands?: 'ERROR: `monitorCommands` has been overhauled, and replaced with the `logging` option. Please see its documentation for more information';
}

/* Excluded from this release type: AdminOptsHandler */

/* Excluded from this release type: AdminOptsTypes */

/**
 * The possible alterations that may be performed on the table. Only one out of the four may be used at a time.
 *
 * @public
 */
export declare interface AlterTableOperations<Schema extends SomeRow> {
    add?: AddColumnOperation;
    drop?: DropColumnOperation<Schema>;
    addVectorize?: AddVectorizeOperation<Schema>;
    dropVectorize?: DropVectorizeOperation<Schema>;
    addReranking?: AddRerankingOperation;
    dropReranking?: DropRerankingOperation;
}

/**
 * Options for altering a table.
 *
 * @public
 */
export declare interface AlterTableOptions<Schema extends SomeRow> extends WithTimeout<'tableAdminTimeoutMs'> {
    /**
     * The operations to perform on the table. Must pick just one of `add`, `drop`, `addVectorize`, or `dropVectorize`.
     */
    operation: AlterTableOperations<Schema>;
}

export declare interface AsCollectionCodecClassFns<Class extends SomeConstructor> {
    serializeForCollection: (this: InstanceType<Class>, ctx: CollectionSerCtx) => ReturnType<SerDesFn<any>>;
    deserializeForCollection: SerDesFn<CollectionDesCtx>;
}

export declare interface AsTableCodecClassFns<Class extends SomeConstructor> {
    serializeForTable: (this: InstanceType<Class>, ctx: TableSerCtx) => ReturnType<SerDesFn<any>>;
    deserializeForTable: SerDesFn<TableDesCtx>;
}

/**
 * An administrative class for managing Astra databases, including creating, listing, and deleting databases.
 *
 * **Shouldn't be instantiated directly; use {@link DataAPIClient.admin} to obtain an instance of this class.**
 *
 * To perform admin tasks on a per-database basis, see the {@link AstraDbAdmin} class.
 *
 * @example
 * ```typescript
 * const client = new DataAPIClient('token');
 *
 * // Create an admin instance with the default token
 * const admin1 = client.admin();
 *
 * // Create an admin instance with a custom token
 * const admin2 = client.admin({ adminToken: 'stronger-token' });
 *
 * const dbs = await admin1.listDatabases();
 * console.log(dbs);
 * ```
 *
 * @see DataAPIClient.admin
 * @see AstraDbAdmin
 *
 * @public
 */
export declare class AstraAdmin extends HierarchicalLogger<AdminCommandEventMap> {    /* Excluded from this release type: __constructor */
    /**
     * Spawns a new {@link Db} instance using a direct endpoint and given options.
     *
     * This endpoint should include the protocol and the hostname, but not the path. It's typically in the form of
     * `https://<db_id>-<region>.apps.astra.datastax.com`, but it can be used with DSE or any other Data-API-compatible
     * endpoint.
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * @example
     * ```typescript
     * const admin = new DataAPIClient('token').admin();
     *
     * const db1 = admin.db('https://<db_id>-<region>.apps.astra.datastax.com');
     *
     * const db2 = admin.db('https://<db_id>-<region>.apps.astra.datastax.com', {
     *   keyspace: 'my_keyspace',
     *   useHttp2: false,
     * });
     * ```
     *
     * @remarks
     * Note that this does not perform any IO or validation on if the endpoint is valid or not. It's up to the user to
     * ensure that the endpoint is correct. If you want to create an actual database, see {@link AstraAdmin.createDatabase}
     * instead.
     *
     * @param endpoint - The direct endpoint to use.
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link Db} instance.
     */
    db(endpoint: string, options?: DbOptions): Db;
    /**
     * Spawns a new {@link Db} instance using a direct endpoint and given options.
     *
     * This overload is purely for user convenience, but it **only supports using Astra as the underlying database**. For
     * DSE or any other Data-API-compatible endpoint, use the other overload instead.
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * @example
     * ```typescript
     * const admin = new DataAPIClient('token').admin();
     *
     * const db1 = admin.db('a6a1d8d6-31bc-4af8-be57-377566f345bf', 'us-east1');
     *
     * const db2 = admin.db('a6a1d8d6-31bc-4af8-be57-377566f345bf', 'us-east1', {
     *   keyspace: 'my_keyspace',
     *   useHttp2: false,
     * });
     * ```
     *
     * @remarks
     * Note that this does not perform any IO or validation on if the endpoint is valid or not. It's up to the user to
     * ensure that the endpoint is correct. If you want to create an actual database, see {@link AstraAdmin.createDatabase}
     * instead.
     *
     * @param id - The database ID to use.
     * @param region - The region to use.
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link Db} instance.
     */
    db(id: string, region: string, options?: DbOptions): Db;
    /**
     * Spawns a new {@link AstraDbAdmin} instance for a database using a direct endpoint and given options.
     *
     * This endpoint should include the protocol and the hostname, but not the path. It's typically in the form of
     * `https://<db_id>-<region>.apps.astra.datastax.com`, but it can be used with DSE or any other Data-API-compatible
     * endpoint.
     *
     * The given options are for the underlying implicitly-created {@link Db} instance, not the {@link AstraDbAdmin} instance.
     * The db admin will use the same options as this {@link AstraAdmin} instance.
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * @example
     * ```typescript
     * const admin = new DataAPIClient('token').admin();
     *
     * const dbAdmin1 = admin.dbAdmin('https://<db_id>-<region>...');
     *
     * const dbAdmin2 = admin.dbAdmin('https://<db_id>-<region>...', {
     *   keyspace: 'my_keyspace',
     *   useHttp2: false,
     * });
     * ```
     *
     * @remarks
     * Note that this does not perform any IO or validation on if the endpoint is valid or not. It's up to the user to
     * ensure that the endpoint is correct. If you want to create an actual database, see {@link AstraAdmin.createDatabase}
     * instead.
     *
     * @param endpoint - The direct endpoint to use.
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link Db} instance.
     */
    dbAdmin(endpoint: string, options?: DbOptions): AstraDbAdmin;
    /**
     * Spawns a new {@link Db} instance using a direct endpoint and given options.
     *
     * This overload is purely for user convenience, but it **only supports using Astra as the underlying database**. For
     * DSE or any other Data-API-compatible endpoint, use the other overload instead.
     *
     * The given options are for the underlying implicitly-created {@link Db} instance, not the {@link AstraDbAdmin} instance.
     * The db admin will use the same options as this {@link AstraAdmin} instance.
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * @example
     * ```typescript
     * const admin = new DataAPIClient('token').admin();
     *
     * const dbAdmin1 = admin.dbAdmin('a6a1d8d6-...-377566f345bf', 'us-east1');
     *
     * const dbAdmin2 = admin.dbAdmin('a6a1d8d6-...-377566f345bf', 'us-east1', {
     *   keyspace: 'my_keyspace',
     *   useHttp2: false,
     * });
     * ```
     *
     * @remarks
     * Note that this does not perform any IO or validation on if the endpoint is valid or not. It's up to the user to
     * ensure that the endpoint is correct. If you want to create an actual database, see {@link AstraAdmin.createDatabase}
     * instead.
     *
     * @param id - The database ID to use.
     * @param region - The region to use.
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link Db} instance.
     */
    dbAdmin(id: string, region: string, options?: DbOptions): AstraDbAdmin;
    /**
     * Fetches the complete information about the database, such as the database name, IDs, region, status, actions, and
     * other metadata.
     *
     * @example
     * ```typescript
     * const info = await admin.info('<db_id>');
     * console.log(info.info.name, info.creationTime);
     * ```
     *
     * @returns A promise that resolves to the complete database information.
     */
    dbInfo(id: string, options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<AstraFullDatabaseInfo>;
    /**
     * Lists all databases in the current org/account, matching the optionally provided filter.
     *
     * Note that this method is paginated, but the page size is high enough that most users won't need to worry about it.
     * However, you can use the `limit` and `skip` options to control the number of results returned and the starting point
     * for the results, as needed.
     *
     * You can also filter by the database status using the `include` option, and by the database provider using the
     * `provider` option.
     *
     * See {@link ListAstraDatabasesOptions} for complete information about the options available for this operation.
     *
     * @example
     * ```typescript
     * const admin = new DataAPIClient('AstraCS:...').admin();
     *
     * const activeDbs = await admin.listDatabases({ include: 'ACTIVE' });
     *
     * for (const db of activeDbs) {
     *   console.log(`Database ${db.name} is active`);
     * }
     * ```
     *
     * @param options - The options to filter the databases by.
     * @returns A list of the complete information for all the databases matching the given filter.
     */
    listDatabases(options?: ListAstraDatabasesOptions): Promise<AstraFullDatabaseInfo[]>;
    /**
     * Creates a new database with the given configuration.
     *
     * **NB. this is a long-running operation. See {@link AstraAdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 10 seconds. Expect it to take roughly 2 min to complete.
     *
     * Note that **the `name` field is non-unique** and thus creating a database, even with the same options, is **not
     * idempotent**.
     *
     * You may also provide options for the implicit {@link Db} instance that will be created with the database, which
     * will override any default options set when creating the {@link DataAPIClient} through a deep merge (i.e. unset
     * properties in the options object will just default to the default options).
     *
     * See {@link CreateAstraDatabaseOptions} for complete information about the options available for this operation.
     *
     * @example
     * ```typescript
     * const newDbAdmin1 = await admin.createDatabase({
     *   name: 'my_database_1',
     *   cloudProvider: 'GCP',
     *   region: 'us-east1',
     * });
     *
     * // Prints '[]' as there are no collections in the database yet
     * console.log(newDbAdmin1.db().listCollections());
     *
     * const newDbAdmin2 = await admin.createDatabase({
     *   name: 'my_database_2',
     *   cloudProvider: 'GCP',
     *   region: 'us-east1',
     *   keyspace: 'my_keyspace',
     * }, {
     *   blocking: false,
     *   dbOptions: {
     *     useHttp2: false,
     *     token: '<weaker-token>',
     *   },
     * });
     *
     * // Can't do much else as the database is still initializing
     * console.log(newDbAdmin2.db().id);
     * ```
     *
     * @remarks
     * Note that if you choose not to block, the returned {@link AstraDbAdmin} object will not be very useful until the
     * operation completes, which is up to the caller to determine.
     *
     * @param config - The configuration for the new database.
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns The AstraDbAdmin instance for the newly created database.
     */
    createDatabase(config: AstraDatabaseConfig, options?: CreateAstraDatabaseOptions): Promise<AstraDbAdmin>;
    /**
     * Terminates a database by ID or by a given {@link Db} instance.
     *
     * **NB. this is a long-running operation. See {@link AstraAdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 10 seconds. Expect it to take roughly 6-7 min to complete.
     *
     * The database info will still be accessible by ID, or by using the {@link AstraAdmin.listDatabases} method with the filter
     * set to `'ALL'` or `'TERMINATED'`. However, all of its data will very much be lost.
     *
     * @example
     * ```typescript
     * const db = client.db('https://<db_id>-<region>.apps.astra.datastax.com');
     * await admin.dropDatabase(db);
     *
     * // Or just
     * await admin.dropDatabase('a6a1d8d6-31bc-4af8-be57-377566f345bf');
     * ```
     *
     * @param db - The database to drop, either by ID or by instance.
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     *
     * @remarks Use with caution. Wear a harness. Don't say I didn't warn you.
     */
    dropDatabase(db: Db | string, options?: AstraDropDatabaseOptions): Promise<void>;
    get _httpClient(): OpaqueHttpClient;
}

/**
 * ##### Overview
 *
 * Options controlling the blocking behavior of certain admin operations.
 *
 * Some admin operations require repeatedly polling the database's status to check if said operation is complete.
 * These operations may be long- or short-running, but they are not instantaneous.
 *
 * By default, these operations **block** until completion, with a method-defined polling interval that can be overridden.
 *
 * Alternatively, you can opt for **non-blocking** behavior, in which case the operation returns immediately, leaving it up to the caller to manually determine completion.
 *
 * ---
 *
 * ##### Blocking
 *
 * When `blocking` is `true` (default), the operation will **not return** until it is *fully complete*.
 * Completion is determined by polling the database's status at a regular interval.
 *
 * You can customize the polling interval using the `pollInterval` option (in milliseconds).
 *
 * @example
 * ```ts
 * // Will block by default until the operation is complete.
 * const dbAdmin1 = await admin.createDatabase({ ... });
 *
 * // Blocks with a custom poll interval (e.g. every 5 seconds).
 * const dbAdmin2 = await admin.createDatabase({ ... }, {
 *   pollInterval: 5000,
 * });
 * ```
 *
 * ---
 *
 * ##### Non-blocking
 *
 * When `blocking` is `false`, the operation returns immediately after initiating the request.
 * It becomes your responsibility to check when the operation has completed.
 *
 * **Important:** In this mode, *resources will still not be usable until the operation finishes.*
 *
 * For instance:
 * - `createDatabase` returns an `AstraDbAdmin` object, but it won’t point to an active database until creation is complete.
 * - `createKeyspace` won't actually allow you to use that keyspace until the database is back to active.
 *
 * @example
 * ```ts
 * // Will return immediately without waiting for operation completion
 * //
 * // The AstraDbAdmin object is still returned, but it's not very useful
 * // until the operation completes.
 * const dbAdmin3 = await admin.createDatabase({...}, {
 *   blocking: false,
 * });
 * ```
 *
 * ---
 *
 * @field blocking - Whether to block the operation until it is complete *(default: `true`)*
 * @field pollInterval - The interval (in milliseconds) at which to poll the operation for completion *(optional)*
 *
 * @public
 */
export declare type AstraAdminBlockingOptions = AstraPollBlockingOptions | AstraNoBlockingOptions;

/**
 * ##### Overview
 *
 * Represents the common properties shared by both {@link AstraPartialDatabaseInfo} and {@link AstraFullDatabaseInfo}.
 *
 * This includes identifiers, basic configuration, status, and environment details.
 *
 * @public
 */
export declare interface AstraBaseDatabaseInfo {
    /**
     * The unique UUID of the database.
     */
    id: string;
    /**
     * The user-provided name of the database.
     */
    name: string;
    /**
     * The list of keyspaces currently present in the database.
     *
     * The list may technically be empty in rare corner cases, if they have all been deleted, but it is quite unlikely.
     */
    keyspaces: string[];
    /**
     * The current status of the database.
     *
     * Common values include:
     * - `'PENDING'`
     * - `'ACTIVE'`
     * - `'DELETING'`
     * - `'HIBERNATED'`
     * - `'TERMINATED'`
     *
     * Status values indicate the provisioning/operational state of the database.
     *
     * {@link AstraDatabaseStatus} contains a large amount of possible statuses (though many are unlikely), but the enumeration is open to other statuses not mentioned.
     */
    status: AstraDatabaseStatus;
    /**
     * The cloud provider where the database is hosted.
     *
     * Valid values include `'AWS'`, `'GCP'`, and `'AZURE'`.
     */
    cloudProvider: AstraDatabaseCloudProvider;
    /**
     * The Astra environment in which the database is running.
     *
     * Not relevant for most users' usage.
     */
    environment: 'dev' | 'test' | 'prod';
    /**
     * The full raw response received from the DevOps API when querying for database metadata.
     *
     * This field is provided for inspection or debugging, and contains fields not explicitly typed/present in this interface.
     */
    raw: Record<string, any>;
}

/**
 * Represents the available cloud providers that DataStax Astra offers for database hosting.
 *
 * @public
 */
export declare type AstraDatabaseCloudProvider = 'AWS' | 'GCP' | 'AZURE';

/**
 * Represents all possible cloud providers that you can filter by.
 *
 * @public
 */
export declare type AstraDatabaseCloudProviderFilter = AstraDatabaseCloudProvider | 'ALL';

/**
 * ##### Overview
 *
 * Represents the core definition options for creating a new vector-enabled DataStax Astra database.
 *
 * This includes required settings such as the database name, cloud provider, and region, as well as an optionally specified keyspace.
 *
 * Note that:
 * - If no `keyspace` is provided, Astra will automatically provide a keyspace named `default_keyspace`.
 * - Available regions may vary depending on the selected cloud provider.
 * - It is **not possible** to create a non-vector database through the Data API clients.
 *
 * **Disclaimer: database creation is a lengthy operation, and may take upwards of 2-3 minutes**
 *
 * ---
 *
 * ##### Example
 *
 * These options are used in the first parameter of the `createDatabase` method.
 *
 * @example
 * ```ts
 * const dbAdmin = await admin.createDatabase({
 *   name: 'my-db',
 *   cloudProvider: 'GCP',
 *   region: 'us-central1',
 * });
 * ```
 *
 * @see AstraAdmin.createDatabase
 * @see CreateAstraDatabaseOptions
 *
 * @public
 */
export declare interface AstraDatabaseConfig {
    /**
     * A user-defined name for the database, e.g. `my_database`.
     */
    name: string;
    /**
     * The cloud provider where the database will be hosted.
     *
     * Supported values include `'AWS'`, `'GCP'`, and `'AZURE'`.
     *
     * **Note: available regions vary across providers.**
     */
    cloudProvider: AstraDatabaseCloudProvider;
    /**
     * The specific cloud region in which the database will be deployed, e.g. `us-east1`.
     *
     * **Note: the region must be valid for the selected `cloudProvider`.**
     */
    region: string;
    /**
     * The default keyspace to create within the database, e.g. `my_keyspace`.
     *
     * If omitted, Astra will automatically provide a keyspace named `default_keyspace`.
     */
    keyspace?: string;
}

/**
 * ##### Overview
 *
 * Represents data about a region in which an Astra database is hosted.
 *
 * This includes the region name, the API endpoint to use when interacting with that region, and the created-at timestamp.
 *
 * Used within the `regions` field of {@link AstraFullDatabaseInfo}, which may include multiple region entries for multi-region databases.
 *
 * @public
 */
export declare interface AstraDatabaseRegionInfo {
    /**
     * The name of the region where the database is hosted, e.g. `us-east1`.
     */
    name: string;
    /**
     * The API endpoint for the region, e.g. `https://<db-id>-<region>.apps.astra.datastax.com`.
     */
    apiEndpoint: string;
    /**
     * A timestamp representing when this region was created.
     */
    createdAt: Date;
}

/**
 * Represents the possible statuses of a database.
 *
 * For future compatability reasons, the enumeration is intentionally left open-ended, in case statuses may be added or modified in the future.
 *
 * @public
 */
export declare type AstraDatabaseStatus = LitUnion<'ACTIVE' | 'ERROR' | 'DECOMMISSIONING' | 'DEGRADED' | 'HIBERNATED' | 'HIBERNATING' | 'INITIALIZING' | 'MAINTENANCE' | 'PARKED' | 'PARKING' | 'PENDING' | 'PREPARED' | 'PREPARING' | 'RESIZING' | 'RESUMING' | 'TERMINATED' | 'TERMINATING' | 'UNKNOWN' | 'UNPARKING' | 'SYNCHRONIZING'>;

/**
 * Represents all possible statuses of a database that you can filter by.
 *
 * @public
 */
export declare type AstraDatabaseStatusFilter = AstraDatabaseStatus | 'ALL' | 'NONTERMINATED';

/**
 * An administrative class for managing Astra databases, including creating, listing, and deleting keyspaces.
 *
 * **Shouldn't be instantiated directly; use {@link Db.admin} or {@link AstraDbAdmin.dbAdmin} to obtain an instance of this class.**
 *
 * To manage databases as a whole, see {@link AstraAdmin}.
 *
 * @example
 * ```typescript
 * const client = new DataAPIClient('*TOKEN*');
 *
 * // Create an admin instance through a Db
 * const db = client.db('*ENDPOINT*');
 * const dbAdmin1 = db.admin();
 * const dbAdmin2 = db.admin({ adminToken: 'stronger-token' });
 *
 * // Create an admin instance through an AstraAdmin
 * const admin = client.admin();
 * const dbAdmin3 = admin.dbAdmin('*ENDPOINT*');
 * const dbAdmin4 = admin.dbAdmin('*DB_ID*', '*REGION*');
 *
 * const keyspaces = await admin1.listKeyspaces();
 * console.log(keyspaces);
 *
 * const dbInfo = await admin1.info();
 * console.log(dbInfo);
 * ```
 *
 * @see Db.admin
 * @see AstraDbAdmin.dbAdmin
 *
 * @public
 */
export declare class AstraDbAdmin extends DbAdmin {    /* Excluded from this release type: __constructor */
    /**
     * Gets the ID of the Astra DB instance this object is managing.
     *
     * @returns The ID of the Astra DB instance.
     */
    get id(): string;
    /**
     * Gets the underlying `Db` object. The options for the db were set when the `AstraDbAdmin` instance, or whatever
     * spawned it, was created.
     *
     * @example
     * ```typescript
     * const dbAdmin = client.admin().dbAdmin('<endpoint>', {
     *   keyspace: 'my_keyspace',
     *   useHttp2: false,
     * });
     *
     * const db = dbAdmin.db();
     * console.log(db.id);
     * ```
     *
     * @returns The underlying `Db` object.
     */
    db(): Db;
    /**
     * Fetches the complete information about the database, such as the database name, IDs, region, status, actions, and
     * other metadata.
     *
     * The method issues a request to the DevOps API each time it is invoked, without caching mechanisms;
     * this ensures up-to-date information for usages such as real-time collections validation by the application.
     *
     * @example
     * ```typescript
     * const info = await dbAdmin.info();
     * console.log(info.info.name, info.creationTime);
     * ```
     *
     * @returns A promise that resolves to the complete database information.
     */
    info(options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<AstraFullDatabaseInfo>;
    /**
     * Lists the keyspaces in the database.
     *
     * The first element in the returned array is the default keyspace of the database, and the rest are additional
     * keyspaces in no particular order.
     *
     * @example
     * ```typescript
     * const keyspaces = await dbAdmin.listKeyspaces();
     *
     * // ['default_keyspace', 'my_other_keyspace']
     * console.log(keyspaces);
     * ```
     *
     * @returns A promise that resolves to list of all the keyspaces in the database.
     */
    listKeyspaces(options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<string[]>;
    /**
     * Creates a new, additional, keyspace for this database.
     *
     * **NB. this is a "long-running" operation. See {@link AstraAdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 1 second. Expect it to take roughly 8-10 seconds to complete.
     *
     * @example
     * ```typescript
     * await dbAdmin.createKeyspace('my_other_keyspace1');
     *
     * // ['default_keyspace', 'my_other_keyspace1']
     * console.log(await dbAdmin.listKeyspaces());
     *
     * await dbAdmin.createKeyspace('my_other_keyspace2', {
     *   blocking: false,
     * });
     *
     * // Will not include 'my_other_keyspace2' until the operation completes
     * console.log(await dbAdmin.listKeyspaces());
     * ```
     *
     * @remarks
     * Note that if you choose not to block, the created keyspace will not be able to be used until the
     * operation completes, which is up to the caller to determine.
     *
     * @param keyspace - The name of the new keyspace.
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     */
    createKeyspace(keyspace: string, options?: CreateAstraKeyspaceOptions): Promise<void>;
    /**
     * Drops a keyspace from this database.
     *
     * **NB. this is a "long-running" operation. See {@link AstraAdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 1 second. Expect it to take roughly 8-10 seconds to complete.
     *
     * @example
     * ```typescript
     * await dbAdmin.dropKeyspace('my_other_keyspace1');
     *
     * // ['default_keyspace', 'my_other_keyspace2']
     * console.log(await dbAdmin.listKeyspaces());
     *
     * await dbAdmin.dropKeyspace('my_other_keyspace2', {
     *   blocking: false,
     * });
     *
     * // Will still include 'my_other_keyspace2' until the operation completes
     * // ['default_keyspace', 'my_other_keyspace2']
     * console.log(await dbAdmin.listKeyspaces());
     * ```
     *
     * @remarks
     * Note that if you choose not to block, the keyspace will still be able to be used until the operation
     * completes, which is up to the caller to determine.
     *
     * @param keyspace - The name of the keyspace to drop.
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     */
    dropKeyspace(keyspace: string, options?: DropAstraKeyspaceOptions): Promise<void>;
    /**
     * Drops the database.
     *
     * **NB. this is a long-running operation. See {@link AstraAdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 10 seconds. Expect it to take roughly 6-7 min to complete.
     *
     * The database info will still be accessible by ID, or by using the {@link AstraAdmin.listDatabases} method with the filter
     * set to `'ALL'` or `'TERMINATED'`. However, all of its data will very much be lost.
     *
     * @example
     * ```typescript
     * const db = client.db('https://<db_id>-<region>.apps.astra.datastax.com');
     * await db.admin().drop();
     * ```
     *
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     *
     * @remarks Use with caution. Use a surge protector. Don't say I didn't warn you.
     */
    drop(options?: DropAstraKeyspaceOptions): Promise<void>;
    get _httpClient(): OpaqueHttpClient;
    /* Excluded from this release type: _getDataAPIHttpClient */
}

/**
 * Represents the options for dropping a database (i.e. blocking options + timeout options).
 *
 * @public
 */
export declare type AstraDropDatabaseOptions = AstraAdminBlockingOptions & WithTimeout<'databaseAdminTimeoutMs'>;

/**
 * ##### Overview
 *
 * Represents the complete metadata returned for an Astra database.
 *
 * This is returned from {@link AstraDbAdmin.info} and {@link AstraAdmin.dbInfo}, whereas {@link AstraPartialDatabaseInfo} is used for {@link Db.info}.
 *
 * @example
 * ```ts
 * const fullInfo = await db.admin().info(),
 *
 * // 'ACTIVE'
 * console.log(fullInfo.status),
 *
 * // 'https://<db-id>-<region>.apps.astra.datastax.com'
 * console.log(fullInfo.regions[0].apiEndpoint),
 * ```
 *
 * @see AstraBaseDatabaseInfo
 *
 * @public
 */
export declare interface AstraFullDatabaseInfo extends AstraBaseDatabaseInfo {
    /**
     * A timestamp representing when the database was initially created.
     */
    createdAt: Date;
    /**
     * A timestamp representing the most recent time the database was accessed (read/write).
     */
    lastUsed: Date;
    /**
     * Information about the regions in which the database is deployed.
     *
     * It should contain at least one value, but may have more for multi-region deployments.
     *
     * Contains the region name, API endpoint for that region, and the timestamp when that region was created.
     */
    regions: AstraDatabaseRegionInfo[];
    /**
     * The unique organization UUID that owns this database.
     */
    orgId: string;
    /**
     The unique user UUID that owns this database.
     */
    ownerId: string;
}

/**
 * ##### Overview (See {@link AstraAdminBlockingOptions})
 *
 * This is one of the possible shapes for {@link AstraAdminBlockingOptions}, specifying **non-blocking** behavior.
 *
 * In this mode, the operation returns immediately after initiating the request. Completion must be checked manually.
 *
 * **Refer to {@link AstraAdminBlockingOptions} for full behavior details, examples, and important caveats.**
 *
 * @public
 */
export declare interface AstraNoBlockingOptions {
    /**
     * Whether to block the operation until it is complete.
     *
     * Set `blocking` to `false` to disable blocking, and have the method return without waiting for completion.
     */
    blocking: false;
}

/**
 * ##### Overview
 *
 * Represents the partial metadata of a database, as returned from {@link Db.info}.
 *
 * For the {@link AstraFullDatabaseInfo}, use either {@link AstraDbAdmin.info} or {@link AstraAdmin.dbInfo}.
 *
 * This type includes a limited view of database properties, based on the {@link Db}'s region, sufficient for most runtime use cases, but perhaps not for all administrative operations.
 *
 * @example
 * ```ts
 * const partialInfo = await db.info();
 * console.log(partialInfo.region); // e.g. "us-west2"
 * ```
 *
 * @see AstraBaseDatabaseInfo
 * @see AstraFullDatabaseInfo
 *
 * @public
 */
export declare interface AstraPartialDatabaseInfo extends AstraBaseDatabaseInfo {
    /**
     * The region being used by the {@link Db} instance, extracted directly from the {@link Db.endpoint}.
     *
     * There may or may not be more regions available, but they are not listed here; see {@link AstraFullDatabaseInfo} for that.
     */
    region: string;
    /**
     * The region being used by the {@link Db} instance, the same as the {@link Db.endpoint}.
     *
     * There may or may not be more api endpoints available, 1:1 with the number of regions available, but they are not listed here; see {@link AstraFullDatabaseInfo} for that.
     */
    apiEndpoint: string;
}

/**
 * ##### Overview (See {@link AstraAdminBlockingOptions})
 *
 * This is one of the possible shapes for {@link AstraAdminBlockingOptions}, specifying **blocking** behavior.
 *
 * In this mode, operations will poll the database's status until the operation is fully complete.
 *
 * **Refer to {@link AstraAdminBlockingOptions} for full behavior details and examples.**
 *
 * @public
 */
export declare interface AstraPollBlockingOptions {
    /**
     * Whether to block the operation until it is complete.
     *
     * Set `blocking` to `true` or leave it unset to enable blocking, having the method poll until completion.
     */
    blocking?: true;
    /**
     * How often (in milliseconds) to poll the operation's status until it completes.
     *
     * Optional; if not set, a default poll interval, determined on a method-by-method basis, will be used.
     */
    pollInterval?: number;
}

/**
 * ##### Overview
 *
 * An embedding headers provider which translates AWS access keys into the appropriate authentication headers for
 * AWS-based embedding providers (e.g. `bedrock`).
 *
 * Sets the headers `x-embedding-access-id` and `x-embedding-secret-id`.
 *
 * @example
 * ```typescript
 * const provider = new AWSEmbeddingHeadersProvider(
 *   'access-key-id',
 *   'secret-access-key',
 * );
 * const collections = await db.collections('my_coll', { embeddingApiKey: provider });
 * ```
 *
 * @see EmbeddingHeadersProvider
 *
 * @public
 */
export declare class AWSEmbeddingHeadersProvider extends StaticHeadersProvider<'embedding'> {
    /**
     * Constructs an instead of the {@link AWSEmbeddingHeadersProvider}.
     *
     * @param accessKeyId - The access key ID part of the AWS access keys
     * @param secretAccessKey - The secret access key part of the AWS access keys
     */
    constructor(accessKeyId: string, secretAccessKey: string);
}

/**
 * ##### Overview
 *
 * The base class of all events that may be emitted/logged by some {@link HierarchicalLogger} (e.g. a `DataAPIClient`, `DbAdmin`, `Collection`, etc.)
 *
 * Using events over direct logging allows for more flexibility in how the events are handled, such as:
 * - Logging to different outputs (e.g., files, external log aggregators)
 * - Integrating with custom logging frameworks (e.g., winston, Bunyan)
 * - Filtering or modifying events dynamically
 *
 * Each event is associated with a unique `requestId`, which can be used to track a specific request across multiple event emissions.
 *
 * See {@link DataAPIClientEventMap} & {@link LoggingConfig} for much more info.
 *
 * @public
 */
export declare abstract class BaseClientEvent {
    /* Excluded from this release type: _permits */
    /* Excluded from this release type: _defaultFormatter */
    /**
     * ##### Overview
     *
     * Sets the default formatter for all events.
     *
     * Useful especially if you want to change the format of events as they're logged to `stdout`/`stderr` (see {@link LoggingOutputs}).
     *
     * See {@link EventFormatter} for much more info.
     *
     * ##### Disclaimer
     *
     * This method sets a static property on the class, so it will affect _all_ instances of `BaseClientEvent`, regardless of the class. Be careful when using this method in a shared environment.
     *
     * @example
     * ```ts
     * BaseClientEvent.setDefaultFormatter((event, msg) => `[${event.name}] ${msg}`);
     * ```
     *
     * @param formatter - A function that transforms an event into a log string.
     */
    static setDefaultFormatter(formatter: EventFormatter): void;
    /**
     * The name of the event (e.g., `'CommandStarted'`, `'CommandFailed'`).
     */
    readonly name: string;
    /**
     * The timestamp of when the event was created.
     */
    readonly timestamp: Date;
    /**
     * ##### Overview
     *
     * A unique identifier for the request that triggered this event.
     *
     * It helps correlate multiple events occurring within the same request lifecycle.
     *
     * ##### Disclaimer
     *
     * High-level operations, such as `collection.insertMany(...)`, may generate multiple requests internally. Each of these requests will have its own unique `requestId`.
     *
     * ##### Example
     *
     * As an example, a `CommandStarted` event may be emitted when a command is started, and a `CommandSucceeded` event may be emitted when the command has succeeded. Both of these events will have the same `requestId`.
     *
     * If logged to a file (e.g. winston with a file transport and json format), you could then filter all events with the same `requestId` to see the entire lifecycle of a single command.
     *
     * @example
     * ```typescript
     * // Set up event listeners on the collection
     * collection.on('commandStarted', (e) => {
     *   console.log(`Command started with requestId: ${e.requestId}`);
     * });
     * collection.on('commandSucceeded', (e) => {
     *   console.log(`Command succeeded with requestId: ${e.requestId}`);
     * });
     *
     * // Logs:
     * // - Command started with requestId: dac0d3ba-79e8-4886-87b9-20237c507eba
     * // - Command succeeded with requestId: dac0d3ba-79e8-4886-87b9-20237c507eba
     * await collection.insertOne({ name: 'Alice' });
     *
     * // Logs:
     * // - Command started with requestId: 1fe46a92-8187-4eaa-a3c2-80a964b68eba
     * // - Command succeeded with requestId: 1fe46a92-8187-4eaa-a3c2-80a964b68eba
     * await collection.insertOne({ name: 'Bob' });
     * ```
     */
    readonly requestId: string;
    /**
     * Any extra information that may be useful for logging/debugging purposes.
     *
     * Some commands may set this; others may not. **Guaranteed to always have at least one key if not undefined.**
     */
    readonly extraLogInfo?: Record<string, any>;
    /* Excluded from this release type: _propagationState */
    /* Excluded from this release type: __constructor */
    abstract getMessagePrefix(): string;
    abstract getMessage(): string;
    /**
     * ##### Overview
     *
     * Formats the event into a human-readable string, as it would be logged to `stdout`/`stderr` (if enabled).
     *
     * See {@link EventFormatter} & {@link BaseClientEvent.setDefaultFormatter} for more information about custom formatting.
     *
     * @param formatter - Optional custom formatter function.
     * @returns The formatted event string.
     */
    format(formatter?: EventFormatter): string;
    /**
     * ##### Overview
     *
     * Converts the event to a verbose JSON format, as it would be logged to `stdout:verbose`/`stderr:verbose` (if enabled).
     *
     * Useful for debugging. The output is pretty-printed JSON with newlines, so perhaps not ideal for structured logging though.
     *
     * @returns A JSON string with full event details.
     */
    formatVerbose(): string;
    /* Excluded from this release type: _modifyEventForFormatVerbose */
    /**
     * ##### Overview
     *
     * Stops the event from bubbling up to the parent listener (e.g. `Collection` → `Db` → `DataAPIClient`).
     *
     * @example
     * ```ts
     * client.on('commandStarted', (e) => {
     *   console.log('Command started (client listener)');
     * });
     *
     * db.on('commandStarted', (e) => {
     *   console.log('Command started (db listener)');
     *   e.stopPropagation();
     * });
     *
     * collection.on('commandStarted', (e) => {
     *   console.log('Command started (collection listener)');
     * });
     *
     * // Logs:
     * // - Command started (collection listener)
     * // - Command started (db) listener
     * collection.insertOne({ name: 'Alice' });
     * ```
     *
     * @see stopImmediatePropagation
     */
    stopPropagation(): void;
    /**
     * ##### Overview
     *
     * Stops the event from bubbling up to the parent listener (e.g. `Collection` → `Db` → `DataAPIClient`) and prevents any further listeners from being called.
     *
     * @example
     * ```ts
     * db.on('commandStarted', (e) => {
     *   console.log('Command started (db listener)');
     * });
     *
     * collection.on('commandStarted', (e) => {
     *   console.log('Command started (collection listener #1)');
     *   e.stopImmediatePropagation();
     * });
     *
     * collection.on('commandStarted', (e) => {
     *   console.log('Command started (collection listener #2)');
     * });
     *
     * // Logs:
     * // - Command started (collection listener #1)
     * collection.insertOne({ name: 'Alice' });
     * ```
     *
     * @see stopPropagation
     */
    stopImmediatePropagation(): void;
    trimDuplicateFields(): this;
}

/**
 * @public
 */
export declare interface BaseDesCtx<DesCtx> extends BaseSerDesCtx {
    deserializers: Deserializers<DesCtx>;
    rawDataApiResp: RawDataAPIResponse;
}

/**
 * @public
 */
export declare interface BaseSerCtx<SerCex> extends BaseSerDesCtx {
    serializers: Serializers<SerCex>;
}

/**
 * @public
 */
export declare interface BaseSerDesConfig<SerCtx extends BaseSerCtx<any>, DesCtx extends BaseDesCtx<any>> {
    /**
     * ##### Overview (Alpha)
     *
     * Provides a structured interface for integrating custom serialization/deserialization logic for documents/rows, filters, ids, etc.
     *
     * You may create implementations of these codecs through the {@link TableCodecs} and {@link CollectionCodecs} classes.
     *
     * See {@link TableSerDesConfig.codecs} & {@link CollectionSerDesConfig.codecs} for much more information.
     *
     * ##### Disclaimer
     *
     * Codecs are a powerful feature, but should be used with caution. It's possible to break the client's behavior by using the features incorrectly.
     *
     * Always test your codecs with a variety of documents to ensure that they behave as expected, before using them on real data.
     *
     * @alpha
     */
    codecs?: (readonly RawCodec<SerCtx, DesCtx>[])[];
    /**
     * ##### Overview
     *
     * Enables an optimization which allows inserted rows/documents to be mutated in-place when serializing.
     *
     * The feature is stable; however, the state of any document after being serialized is not guaranteed.
     *
     * This will mutate filters and update filters as well.
     *
     * ##### Context
     *
     * For example, when you insert a record like so:
     * ```ts
     * import { uuid } from '@datastax/astra-db-ts';
     * await collection.insertOne({ name: 'Alice', friends: { john: uuid('...') } });
     * ```
     *
     * The document is internally serialized as such:
     * ```ts
     * { name: 'Alice', friends: { john: { $uuid: '...' } } }
     * ```
     *
     * To avoid mutating a user-provided object, the client will be forced to clone any objects that contain
     * a custom datatype, as well as their parents (which looks something like this):
     * ```ts
     * { ...original, friends: { ...original.friends, john: { $uuid: '...' } } }
     * ```
     *
     * ##### Enabling this option
     *
     * This can be a minor performance hit, especially for large objects, so if you're confident that you won't be
     * needing the object after it's inserted, you can enable this option to avoid the cloning, and instead mutate
     * the object in-place.
     *
     * @example
     * ```ts
     * // Before
     * const collection = db.collection<User>('users');
     *
     * const doc = { name: 'Alice', friends: { john: uuid.v4() } };
     * await collection.insertOne(doc);
     *
     * console.log(doc); // { name: 'Alice', friends: { john: UUID<4>('...') } }
     *
     * // After
     * const collection = db.collection<User>('users', {
     *   serdes: { mutateInPlace: true },
     * });
     *
     * const doc = { name: 'Alice', friends: { john: UUID.v4() } };
     * await collection.insertOne(doc);
     *
     * console.log(doc); // { name: 'Alice', friends: { john: { $uuid: '...' } } }
     * ```
     *
     * @defaultValue false
     */
    mutateInPlace?: boolean;
}

/**
 * @public
 */
export declare interface BaseSerDesCtx {
    rootObj: any;
    path: PathSegment[];
    done<T>(obj?: T): readonly [0, T?];
    recurse<T>(obj?: T): readonly [1, T?];
    replace<T>(obj: T): readonly [2, T];
    nevermind(): readonly [3];
    mapAfter(map: (v: any) => unknown): readonly [3];
    mutatingInPlace: boolean;
    locals: Record<string, any>;
    target: SerDesTarget;
}

export { BigNumber }

/* Excluded from this release type: BigNumberHack */

/**
 * A shorthand function for `new DataAPIBlob(blob)`
 *
 * @public
 */
export declare const blob: (blob: DataAPIBlobLike) => DataAPIBlob;

/**
 * ##### Overview
 *
 * Simple utility function to build an Astra endpoint from a database ID and region.
 *
 * Useful if you're trying to use {@link DataAPIClient.db} or something along those lines, which require a full endpoint URL, but you only have an ID and region to work with.
 *
 * @example
 * ```ts
 * import { buildAstraEndpoint } from '@datastax/astra-db-ts';
 *
 * // 'https://<id>-<region>.apps.astra.datastax.com'
 * const endpoint = buildAstraEndpoint('<id>', '<region>');
 * ```
 *
 * @public
 */
export declare function buildAstraEndpoint(id: string, region: string, env?: 'dev' | 'test' | 'prod'): string;

/**
 * ##### Overview
 *
 * The caller information to send with requests, of the form `[name, version?]`, or an array of such.
 *
 * **Intended generally for integrations or frameworks that wrap the client.**
 *
 * Used to identify the client making requests to the server.
 *
 * It will be sent in the headers of the request as such:
 * ```
 * User-Agent: ...<name>/<version> astra-db-ts/<version>
 * ```
 *
 * If no caller information is provided, the client will simply be identified as `astra-db-ts/<version>`.
 *
 * **NB. If providing an array of callers, they should be ordered from most important to least important.**
 *
 * @public
 */
export declare type Caller = readonly [name: string, version?: string];

/* Excluded from this release type: CallerCfgHandler */

/* Excluded from this release type: ClientKind */

/**
 * @beta
 */
export declare type CollCustomCodecOpts = CustomCodecOpts<CollectionSerCtx, CollectionDesCtx>;

/**
 * ##### Overview
 *
 * Represents the interface to a collection in a Data-API-enabled database.
 *
 * > **⚠️Warning**: This isn't directly instantiated, but spawned via {@link Db.createCollection} or {@link Db.collection}.
 *
 * @example
 * ```ts
 * const collection = db.collection<Type?>('my_collection');
 * ```
 *
 * ---
 *
 * ##### Typing the collection
 *
 * Collections are inherently untyped, but you can provide your own client-side compile-time schema for type inference and early-bug-catching purposes.
 *
 * > **🚨Important:** For most intents & purposes, you can ignore the (generally negligible) difference between _WSchema_ and _RSchema_, and treat {@link Collection} as if it were typed as `Collection<Schema>`.
 *
 * A `Collection` is typed as `Collection<WSchema, RSchema>`, where:
 * - `WSchema` is the type of the row as it's written to the table (the "write" schema)
 *    - This includes inserts, filters, sorts, etc.
 *  - `RSchema` is the type of the row as it's read from the table (the "read" schema)
 *    - This includes finds
 *    - Unless custom ser/des is used, it is nearly exactly the same as `WSchema`
 *    - This defaults to `FoundDoc<WSchema>` (see {@link FoundDoc})
 *
 * ---
 *
 * ##### Typing the `_id`
 *
 * The `_id` field of the document may be any valid JSON scalar (including {@link Date}, {@link UUID}, and {@link ObjectId}).
 * - See {@link SomeId} for the enumeration of all valid types.
 * - See {@link CollectionDefaultIdOptions} for more info on setting default `_id`s.
 *
 * The type of the `_id` field is extracted from the collection schema via the {@link IdOf} utility type.
 *
 * > **💡Tip:** See {@link SomeId} for much more information on the `_id` field.
 *
 * @example
 * ```ts
 * interface User {
 *   _id: UUID,
 *   name: string,
 * }
 *
 * const coll = await db.createCollection<User>('users', {
 *   defaultId: { type: 'uuid' },
 * });
 *
 * const resp = await coll.insertOne({ name: 'Alice' });
 * console.log(resp.insertedId.version) // 4
 * ```
 *
 * ---
 *
 * ##### Datatypes
 *
 * Certain datatypes may be represented as TypeScript classes (some native, some provided by `astra-db-ts`), however.
 *
 * For example:
 * - `$date` is represented by a native JS {@link Date}
 * - `$uuid` is represented by an `astra-db-ts` provided {@link UUID}
 * - `$vector` is represented by an `astra-db-ts` provided {@link DataAPIVector}
 *
 * You may also provide your own datatypes by providing some custom serialization logic as well (see later section).
 *
 * @example
 * ```ts
 * interface User {
 *   _id: string,
 *   dob: Date,
 *   friends?: Record<string, UUID>, // UUID is also `astra-db-ts` provided
 *   $vector: DataAPIVector,
 * }
 *
 * await db.collection<User>('users').insertOne({
 *   _id: '123',
 *   dob: new Date(),
 *   $vector: new DataAPIVector([1, 2, 3]), // This can also be passed as a number[]
 * });
 * ```
 *
 * The full list of relevant datatypes (for collections) includes: {@link UUID}, {@link ObjectId}, {@link Date}, {@link DataAPIVector} and {@link BigNumber}.
 *
 * ---
 *
 * ##### Big numbers
 *
 * By default, big numbers (`bigint`s and {@link BigNumber}s from `bignumber.js`) are disabled, and will error when attempted to be serialized, and will lose precision when deserialized.
 *
 * See {@link CollectionSerDesConfig.enableBigNumbers} for more information on enabling big numbers in collections.
 *
 * ---
 *
 * ##### Custom datatypes
 *
 * You can plug in your own custom datatypes, as well as enable many other features by providing some custom serialization/deserialization logic through the `serdes` option in {@link CollectionOptions}, {@link DbOptions}, and/or {@link DataAPIClientOptions.dbOptions}.
 *
 * Note however that this is currently not entirely stable, and should be used with caution.
 *
 * ---
 *
 * ##### 🚨Disclaimers
 *
 * *Collections are inherently untyped. There is no runtime type validation or enforcement of the schema.*
 *
 * *It is on the user to ensure that the TS type of the `Collection` corresponds with the actual intended collection schema, in its TS-deserialized form. Incorrect or dynamic tying could lead to surprising behaviors and easily-preventable errors.*
 *
 * @see SomeDoc
 * @see Db.createCollection
 * @see Db.collection
 * @see CollectionDefaultIdOptions
 * @see CollectionSerDesConfig
 * @see CollectionOptions
 *
 * @public
 */
export declare class Collection<WSchema extends SomeDoc = SomeDoc, RSchema extends WithId<SomeDoc> = FoundDoc<WSchema>> extends HierarchicalLogger<CommandEventMap> {    /**
     * ##### Overview
     *
     * The user-provided, case-sensitive. name of the collection
     *
     * This is unique among all tables and collections in its keyspace, but not necessarily unique across the entire database.
     *
     * It is up to the user to ensure that this collection really exists.
     */
    readonly name: string;
    /**
     * ##### Overview
     *
     * The keyspace where the collection resides in.
     *
     * It is up to the user to ensure that this keyspace really exists, and that this collection is in it.
     */
    readonly keyspace: string;
    /* Excluded from this release type: __constructor */
    /**
     * ##### Overview
     *
     * Atomically inserts a single document into the collection.
     *
     * See {@link CollectionInsertOneOptions} and {@link CollectionInsertOneResult} as well for more information.
     *
     * @example
     * ```ts
     * import { UUID, ObjectId, ... } from '@datastax/astra-db-ts';
     *
     * // Insert a document with a specific ID
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     * await collection.insertOne({ _id: new ObjectID(), name: 'Jane Doe' });
     * await collection.insertOne({ _id: UUID.v7(), name: 'Dane Joe' });
     *
     * // Insert a document with a vector (if enabled on the collection)
     * await collection.insertOne({ _id: 1, name: 'Jane Doe', $vector: [.12, .52, .32] });
     *
     * // or if vectorize (auto-embedding-generation) is enabled
     * await collection.insertOne({ _id: 1, name: 'Jane Doe', $vectorize: "Hey there!" });
     * ```
     *
     * ---
     *
     * ##### The `_id` field
     *
     * If the document does not contain an `_id` field, the server will **generate an _id** for the document.
     * - The type of the generated id may be specified in {@link CollectionDefinition.defaultId} at collection creation, otherwise it'll just be a raw UUID string.
     * - This generation does not mutate the document.
     *
     * If an `_id` is provided which corresponds to a document that already exists in the collection, a {@link DataAPIResponseError} is raised, and the insertion fails.
     *
     * If you prefer to upsert a document instead, see {@link Collection.replaceOne}.
     *
     * > **💡Tip:** See {@link SomeId} for much more information on the `_id` field.
     *
     * @example
     * ```typescript
     * // Insert a document with an autogenerated ID
     * await collection.insertOne({ name: 'Jane Doe' });
     *
     * // Use the inserted ID (generated or not)
     * const resp = await collection.insertOne({ name: 'Lemmy' });
     * console.log(resp.insertedId);
     *
     * // Or if the collection has a default ID
     * const collection = db.createCollection('users', {
     *   defaultId: { type: 'uuid' },
     * });
     *
     * const resp = await collection.insertOne({ name: 'Lemmy' });
     * console.log(resp.insertedId.version); // 4
     * ```
     *
     * @param document - The document to insert.
     * @param options - The options for this operation.
     *
     * @returns The ID of the inserted document.
     *
     * @see CollectionInsertOneOptions
     * @see CollectionInsertOneResult
     */
    insertOne(document: MaybeId<WSchema>, options?: CollectionInsertOneOptions): Promise<CollectionInsertOneResult<RSchema>>;
    /**
     * ##### Overview
     *
     * Inserts many documents into the collection.
     *
     * See {@link CollectionInsertManyOptions} and {@link CollectionInsertManyResult} as well for more information.
     *
     * @example
     * ```ts
     * import { uuid } from '@datastax/astra-db-ts';
     *
     * await collection.insertMany([
     *   { _id: uuid.v4(), name: 'John Doe' }, // or UUID.v4()
     *   { name: 'Jane Doe' },
     * ]);
     * ```
     *
     * ---
     *
     * ##### Chunking
     *
     * > **🚨Important:** This function inserts documents in chunks to avoid exceeding insertion limits, which means it may make multiple requests to the server. As a result, this operation is **not necessarily atomic.**
     * >
     * > If the dataset is large or the operation is ordered, it may take a relatively significant amount of time. During this time, documents inserted by other concurrent processes may be written to the database, potentially causing duplicate id conflicts. In such cases, it's not guaranteed which write will succeed.
     *
     * By default, it inserts documents in chunks of 50 at a time. You can fine-tune the parameter through the `chunkSize` option. Note that increasing chunk size won't always increase performance. Instead, increasing concurrency may help.
     *
     * You can set the `concurrency` option to control how many network requests are made in parallel on unordered insertions. Defaults to `8`.
     *
     * @example
     * ```ts
     * const docs = Array.from({ length: 100 }, (_, i) => ({ _id: i }));
     * await collection.insertMany(docs, { concurrency: 16 });
     * ```
     *
     * ---
     *
     * ##### Ordered insertion
     *
     * You may set the `ordered` option to `true` to stop the operation after the first error; otherwise documents may be parallelized and processed in arbitrary order, improving, perhaps vastly, performance.
     *
     * Setting the `ordered` operation disables any parallelization so insertions truly are stopped after the very first error.
     *
     * @example
     * ```ts
     * // Will throw an InsertManyError after the 2nd doc is inserted with a duplicate key;
     * // the 3rd doc will never attempt to be inserted
     * await collection.insertMany([
     *   { _id: '1', name: 'John Doe' },
     *   { _id: '1', name: 'John Doe' },
     *   { _id: '2', name: 'Jane Doe' },
     * ], {
     *   ordered: true,
     * });
     * ```
     *
     * ---
     *
     * ##### The `_id` field
     *
     * If the document does not contain an `_id` field, the server will **generate an _id** for the document.
     * - The type of the generated id may be specified in {@link CollectionDefinition.defaultId} at collection creation, otherwise it'll just be a raw UUID string.
     * - This generation does not mutate the document.
     *
     * If an `_id` is provided which corresponds to a document that already exists in the collection, a {@link DataAPIResponseError} is raised, and the insertion fails.
     *
     * > **💡Tip:** See {@link SomeId} for much more information on the `_id` field.
     *
     * @example
     * ```typescript
     * // Insert documents with autogenerated IDs
     * await collection.insertMany([
     *   { name: 'John Doe' },
     *   { name: 'Jane Doe' },
     * ]);
     *
     * // Use the inserted IDs (generated or not)
     * const resp = await collection.insertMany([
     *   { name: 'Lemmy' },
     *   { name: 'Kilmister' },
     * ]);
     * console.log(resp.insertedIds); // will be string UUIDs
     *
     * // Or if the collection has a default ID
     * const collection = db.createCollection('users', {
     *   defaultId: { type: 'objectId' },
     * });
     *
     * const resp = await collection.insertMany([
     *   { name: 'Lynyrd' },
     *   { name: 'Skynyrd' },
     * ]);
     * console.log(resp.insertedIds[0].getTimestamp()); // will be ObjectIds
     * ```
     *
     * ---
     *
     * ##### `CollectionInsertManyError`
     *
     * If any 2XX insertion error occurs, the operation will throw an {@link CollectionInsertManyError} containing the partial result.
     *
     * If a thrown exception is not due to an insertion error, e.g. a `5xx` error or network error, the operation will throw the underlying error.
     *
     * In case of an unordered request, if the error was a simple insertion error, the {@link CollectionInsertManyError} will be thrown after every document has been attempted to be inserted. If it was a `5xx` or similar, the error will be thrown immediately.
     *
     * @param documents - The documents to insert.
     * @param options - The options for this operation.
     *
     * @returns The IDs of the inserted documents (and the count)
     *
     * @throws CollectionInsertManyError - If the operation fails.
     *
     * @see CollectionInsertManyOptions
     * @see CollectionInsertManyResult
     */
    insertMany(documents: readonly MaybeId<WSchema>[], options?: CollectionInsertManyOptions): Promise<CollectionInsertManyResult<RSchema>>;
    /**
     * ##### Overview
     *
     * Atomically updates a single document in the collection.
     *
     * See {@link CollectionFilter}, {@link CollectionUpdateFilter}, {@link CollectionUpdateOneOptions}, and {@link CollectionUpdateOneResult} as well for more information.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     * await collection.updateOne({ _id: '1' }, { $set: { name: 'Jane Doe' } });
     * ```
     *
     * ---
     *
     * ##### Upserting
     *
     * If `upsert` is set to true, it will insert the document reconstructed from the filter & the update filter if no match is found.
     *
     * @example
     * ```ts
     * const resp = await collection.updateOne(
     *   { _id: 42 },
     *   { $set: { age: 27 }, $setOnInsert: { name: 'Kasabian' } },
     *   { upsert: true },
     * );
     *
     * if (resp.upsertedCount) {
     *   console.log(resp.upsertedId); // 42
     * }
     * ```
     *
     * ---
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * > **⚠️Warning:** If the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * ---
     *
     * ##### Update by vector search
     *
     * If the collection has vector search enabled, you can update the most relevant document by providing a vector in the sort option.
     *
     * @example
     * ```ts
     * await collection.updateOne(
     *   { optionalFilter },
     *   { $set: { name: 'Jane Doe', $vectorize: 'Come out and play' } },
     *   { sort: { $vector: [.09, .58, .21] } },
     * );
     * ```
     *
     * @param filter - A filter to select the document to update.
     * @param update - The update to apply to the selected document.
     * @param options - The options for this operation.
     *
     * @returns A summary of what changed.
     *
     * @see CollectionFilter
     * @see CollectionUpdateFilter
     * @see CollectionUpdateOneOptions
     * @see CollectionUpdateOneResult
     */
    updateOne(filter: CollectionFilter<WSchema>, update: CollectionUpdateFilter<WSchema>, options?: CollectionUpdateOneOptions): Promise<CollectionUpdateOneResult<RSchema>>;
    /**
     * ##### Overview
     *
     * Updates many documents in the collection.
     *
     * See {@link CollectionFilter}, {@link CollectionUpdateFilter}, {@link CollectionUpdateManyOptions}, and {@link CollectionUpdateManyResult} as well for more information.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe', age: 30 },
     *   { name: 'Jane Doe', age: 30 },
     * ]);
     * await collection.updateMany({ age: 30 }, { $set: { age: 31 } });
     * ```
     * ---
     *
     * ##### Pagination
     *
     * > **🚨Important:** This function paginates the updating of documents due to server update limits, which means it may make multiple requests to the server. As a result, this operation is **not necessarily atomic**.
     * >
     * > Depending on the amount of matching documents, it can keep running (in a blocking manner) for a macroscopic amount of time. During this time, documents that are modified/inserted from another concurrent process/application may be modified/inserted during the execution of this method call.
     *
     * ---
     *
     * ##### Upserting
     *
     * If `upsert` is set to true, it will insert the document reconstructed from the filter & the update filter if no match is found.
     *
     * Only one document may be upserted per command.
     *
     * @example
     * ```ts
     * const resp = await collection.updateMany(
     *   { name: 'Kasabian' },
     *   { $set: { age: 27 }, $setOnInsert: { _id: 42 } },
     *   { upsert: true },
     * );
     *
     * if (resp.upsertedCount) {
     *   console.log(resp.upsertedId); // 42
     * }
     * ```
     *
     * ---
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * > **🚨Important:** If the filter is empty, _all documents in the collection will (non-atomically) be updated_. Proceed with caution.
     *
     * @param filter - A filter to select the documents to update.
     * @param update - The update to apply to the selected documents.
     * @param options - The options for this operation.
     *
     * @returns A summary of what changed.
     *
     * @see CollectionFilter
     * @see CollectionUpdateFilter
     * @see CollectionUpdateManyOptions
     * @see CollectionUpdateManyResult
     */
    updateMany(filter: CollectionFilter<WSchema>, update: CollectionUpdateFilter<WSchema>, options?: CollectionUpdateManyOptions): Promise<CollectionUpdateManyResult<RSchema>>;
    /**
     * ##### Overview
     *
     * Replaces a single document in the collection.
     *
     * See {@link CollectionFilter}, {@link CollectionReplaceOneOptions}, and {@link CollectionReplaceOneResult} as well for more information.
     *
     * @example
     * ```typescript
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     * await collection.replaceOne({ _id: '1' }, { name: 'Dohn Joe' });
     * ```
     *
     * ---
     *
     * ##### Upserting
     *
     * If `upsert` is set to true, it will insert the document reconstructed from the filter & the update filter if no match is found.
     *
     * @example
     * ```ts
     * const resp = await collection.replaceOne(
     *   { _id: 42 },
     *   { name: 'Jessica' },
     *   { upsert: true },
     * );
     *
     * if (resp.upsertedCount) {
     *   console.log(resp.upsertedId); // 42
     * }
     * ```
     *
     * ---
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * > **⚠️Warning:** If the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * ---
     *
     * ##### Replace by vector search
     *
     * If the collection has vector search enabled, you can replace the most relevant document by providing a vector in the sort option.
     *
     * @example
     * ```ts
     * await collection.insertOne({ name: 'John Doe', $vector: [.12, .52, .32] });
     *
     * await collection.replaceOne(
     *   { optionalFilter },
     *   { name: 'Jane Doe', $vectorize: 'Come out and play' },
     *   { sort: { $vector: [.11, .53, .31] } },
     * );
     * ```
     *
     * @param filter - A filter to select the document to replace.
     * @param replacement - The replacement document, which contains no `_id` field.
     * @param options - The options for this operation.
     *
     * @returns A summary of what changed.
     *
     * @see CollectionFilter
     * @see CollectionReplaceOneOptions
     * @see CollectionReplaceOneResult
     */
    replaceOne(filter: CollectionFilter<WSchema>, replacement: NoId<WSchema>, options?: CollectionReplaceOneOptions): Promise<CollectionReplaceOneResult<RSchema>>;
    /**
     * ##### Overview
     *
     * Atomically deletes a single document from the collection.
     *
     * See {@link CollectionFilter}, {@link CollectionDeleteOneOptions}, and {@link CollectionDeleteOneResult} as well for more information.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     * await collection.deleteOne({ name: 'John Doe' });
     * ```
     *
     * ---
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * > **⚠️Warning:** If the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * ---
     *
     * ##### Delete by vector search
     *
     * If the collection has vector search enabled, you can delete the most relevant document by providing a vector in the sort option.
     *
     * @example
     * ```ts
     * await collection.insertOne({ name: 'John Doe', $vector: [.12, .52, .32] });
     * await collection.deleteOne({}, { sort: { $vector: [.11, .53, .31] }});
     * ```
     *
     * @param filter - A filter to select the document to delete.
     * @param options - The options for this operation.
     *
     * @returns How many documents were deleted.
     *
     * @see CollectionFilter
     * @see CollectionDeleteOneOptions
     * @see CollectionDeleteOneResult
     */
    deleteOne(filter: CollectionFilter<WSchema>, options?: CollectionDeleteOneOptions): Promise<CollectionDeleteOneResult>;
    /**
     * ##### Overview
     *
     * Deletes many documents from the collection.
     *
     * See {@link CollectionFilter}, {@link CollectionDeleteManyOptions}, and {@link CollectionDeleteManyResult} as well for more information.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe', age: 1 },
     *   { name: 'John Doe', age: 2 },
     * ]);
     * await collection.deleteMany({ name: 'John Doe' });
     * ```
     *
     * ---
     *
     * ##### Pagination
     *
     * > **🚨Important:** This function paginates the deletion of documents due to server deletion limits, which means it may make multiple requests to the server. As a result, this operation is **not necessarily atomic**.
     * >
     * > Depending on the amount of matching documents, it can keep running (in a blocking manner) for a macroscopic amount of time. During this time, documents that are modified/inserted from another concurrent process/application may be modified/inserted during the execution of this method call.
     *
     * ---
     *
     * ##### 🚨Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * > **🚨Important:** If an empty filter is passed, **all documents in the collection will atomically be deleted in a single API call**. Proceed with caution.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe' },
     *   { name: 'Jane Doe' },
     * ]);
     *
     * const resp = await collection.deleteMany({});
     * console.log(resp.deletedCount); // -1
     * ```
     *
     * @param filter - A filter to select the documents to delete.
     * @param options - The options for this operation.
     *
     * @returns How many documents were deleted.
     *
     * @see CollectionFilter
     * @see CollectionDeleteManyOptions
     * @see CollectionDeleteManyResult
     */
    deleteMany(filter: CollectionFilter<WSchema>, options?: CollectionDeleteManyOptions): Promise<CollectionDeleteManyResult>;
    /**
     * ##### Overview
     *
     * Find documents in the collection, optionally matching the provided filter.
     *
     * See {@link CollectionFilter}, {@link CollectionFindOptions}, and {@link FindCursor} as well for more information.
     *
     * @example
     * ```ts
     * const cursor = await collection.find({ name: 'John Doe' }, { sort: { age: 1 } });
     * const docs = await cursor.toArray();
     * ```
     *
     * @example
     * ```ts
     * const cursor = await collection.find({})
     *   .sort({ age: 1 })
     *   .project<{ name: string }>({ name: 1 })
     *   .map(doc => doc.name);
     *
     * // ['John Doe', 'Jane Doe', ...]
     * const names = await cursor.toArray();
     * ```
     *
     * ---
     *
     * ##### Projection
     *
     * > **🚨Important:** When projecting, it is _heavily_ recommended to provide an explicit type override representing the projected schema, to prevent any type-mismatches when the schema is strictly provided.
     * >
     * > Otherwise, the documents will be typed as the full `Schema`, which may lead to runtime errors when trying to access properties that are not present in the projected documents.
     *
     * > **💡Tip:** Use the {@link Pick} or {@link Omit} utility types to create a type representing the projected schema.
     *
     * @example
     * ```ts
     * interface User {
     *   name: string,
     *   car: { make: string, model: string },
     * }
     *
     * const collection = db.collection<User>('users');
     *
     * // --- Not providing a type override ---
     *
     * const cursor = await collection.find({}, {
     *   projection: { car: 1 },
     * });
     *
     * const next = await cursor.next();
     * console.log(next.car.make); // OK
     * console.log(next.name); // Uh oh! Runtime error, since tsc doesn't complain
     *
     * // --- Explicitly providing the projection type ---
     *
     * const cursor = await collection.find<Pick<User, 'car'>>({}, {
     *   projection: { car: 1 },
     * });
     *
     * const next = await cursor.next();
     * console.log(next.car.make); // OK
     * console.log(next.name); // Type error; won't compile
     * ```
     *
     * ---
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the documents. See {@link CollectionFilter} for much more information.
     *
     * > **⚠️Warning:** If the filter is empty, all documents in the collection will be returned (up to any provided or server limit).
     *
     * ---
     *
     * ##### Find by vector search
     *
     * If the collection has vector search enabled, you can find the most relevant documents by providing a vector in the sort option.
     *
     * Vector ANN searches cannot return more than a set number of documents, which, at the time of writing, is 1000 items.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe', $vector: [.12, .52, .32] },
     *   { name: 'Jane Doe', $vector: [.32, .52, .12] },
     *   { name: 'Dane Joe', $vector: [.52, .32, .12] },
     * ]);
     *
     * const cursor = collection.find({}, {
     *   sort: { $vector: [.12, .52, .32] },
     * });
     *
     * // Returns 'John Doe'
     * console.log(await cursor.next());
     * ```
     *
     * ---
     *
     * ##### Sorting
     *
     * The sort option can be used to sort the documents returned by the cursor. See {@link Sort} for more information.
     *
     * If the sort option is not provided, there is no guarantee as to the order of the documents returned.
     *
     * > **🚨Important:** When providing a non-vector sort, the Data API will return a smaller number of documents (20, at the time of writing), and stop there. The returned documents are the top results across the whole collection according to the requested criterion.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe', age: 1, height: 168 },
     *   { name: 'John Doe', age: 2, height: 42 },
     * ]);
     *
     * const cursor = collection.find({}, {
     *   sort: { age: 1, height: -1 },
     * });
     *
     * // Returns 'John Doe' (age 2, height 42), 'John Doe' (age 1, height 168)
     * console.log(await cursor.toArray());
     * ```
     *
     * ---
     *
     * ##### Other options
     *
     * Other available options include `skip`, `limit`, `includeSimilarity`, and `includeSortVector`. See {@link CollectionFindOptions} and {@link FindCursor} for more information.
     *
     * If you prefer, you may also set these options using a fluent interface on the {@link FindCursor} itself.
     *
     * @example
     * ```ts
     * // cursor :: FindCursor<string>
     * const cursor = collection.find({})
     *   .sort({ $vector: [.12, .52, .32] })
     *   .projection<{ name: string, age: number }>({ name: 1, age: 1 })
     *   .includeSimilarity(true)
     *   .map(doc => `${doc.name} (${doc.age})`);
     * ```
     *
     * @remarks
     * When not specifying sorting criteria at all (by vector or otherwise),
     * the cursor can scroll through an arbitrary number of documents as
     * the Data API and the client periodically exchange new chunks of documents.
     *
     * --
     *
     * It should be noted that the behavior of the cursor in the case documents
     * have been added/removed after the `find` was started depends on database
     * internals, and it is not guaranteed, nor excluded, that such "real-time"
     * changes in the data would be picked up by the cursor.
     *
     * @param filter - A filter to select the documents to find. If not provided, all documents will be returned.
     * @param options - The options for this operation.
     *
     * @returns a FindCursor which can be iterated over.
     *
     * @see CollectionFilter
     * @see CollectionFindOptions
     * @see FindCursor
     */
    find<T extends SomeDoc = WithSim<RSchema>, TRaw extends T = T>(filter: CollectionFilter<WSchema>, options?: CollectionFindOptions): CollectionFindCursor<T, TRaw>;
    /**
     * ##### Overview (preview)
     *
     * Finds documents in a collection through a retrieval process that uses a reranker model to combine results from a vector similarity search and a lexical-based search (aka a "hybrid search").
     *
     * **Disclaimer: this method is currently in preview/beta in this release of the client.**
     *
     * @example
     * ```ts
     * // With vectorize
     * const cursor = await coll.findAndRerank({})
     *   .sort({ $hybrid: 'what is a dog?' })
     *   .includeScores();
     *
     * // Using your own vectors
     * const cursor = await coll.findAndRerank({})
     *   .sort({ $hybrid: { $vector: vector([...]), $lexical: 'what is a dog?' } })
     *   .rerankOn('$lexical')
     *   .rerankQuery('I like dogs');
     *
     * for await (const res of cursor) {
     *   console.log(cursor.document, cursor.scores);
     * }
     * ```
     *
     * @beta
     */
    findAndRerank<T extends SomeDoc = RSchema, TRaw extends T = T>(filter: CollectionFilter<WSchema>, options?: CollectionFindAndRerankOptions): CollectionFindAndRerankCursor<RerankedResult<T>, TRaw>;
    /**
     * ##### Overview
     *
     * Find a single document in the collection, optionally matching the provided filter.
     *
     * See {@link CollectionFilter} and {@link CollectionFindOneOptions} as well for more information.
     *
     * @example
     * ```ts
     * const doc = await collection.findOne({ name: 'John Doe' });
     * ```
     *
     * ---
     *
     * ##### Projection
     *
     * > **🚨Important:** When projecting, it is _heavily_ recommended to provide an explicit type override representing the projected schema, to prevent any type-mismatches when the schema is strictly provided.
     * >
     * > Otherwise, the document will be typed as the full `Schema`, which may lead to runtime errors when trying to access properties that are not present in the projected document.
     *
     * > **💡Tip:** Use the {@link Pick} or {@link Omit} utility types to create a type representing the projected schema.
     *
     * @example
     * ```ts
     * interface User {
     *   name: string,
     *   car: { make: string, model: string },
     * }
     *
     * const collection = db.collection<User>('users');
     *
     *
     * // --- Not providing a type override ---
     *
     * const doc = await collection.findOne({}, {
     *   projection: { car: 1 },
     * });
     *
     * console.log(doc.car.make); // OK
     * console.log(doc.name); // Uh oh! Runtime error, since tsc doesn't complain
     *
     * // --- Explicitly providing the projection type ---
     *
     * const doc = await collection.findOne<Pick<User, 'car'>>({}, {
     *   projection: { car: 1 },
     * });
     *
     * console.log(doc.car.make); // OK
     * console.log(doc.name); // Type error; won't compile
     * ```
     *
     * ---
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * > **⚠️Warning:** If the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * ##### Find by vector search
     *
     * If the collection has vector search enabled, you can find the most relevant document by providing a vector in the sort option.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe', $vector: [.12, .52, .32] },
     *   { name: 'Jane Doe', $vector: [.32, .52, .12] },
     *   { name: 'Dane Joe', $vector: [.52, .32, .12] },
     * ]);
     *
     * const doc = collection.findOne({}, {
     *   sort: { $vector: [.12, .52, .32] },
     * });
     *
     * // 'John Doe'
     * console.log(doc.name);
     * ```
     *
     * ##### Sorting
     *
     * The sort option can be used to pick the most relevant document. See {@link Sort} for more information.
     *
     * If the sort option is not provided, there is no guarantee as to which of the documents which matches the filter is returned.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe', age: 1, height: 168 },
     *   { name: 'John Doe', age: 2, height: 42 },
     * ]);
     *
     * const doc = collection.findOne({}, {
     *   sort: { age: 1, height: -1 },
     * });
     *
     * // 'John Doe' (age 2, height 42)
     * console.log(doc.name);
     * ```
     *
     * ##### Other options
     *
     * Other available options include `includeSimilarity`. See {@link CollectionFindOneOptions} for more information.
     *
     * If you want to get `skip` or `includeSortVector` as well, use {@link Collection.find} with a `limit: 1` instead.
     *
     * @example
     * ```ts
     * const doc = await cursor.findOne({}, {
     *   sort: { $vector: [.12, .52, .32] },
     *   includeSimilarity: true,
     * });
     * ```
     *
     * @param filter - A filter to select the documents to find. If not provided, all documents will be returned.
     * @param options - The options for this operation.
     *
     * @returns A document matching the criterion, or `null` if no such document exists.
     *
     * @see CollectionFilter
     * @see CollectionFindOneOptions
     */
    findOne<TRaw extends SomeDoc = WithSim<RSchema>>(filter: CollectionFilter<WSchema>, options?: CollectionFindOneOptions): Promise<TRaw | null>;
    /**
     * ##### Overview
     *
     * Return a list of the unique values of `key` across the documents in the collection that match the provided filter.
     *
     * See {@link CollectionFilter} and {@link CollectionDistinctOptions} as well for more information.
     *
     * @example
     * ```ts
     * const docs = await collection.distinct('name');
     * ```
     *
     * ---
     *
     * ##### Major disclaimer 🚨
     *
     * > **🚨Important:** This is a **client-side operation**.
     * >
     * > This method browses all matching documents (albeit with a projection) using the logic of the {@link Collection.find} method, and collects the unique value for the given `key` manually.
     * >
     * > As such, there may be performance, latency, and ultimately billing implications if the amount of matching documents is large.
     * >
     * > Therefore, it is **heavily recommended** to only use this method on **small datasets**, or a **strict filter**.
     *
     * ---
     *
     * ##### Usage
     *
     * The key may use dot-notation to access nested fields, such as `'field'`, `'field.subfield'`, `'field.3'`, `'field.3.subfield'`, etc. If lists are encountered and no numeric index is specified, all items in the list are pulled.
     *
     * > **✏️Note:** On complex extractions, the return type may be not as expected.** In that case, it's on the user to cast the return type to the correct one.
     *
     * Distinct works with arbitrary objects as well, by stable-y stringifying the object and comparing it with the string representations of the objects already seen.
     * - This, unsurprisingly, may not be great for performance if you have a lot of records that match, so it's **recommended to use distinct on simple values** whenever performance or number of records is a concern.
     *
     * For details on the behavior of "distinct" in conjunction with real-time changes in the collection contents, see the remarks on the `find` command.
     *
     * @example
     * ```typescript
     * await collection.insertMany([
     *   { letter: { value: 'a' }, car: [1] },
     *   { letter: { value: 'b' }, car: [2, 3] },
     *   { letter: { value: 'a' }, car: [2], bus: 'no' },
     * ]);
     *
     * // ['a', 'b']
     * const distinct = await collection.distinct('letter.value');
     *
     * await collection.insertOne({
     *   x: [{ y: 'Y', 0: 'ZERO' }],
     * });
     *
     * // ['Y']
     * await collection.distinct('x.y');
     *
     * // [{ y: 'Y', 0: 'ZERO' }]
     * await collection.distinct('x.0');
     *
     * // ['Y']
     * await collection.distinct('x.0.y');
     *
     * // ['ZERO']
     * await collection.distinct('x.0.0');
     * ```
     *
     * @param key - The dot-notation key to pick which values to retrieve unique
     * @param filter - A filter to select the documents to find. If not provided, all documents will be matched.
     * @param options - The options for this operation.
     *
     * @returns A list of all the unique values selected by the given `key`
     *
     * @see CollectionFilter
     * @see CollectionDistinctOptions
     */
    distinct<Key extends string>(key: Key, filter: CollectionFilter<WSchema>, options?: CollectionDistinctOptions): Promise<Flatten<(SomeDoc & ToDotNotation<RSchema>)[Key]>[]>;
    /**
     * ##### Overview
     *
     * Counts the number of documents in the collection, optionally with a filter.
     *
     * See {@link CollectionFilter} and {@link CollectionCountDocumentsOptions} as well for more information.
     *
     * @example
     * ```ts
     * const count = await collection.countDocuments({ name: 'John Doe' }, 1000);
     * ```
     *
     * ---
     *
     * ##### The `limit` parameter 🚨
     *
     * > **🚨Important:** This operation takes in a `limit` option which dictates the maximum number of documents that may be present before a {@link TooManyDocumentsToCountError} is thrown.
     * >
     * > If the limit is higher than the highest limit accepted by the Data API (i.e. `1000`), a {@link TooManyDocumentsToCountError} will be thrown anyway.
     *
     * @example
     * ```typescript
     * await collection.insertMany([
     *   { name: 'John Doe' },
     *   { name: 'Jane Doe' },
     * ]);
     *
     * const count = await collection.countDocuments({}, 1000);
     * console.log(count); // 1
     *
     * // Will throw a TooManyDocumentsToCountError as it counts 2, but the limit is 1
     * const count = await collection.countDocuments({}, 1);
     * ```
     *
     * @remarks
     * Count operations are expensive: for this reason, the best practice is to provide a reasonable `upperBound`
     * according to the caller expectations. Moreover, indiscriminate usage of count operations for sizeable amounts
     * of documents (i.e. in the thousands and more) is discouraged in favor of alternative application-specific
     * solutions. Keep in mind that the Data API has a hard upper limit on the amount of documents it will count,
     * and that an exception will be thrown by this method if this limit is encountered.
     *
     * @param filter - A filter to select the documents to count. If not provided, all documents will be counted.
     * @param upperBound - The maximum number of documents to count.
     * @param options - The options for this operation.
     *
     * @returns The number of counted documents, if below the provided limit
     *
     * @throws TooManyDocumentsToCountError - If the number of documents counted exceeds the provided limit.
     *
     * @see CollectionFilter
     * @see CollectionCountDocumentsOptions
     */
    countDocuments(filter: CollectionFilter<WSchema>, upperBound: number, options?: CollectionCountDocumentsOptions): Promise<number>;
    /**
     * ##### Overview
     *
     * Gets an estimate of the count of documents in a collection.
     *
     * This gives a very rough estimate of the number of documents in the collection. It is not guaranteed to be
     * accurate, and should not be used as a source of truth for the number of documents in the collection.
     *
     * However, this operation is faster than {@link Collection.countDocuments}, and while it doesn't
     * accept a filter, **it can handle any number of documents.**
     *
     * See {@link CollectionEstimatedDocumentCountOptions} as well for more information.
     *
     * @example
     * ```ts
     * const count = await collection.estimatedDocumentCount();
     * console.log(count); // Hard to predict exact number
     * ```
     *
     * @param options - The options for this operation.
     *
     * @returns The estimated number of documents in the collection
     *
     * @see CollectionEstimatedDocumentCountOptions
     */
    estimatedDocumentCount(options?: CollectionEstimatedDocumentCountOptions): Promise<number>;
    /**
     * ##### Overview
     *
     * Atomically finds a single document in the collection and replaces it.
     *
     * See {@link CollectionFilter} and {@link CollectionFindOneAndReplaceOptions} as well for more information.
     *
     * @example
     * ```typescript
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     * await collection.findOneAndReplace({ _id: '1' }, { name: 'Dohn Joe' });
     * ```
     *
     * ---
     *
     * ##### Projection
     *
     * > **🚨Important:** When projecting, it is _heavily_ recommended to provide an explicit type override representing the projected schema, to prevent any type-mismatches when the schema is strictly provided.
     * >
     * > Otherwise, the returned document will be typed as the full `Schema`, which may lead to runtime errors when trying to access properties that are not present in the projected document.
     *
     * > **💡Tip:** Use the {@link Pick} or {@link Omit} utility types to create a type representing the projected schema.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe', age: 3 });
     *
     * const doc = await collection.findOneAndReplace<{ name: string }>(
     *   { _id: '1' },
     *   { name: 'Dohn Joe' },
     *   { projection: { name: 1, _id: 0 } },
     * );
     *
     * // Prints { name: 'John Doe' }
     * console.log(doc);
     * ```
     *
     * ---
     *
     * ##### Upserting
     *
     * If `upsert` is set to true, it will insert the document reconstructed from the filter & the update filter if no match is found.
     *
     * @example
     * ```ts
     * const resp = await collection.findOneAndReplace(
     *   { _id: 42 },
     *   { name: 'Jessica' },
     *   { upsert: true },
     * );
     *
     * console.log(resp); // null, b/c no previous document was found
     * ```
     *
     * ---
     *
     * ##### `returnDocument`
     *
     * `returnDocument` (default `'before'`) controls whether the original or the updated document is returned.
     * - `'before'`: Returns the document as it was before the update, or `null` if the document was upserted.
     * - `'after'`: Returns the document as it is after the update.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     *
     * const after = await collection.findOneAndReplace(
     *   { _id: '1' },
     *   { name: 'Jane Doe' },
     *   { returnDocument: 'after' },
     * );
     *
     * // Prints { _id: '1', name: 'Jane Doe' }
     * console.log(after);
     * ```
     *
     * ---
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * > **⚠️Warning:** If the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * ---
     *
     * ##### Find one and replace by vector search
     *
     * If the collection has vector search enabled, you can replace the most relevant document by providing a vector in the sort option.
     *
     * See {@link Collection.replaceOne} for a concrete example.
     *
     * @param filter - A filter to select the document to find.
     * @param replacement - The replacement document, which contains no `_id` field.
     * @param options - The options for this operation.
     *
     * @returns The document before/after replacement, depending on the type of `returnDocument`
     *
     * @see CollectionFilter
     * @see CollectionFindOneAndReplaceOptions
     */
    findOneAndReplace<TRaw extends SomeDoc = RSchema>(filter: CollectionFilter<WSchema>, replacement: NoId<WSchema>, options?: CollectionFindOneAndReplaceOptions): Promise<TRaw | null>;
    /**
     * ##### Overview
     *
     * Atomically finds a single document in the collection and deletes it.
     *
     * See {@link CollectionFilter} and {@link CollectionFindOneAndDeleteOptions} as well for more information.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     * await collection.findOneAndDelete({ _id: '1' });
     * ```
     *
     * ---
     *
     * ##### Projection
     *
     * > **🚨Important:** When projecting, it is _heavily_ recommended to provide an explicit type override representing the projected schema, to prevent any type-mismatches when the schema is strictly provided.
     * >
     * > Otherwise, the returned document will be typed as the full `Schema`, which may lead to runtime errors when trying to access properties that are not present in the projected document.
     *
     * > **💡Tip:** Use the {@link Pick} or {@link Omit} utility types to create a type representing the projected schema.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe', age: 3 });
     *
     * const doc = await collection.findOneAndDelete<{ name: string }>(
     *   { _id: '1' },
     *   { projection: { name: 1, _id: 0 } },
     * );
     *
     * // Prints { name: 'John Doe' }
     * console.log(doc);
     * ```
     *
     * ---
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * > **⚠️Warning:** If the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * ---
     *
     * ##### Find one and delete by vector search
     *
     * If the collection has vector search enabled, you can delete the most relevant document by providing a vector in the sort option.
     *
     * See {@link Collection.deleteOne} for a concrete example.
     *
     * @param filter - A filter to select the document to find.
     * @param options - The options for this operation.
     *
     * @returns The deleted document, or `null` if no document was found.
     *
     * @see CollectionFilter
     * @see CollectionFindOneAndDeleteOptions
     */
    findOneAndDelete<TRaw extends SomeDoc = RSchema>(filter: CollectionFilter<WSchema>, options?: CollectionFindOneAndDeleteOptions): Promise<TRaw | null>;
    /**
     * ##### Overview
     *
     * Atomically finds a single document in the collection and updates it.
     *
     * See {@link CollectionFilter} and {@link CollectionFindOneAndUpdateOptions} as well for more information.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     * await collection.findOneAndUpdate({ _id: '1' }, { $set: { name: 'Jane Doe' } });
     * ```
     *
     * ---
     *
     * ##### Projection
     *
     * > **🚨Important:** When projecting, it is _heavily_ recommended to provide an explicit type override representing the projected schema, to prevent any type-mismatches when the schema is strictly provided.
     * >
     * > Otherwise, the returned document will be typed as the full `Schema`, which may lead to runtime errors when trying to access properties that are not present in the projected document.
     *
     * > **💡Tip:** Use the {@link Pick} or {@link Omit} utility types to create a type representing the projected schema.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe', age: 3 });
     *
     * const doc = await collection.findOneAndUpdate<{ name: string }>(
     *   { _id: '1' },
     *   { $set: { name: 'Jane Doe' } },
     *   { projection: { name: 1, _id: 0 } },
     * );
     *
     * // Prints { name: 'John Doe' }
     * console.log(doc);
     * ```
     *
     * ---
     *
     * ##### Upserting
     *
     * If `upsert` is set to true, it will insert the document reconstructed from the filter & the update filter if no match is found.
     *
     * @example
     * ```ts
     * const resp = await collection.findOneAndUpdate(
     *   { _id: 42 },
     *   { $set: { name: 'Jessica' } },
     *   { upsert: true },
     * );
     *
     * console.log(resp); // null, b/c no previous document was found
     * ```
     *
     * ---
     *
     * ##### `returnDocument`
     *
     * `returnDocument` (default `'before'`) controls whether the original or the updated document is returned.
     * - `'before'`: Returns the document as it was before the update, or `null` if the document was upserted.
     * - `'after'`: Returns the document as it is after the update.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     *
     * const after = await collection.findOneAndUpdate(
     *   { _id: '1' },
     *   { $set: { name: 'Jane Doe' } },
     *   { returnDocument: 'after' },
     * );
     *
     * // Prints { _id: '1', name: 'Jane Doe' }
     * console.log(after);
     * ```
     *
     * ---
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * > **⚠️Warning:** If the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * ---
     *
     * ##### Find one and update by vector search
     *
     * If the collection has vector search enabled, you can update the most relevant document by providing a vector in the sort option.
     *
     * See {@link Collection.updateOne} for a concrete example.
     *
     * @param filter - A filter to select the document to find.
     * @param update - The update to apply to the selected document.
     * @param options - The options for this operation.
     *
     * @returns The document before/after the update, depending on the type of `returnDocument`
     */
    findOneAndUpdate(filter: CollectionFilter<WSchema>, update: CollectionUpdateFilter<WSchema>, options?: CollectionFindOneAndUpdateOptions): Promise<RSchema | null>;
    /**
     * ##### Overview
     *
     * Get the collection options, i.e. its configuration as read from the database.
     *
     * The method issues a request to the Data API each time it is invoked, without caching mechanisms; this ensures up-to-date information for usages such as real-time collection validation by the application.
     *
     * @example
     * ```ts
     * const options = await collection.info();
     * console.log(options.vector);
     * ```
     *
     * @param options - The options for this operation.
     *
     * @returns The options that the collection was created with (i.e. the `vector` and `indexing` operations).
     */
    options(options?: WithTimeout<'collectionAdminTimeoutMs'>): Promise<CollectionDefinition<SomeDoc>>;
    /**
     * ##### Overview
     *
     * Drops the collection from the database, including all the documents it contains.
     *
     * @example
     * ```typescript
     * const collection = await db.collection('my_collection');
     * await collection.drop();
     * ```
     *
     * ---
     *
     * ##### Disclaimer 🚨
     *
     * > **🚨Important**: Once the collection is dropped, this object is still technically "usable", but any further operations on it will fail at the Data API level; thus, it's the user's responsibility to make sure that the {@link Collection} object is no longer used.
     *
     * @param options - The options for this operation.
     *
     * @returns A promise which resolves when the collection has been dropped.
     *
     * @remarks Use with caution. Wear your safety goggles. Don't say I didn't warn you.
     */
    drop(options?: Omit<DropCollectionOptions, keyof WithKeyspace>): Promise<void>;
    /**
     * Backdoor to the HTTP client for if it's absolutely necessary. Which it almost never (if even ever) is.
     */
    get _httpClient(): OpaqueHttpClient;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - `bulkWrite` has been removed until it is supported on the server side by the Data API. Please manually perform equivalent collection operations to attain the same behavior.
     */
    bulkWrite: 'ERROR: `bulkWrite` has been removed; manually perform collection operations to retain the same behavior';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - `deleteAll` has been removed to retain Data API consistency. Use `deleteMany({})` instead to retain the same behavior.
     */
    deleteAll: 'ERROR: `deleteAll` has been removed; use `deleteMany({})` instead';
}

/**
 * Represents filter operations exclusive to array (or dynamically typed) fields
 *
 * @public
 */
export declare interface CollectionArrayFilterOps<Elem> {
    /**
     * Checks if the array is of a certain size.
     */
    $size?: number;
    /**
     * Checks if the array contains all the specified elements.
     */
    $all?: Elem;
}

/**
 * Types some array operations. Not inherently strict or weak.
 *
 * @public
 */
export declare type CollectionArrayUpdate<Schema> = {
    [K in keyof Schema as any[] extends Schema[K] ? K : never]?: PickArrayTypes<Schema[K]>;
};

/**
 * @public
 */
export declare type CollectionCodec<Class extends CollectionCodecClass> = InstanceType<Class>;

/**
 * @public
 */
export declare type CollectionCodecClass = (abstract new (...args: any[]) => {
    [$SerializeForCollection]: (ctx: CollectionSerCtx) => ReturnType<SerDesFn<any>>;
}) & {
    [$DeserializeForCollection]: SerDesFn<CollectionDesCtx>;
};

/**
 * @beta
 */
export declare class CollectionCodecs {
    static Defaults: {
        $date: RawCollCodecs;
        $vector: RawCollCodecs;
        $uuid: RawCollCodecs;
        $objectId: RawCollCodecs;
    };
    static forId(clazz: CollectionCodecClass): RawCollCodecs;
    static forName(name: string, optsOrClass: CollNominalCodecOpts | CollectionCodecClass): RawCollCodecs;
    /**
     * @deprecated
     */
    static forPath(path: readonly PathSegment[], optsOrClass: CollNominalCodecOpts | CollectionCodecClass): RawCollCodecs;
    static forType(type: string, optsOrClass: CollTypeCodecOpts | CollectionCodecClass): RawCollCodecs;
    static custom(opts: CollCustomCodecOpts): RawCollCodecs;
    static asCodecClass<Class extends SomeConstructor>(clazz: Class, fns?: AsCollectionCodecClassFns<Class>): CollectionCodecClass;
}

export declare type CollectionCountDocumentsOptions = GenericCountOptions;

/**
 * Types the $currentDate operation. Not inherently strict or weak.
 *
 * @public
 */
export declare type CollectionCurrentDate<Schema> = {
    [K in keyof Schema as Schema[K] extends Date | {
        $date: number;
    } ? K : never]?: boolean;
};

/**
 * Weaker version of StrictDateUpdate which allows for more flexibility in typing date update operations.
 *
 * @public
 */
export declare type CollectionDateUpdate<Schema> = {
    [K in keyof Schema as ContainsDate<Schema[K]> extends true ? K : never]?: Date | {
        $date: number;
    };
};

/**
 * Represents the options for the default ID.
 *
 * **If `type` is not specified, the default ID will be a string UUID.**
 *
 * @field type - The type of the default ID.
 *
 * @public
 */
export declare interface CollectionDefaultIdOptions {
    /**
     * The type of the default ID that the API should generate if no ID is provided in the inserted document.
     *
     * **If not specified, the default ID will be a string UUID.**
     *
     * | Type       | Description    | Example                                            |
     * |------------|----------------|----------------------------------------------------|
     * | `uuid`     | A UUID v4.     | `new UUID('f47ac10b-58cc-4372-a567-0e02b2c3d479')` |
     * | `uuidv6`   | A UUID v6.     | `new UUID('6f752f1a-6b6d-4f3e-8e1e-2e167e3b5f3d')` |
     * | `uuidv7`   | A UUID v7.     | `new UUID('018e75ff-a07b-7b08-bb91-aa566c5abaa6')` |
     * | `objectId` | An ObjectID.   | `new ObjectId('507f1f77bcf86cd799439011')`         |
     * | unset      | A string UUID. | `'f47ac10b-58cc-4372-a567-0e02b2c3d479'`           |
     *
     * @example
     * ```typescript
     * const collections = await db.createCollection('my-collections');
     *
     * // { name: 'Jessica', _id: 'f47ac10b-58cc-4372-a567-0e02b2c3d479' }
     * await collections.insertOne({ name: 'Jessica' });
     *```
     *
     * @example
     * ```typescript
     * const collections = await db.createCollection('my-collections', {
     *   defaultId: { type: 'uuidv6' },
     * });
     *
     * // { name: 'Allman', _id: UUID('6f752f1a-6b6d-6f3e-8e1e-2e167e3b5f3d') }
     * await collections.insertOne({ name: 'Allman' });
     * ```
     *
     * @example
     * ```typescript
     * const collections = await db.createCollection('my-collections', {
     *   defaultId: { type: 'objectId' },
     * });
     *
     * // { name: 'Brothers', _id: ObjectId('507f1f77bcf86cd799439011') }
     * await collections.insertOne({ name: 'Brothers' });
     * ```
     *
     * @remarks Make sure you're keeping this all in mind if you're specifically typing your _id field.
     */
    type: 'uuid' | 'uuidv6' | 'uuidv7' | 'objectId';
}

/**
 * Represents the options for the createCollection command.
 *
 * @field vector - Options related to vector search.
 * @field indexing - Options related to indexing.
 * @field defaultId - Options related to the default ID.
 *
 * @public
 */
export declare interface CollectionDefinition<Schema extends SomeDoc> {
    /**
     * Options related to vector search.
     */
    vector?: CollectionVectorOptions;
    /**
     * Options related to indexing.
     */
    indexing?: CollectionIndexingOptions<Schema>;
    /**
     * Options related to the default ID.
     */
    defaultId?: CollectionDefaultIdOptions;
    /**
     * Options related to lexical (bm25) search.
     */
    lexical?: CollectionLexicalOptions;
    /**
     * Options related to reranking.
     */
    rerank?: CollectionRerankOptions;
}

/**
 * ##### Overview
 *
 * Represents an error that occurred during a `deleteMany` operation (which is, generally, paginated).
 *
 * Contains the number of documents that were successfully deleted, as well as the cumulative errors that occurred
 * during the operation.
 *
 * @example
 * ```ts
 * try {
 *   await collection.deleteMany({ age: 30 });
 * } catch (e) {
 *   if (e instanceof CollectionDeleteManyError) {
 *     console.log(e.cause);
 *     console.log(e.partialResult);
 *   }
 * }
 * ```
 *
 * @see Collection.deleteMany
 *
 * @public
 */
export declare class CollectionDeleteManyError extends DataAPIError {
    /**
     * The name of the error. This is always 'DeleteManyError'.
     */
    name: string;
    /**
     * The partial result of the `DeleteMany` operation that was performed. This is *always* defined, and is the result
     * of the operation up to the point of the first error.
     */
    readonly partialResult: CollectionDeleteManyResult;
    /**
     * The error that caused the operation to fail.
     */
    readonly cause: Error;
    /* Excluded from this release type: __constructor */
}

export declare type CollectionDeleteManyOptions = GenericDeleteManyOptions;

/**
 * Represents the result of a delete command.
 *
 * @field deletedCount - The number of deleted documents. Can be any non-negative integer.
 *
 * @see Collection.deleteMany
 *
 * @public
 */
export declare type CollectionDeleteManyResult = GenericDeleteManyResult;

/**
 * Represents the options for the deleteOne command.
 *
 * @field sort - The sort order to pick which document to delete if the filter selects multiple documents.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.deleteOne
 *
 * @public
 */
export declare type CollectionDeleteOneOptions = GenericDeleteOneOptions;

/**
 * Represents the result of a delete command.
 *
 * @field deletedCount - The number of deleted documents. Can be either 0 or 1.
 *
 * @see Collection.deleteOne
 *
 * @public
 */
export declare interface CollectionDeleteOneResult {
    /**
     * The number of deleted documents.
     */
    deletedCount: 0 | 1;
}

/**
 * Information about a collection, used when `nameOnly` is false in {@link ListCollectionsOptions}.
 *
 * @field name - The name of the collections.
 * @field options - The creation options for the collections.
 *
 * @see ListCollectionsOptions
 * @see Db.listCollections
 *
 * @public
 */
export declare interface CollectionDescriptor {
    /**
     * The name of the collections.
     */
    name: string;
    /**
     * The creation options for the collections (i.e. the `vector`, `indexing`, and `defaultId` fields).
     */
    definition: CollectionDefinition<SomeDoc>;
}

/**
 * @beta
 */
export declare interface CollectionDesCtx extends BaseDesCtx<CollectionDesCtx> {
    getNumCoercionForPath?: CollNumCoercionFn;
}

export declare type CollectionDistinctOptions = GenericDistinctOptions;

export declare type CollectionEstimatedDocumentCountOptions = GenericEstimatedCountOptions;

/**
 * Represents some filter operation for a given document schema.
 *
 * @example
 * ```typescript
 * interface BasicSchema {
 *   arr: string[],
 *   num: number,
 * }
 *
 * db.collections<BasicSchema>('coll_name').findOne({
 *   $and: [
 *     { _id: { $in: ['abc', 'def'] } },
 *     { $not: { arr: { $size: 0 } } },
 *   ],
 * });
 * ```
 *
 * @public
 */
export declare type CollectionFilter<Schema extends SomeDoc> = {
    [K in keyof ToDotNotation<NoId<Schema>>]?: CollectionFilterExpr<ToDotNotation<NoId<Schema>>[K]>;
} & {
    _id?: CollectionFilterExpr<IdOf<Schema>>;
    $and?: CollectionFilter<Schema>[];
    $or?: CollectionFilter<Schema>[];
    $not?: CollectionFilter<Schema>;
    [key: string]: any;
};

/**
 * Represents an expression in a filter statement, such as an exact value, or a filter operator
 *
 * @public
 */
export declare type CollectionFilterExpr<Elem> = Elem | (CollectionFilterOps<Elem> & Record<string, any>);

/**
 * Represents filter operators such as `$eq` and `$in` (but not statements like `$and`)
 *
 * @public
 */
export declare type CollectionFilterOps<Elem> = {
    $eq?: Elem;
    $ne?: Elem;
    $in?: Elem[];
    $nin?: Elem[];
    $exists?: boolean;
    $lt?: Elem;
    $lte?: Elem;
    $gt?: Elem;
    $gte?: Elem;
} & (any[] extends Elem ? CollectionArrayFilterOps<Elem> : EmptyObj);

/**
 * ##### Overview (preview)
 *
 * A lazy iterator over the results of a `findAndRerank` operation on a {@link Collection}.
 *
 * > **⚠️Warning**: Shouldn't be directly instantiated, but rather spawned via {@link Collection.findAndRerank}.
 *
 * ---
 *
 * ##### Typing
 *
 * > **🚨Important:** For most intents and purposes, you may treat the cursor as if it is typed simply as `Cursor<T>`.
 * >
 * > If you're using a projection, it is heavily recommended to provide an explicit type representing the type of the document after projection.
 *
 * In full, the cursor is typed as `CollectionFindAndRerankCursor<T, TRaw>`, where
 * - `T` is the type of the mapped records, and
 * - `TRaw` is the type of the raw records before any mapping.
 *
 * If no mapping function is provided, `T` and `TRaw` will be the same type. Mapping is done using the {@link CollectionFindAndRerankCursor.map} method.
 *
 * ---
 *
 * ##### Options
 *
 * Options may be set either through the `findAndRerank({}, options)` method, or through the various fluent **builder
 * methods**, which, *unlike Mongo*, **do not mutate the existing cursor**, but rather return a new, uninitialized cursor
 * with the new option(s) set.
 *
 * @example
 * ```typescript
 * const collection = db.collection('hybrid_coll');
 *
 * const cursor: Cursor<Person> = collection.findAndRerank({}, {
 *   sort: { $hybrid: 'what is a car?' },
 *   includeScores: true,
 * });
 *
 * for await (const res of cursor) {
 *   console.log(res.document);
 *   console.log(res.scores);
 * }
 * ```
 *
 * @see Collection.findAndRerank
 * @see FindAndRerankCursor
 *
 * @public
 */
export declare class CollectionFindAndRerankCursor<T, TRaw extends SomeDoc = SomeDoc> extends FindAndRerankCursor<T, TRaw> {
    /**
     * ##### Overview
     *
     * Returns the {@link Collection} which spawned this cursor.
     *
     * @example
     * ```ts
     * const coll = db.collection(...);
     * const cursor = coll.findAndRerank(...);
     * cursor.dataSource === coll; // true
     * ```
     */
    get dataSource(): Collection;
    /**
     * ##### Overview
     *
     * Sets the filter for the cursor, overwriting any previous filter.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new filter set.*
     *
     * @example
     * ```ts
     * await table.insertOne({ name: 'John', ... });
     *
     * const cursor = table.findAndRerank({})
     *   .sort({ $hybrid: 'big burly man' })
     *   .filter({ name: 'John' });
     *
     * // The cursor will only return records with the name 'John'
     * const john = await cursor.next();
     * john.name === 'John'; // true
     * ```
     *
     * @param filter - A filter to select which records to return.
     *
     * @returns A new cursor with the new filter set.
     */
    filter(filter: CollectionFilter<TRaw>): this;
    project: <RRaw extends SomeDoc = Partial<TRaw>>(projection: Projection) => CollectionFindAndRerankCursor<RerankedResult<RRaw>, RRaw>;
    map: <R>(map: (doc: T) => R) => CollectionFindAndRerankCursor<R, TRaw>;
}

/**
 * Options for the collection `findAndRerank` method.
 *
 * @see Collection.findAndRerank
 *
 * @public
 */
export declare type CollectionFindAndRerankOptions = GenericFindAndRerankOptions;

/**
 * ##### Overview
 *
 * A lazy iterator over the results of a `find` operation on a {@link Collection}.
 *
 * > **⚠️Warning**: Shouldn't be directly instantiated, but rather spawned via {@link Collection.find}.
 *
 * ---
 *
 * ##### Typing
 *
 * > **🚨Important:** For most intents and purposes, you may treat the cursor as if it is typed simply as `Cursor<T>`.
 * >
 * > If you're using a projection, it is heavily recommended to provide an explicit type representing the type of the document after projection.
 *
 * In full, the cursor is typed as `CollectionFindCursor<T, TRaw>`, where
 * - `T` is the type of the mapped records, and
 * - `TRaw` is the type of the raw records before any mapping.
 *
 * If no mapping function is provided, `T` and `TRaw` will be the same type. Mapping is done using the {@link CollectionFindCursor.map} method.
 *
 * ---
 *
 * ##### Options
 *
 * Options may be set either through the `find({}, options)` method, or through the various fluent **builder
 * methods**, which, *unlike Mongo*, **do not mutate the existing cursor**, but rather return a new, uninitialized cursor
 * with the new option(s) set.
 *
 * @example
 * ```typescript
 * interface Person {
 *   firstName: string,
 *   lastName: string,
 *   age: number,
 * }
 *
 * const collection = db.collection<Person>('people');
 * const cursor1: Cursor<Person> = collection.find({ firstName: 'John' });
 *
 * // Lazily iterate all documents matching the filter
 * for await (const doc of cursor1) {
 *   console.log(doc);
 * }
 *
 * // Rewind the cursor to be able to iterate again
 * cursor1.rewind();
 *
 * // Get all documents matching the filter as an array
 * const docs = await cursor1.toArray();
 *
 * // Immutably set options & map as needed (changing options returns a new, uninitialized cursor)
 * const cursor2: Cursor<string> = cursor
 *   .project<Omit<Person, 'age'>>({ age: 0 })
 *   .map(doc => doc.firstName + ' ' + doc.lastName);
 *
 * // Get next document from cursor
 * const doc = await cursor2.next();
 * ```
 *
 * @see Collection.find
 * @see FindCursor
 *
 * @public
 */
export declare class CollectionFindCursor<T, TRaw extends SomeDoc = SomeDoc> extends FindCursor<T, TRaw> {
    /**
     * ##### Overview
     *
     * Returns the {@link Collection} which spawned this cursor.
     *
     * @example
     * ```ts
     * const coll = db.collection(...);
     * const cursor = coll.find({});
     * cursor.dataSource === coll; // true
     * ```
     */
    get dataSource(): Collection;
    /**
     * ##### Overview
     *
     * Sets the filter for the cursor, overwriting any previous filter.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new filter set.*
     *
     * @example
     * ```ts
     * await collection.insertOne({ name: 'John', ... });
     *
     * const cursor = collection.find({})
     *   .filter({ name: 'John' });
     *
     * // The cursor will only return records with the name 'John'
     * const john = await cursor.next();
     * john.name === 'John'; // true
     * ```
     *
     * @param filter - A filter to select which records to return.
     *
     * @returns A new cursor with the new filter set.
     */
    filter(filter: CollectionFilter<TRaw>): this;
    project: <RRaw extends SomeDoc = Partial<TRaw>>(projection: Projection) => CollectionFindCursor<RRaw, RRaw>;
    includeSimilarity: (includeSimilarity?: boolean) => CollectionFindCursor<WithSim<TRaw>, WithSim<TRaw>>;
    map: <R>(map: (doc: T) => R) => CollectionFindCursor<R, TRaw>;
}

/**
 * Represents the options for the `findOneAndDelete` command.
 *
 * @field sort - The sort order to pick which document to delete if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.findOneAndDelete
 *
 * @public
 */
export declare type CollectionFindOneAndDeleteOptions = GenericFindOneAndDeleteOptions;

/**
 * Represents the options for the `findOneAndReplace` command.
 *
 * @field returnDocument - Specifies whether to return the original or updated document.
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field sort - The sort order to pick which document to replace if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.findOneAndReplace
 *
 * @public
 */
export declare type CollectionFindOneAndReplaceOptions = GenericFindOneAndReplaceOptions;

/**
 * Represents the options for the `findOneAndUpdate` command.
 *
 * @field returnDocument - Specifies whether to return the original or updated document.
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field sort - The sort order to pick which document to replace if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field includeResultMetadata - When true, returns alongside the document, an `ok` field with a value of 1 if the command executed successfully.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.findOneAndUpdate
 *
 * @public
 */
export declare type CollectionFindOneAndUpdateOptions = GenericFindOneAndUpdateOptions;

/**
 * Represents the options for the collection `findOne` command.
 *
 * @field sort - The sort order to pick which document to return if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field includeSimilarity - If true, include the similarity score in the result via the `$similarity` field.
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare type CollectionFindOneOptions = GenericFindOneOptions;

/**
 * Options for the collection `find` method.
 *
 * @field sort - The sort order to pick which document to return if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field limit - Max number of documents to return in the lifetime of the cursor.
 * @field skip - Number of documents to skip if using a sort.
 * @field includeSimilarity - If true, include the similarity score in the result via the `$similarity` field.
 *
 * @see Collection.find
 *
 * @public
 */
export declare type CollectionFindOptions = GenericFindOptions;

/**
 * Represents the options for the indexing.
 *
 * **Only one of `allow` or `deny` can be specified.**
 *
 * See [indexing](https://docs.datastax.com/en/astra/astra-db-vector/api-reference/data-api-commands.html#advanced-feature-indexing-clause-on-createcollection) for more details.
 *
 * @example
 * ```typescript
 * const collection1 = await db.createCollection('my-collections', {
 *   indexing: {
 *     allow: ['name', 'age'],
 *   },
 * });
 *
 * const collection2 = await db.createCollection('my-collections', {
 *   indexing: {
 *     deny: ['*'],
 *   },
 * });
 * ```
 *
 * @field allow - The fields to index.
 * @field deny - The fields to not index.
 *
 * @public
 */
export declare type CollectionIndexingOptions<Schema extends SomeDoc> = {
    allow: (keyof ToDotNotation<Schema> | string)[] | ['*'];
    deny?: never;
} | {
    deny: (keyof ToDotNotation<Schema> | string)[] | ['*'];
    allow?: never;
};

/**
 * ##### Overview
 *
 * Represents an error that occurred during a (potentially paginated) `insertMany` operation on a {@link Collection}.
 *
 * Contains the inserted IDs of the documents that were successfully inserted, as well as the cumulative errors
 * that occurred during the operation.
 *
 * If the operation was ordered, the `insertedIds` will be in the same order as the documents that were attempted to
 * be inserted.
 *
 * @example
 * ```ts
 * try {
 *   await collection.insertMany([
 *     { _id: 'id1', desc: 'An innocent little document' },
 *     { _id: 'id2', desc: 'Another little document minding its own business' },
 *     { _id: 'id2', desc: 'A mean document commiting _identity theft' },
 *     { _id: 'id3', desc: 'A document that will never see the light of day-tabase' },
 *   ], { ordered: true });
 * } catch (e) {
 *   if (e instanceof CollectionInsertManyError) {
 *     console.log(e.message); // "Document already exists with the given _id"
 *     console.log(e.insertedIds()); // ['id1', 'id2']
 *     console.log(e.errors()); // [DataAPIResponseError(...)]
 *   }
 * }
 * ```
 *
 * ---
 *
 * ##### Collections vs Tables
 *
 * There is a sister {@link TableInsertManyError} class that is used for `insertMany` operations on tables. It's identical in structure, but uses the appropriate {@link SomeRow} type for the IDs.
 *
 * @see Collection.insertMany
 * @see TableInsertManyError
 *
 * @public
 */
export declare class CollectionInsertManyError extends DataAPIError {    /**
     * The name of the error. This is always 'InsertManyError'.
     */
    name: string;
    /* Excluded from this release type: __constructor */
    insertedIds(): SomeId[];
    errors(): Error[];
}

/**
 * ##### Overview
 *
 * The options for an `insertMany` command on a collection.
 *
 * > **🚨Important:** The options depend on the `ordered` parameter. If `ordered` is `true`, then the `concurrency` option is not allowed.
 *
 * @example
 * ```ts
 * const result = await collection.insertMany([
 *   { name: 'John', age: 30 },
 *   { name: 'Jane', age: 25 },
 * ], {
 *   ordered: true,
 *   timeout: 60000,
 * });
 * ```
 *
 * @example
 * ```ts
 * const result = await collection.insertMany([
 *   { name: 'John', age: 30 },
 *   { name: 'Jane', age: 25 },
 * ], {
 *   concurrency: 16, // ordered implicitly `false` if unset
 * });
 * ```
 *
 * ---
 *
 * ##### Datatypes
 *
 * See {@link Collection}'s documentation for information on the available datatypes for collections.
 *
 * @see Collection.insertMany
 * @see CollectionInsertManyResult
 *
 * @public
 */
export declare type CollectionInsertManyOptions = GenericInsertManyOptions;

/**
 * ##### Overview
 *
 * Represents the result of an `insertMany` command on a {@link Collection}.
 *
 * @example
 * ```ts
 * try {
 *   const result = await collection.insertMany([
 *     { name: 'John', age: 30 },
 *     { name: 'Jane', age: 25 },
 *   ]);
 *   console.log(result.insertedIds);
 * } catch (e) {
 *   if (e instanceof CollectionInsertManyError) {
 *     console.log(e.insertedIds())
 *     console.log(e.errors())
 *   }
 * }
 * ```
 *
 * ---
 *
 * ##### The `_id` fields
 *
 * The type of the `_id` fields are inferred from the {@link Collection}'s type, if it is present.
 *
 * > **⚠️Warning:** It is the user's responsibility to ensure that the ID type accommodates all possible variations—including auto-generated IDs and any user-provided ones.
 *
 * If the collection is "untyped", or no `_id` field is present in its type, then it will default to {@link SomeId}, which is a union type covering all possible types for a document ID.
 *
 * You may mitigate this concern on untyped collections by using a type such as `{ _id: string } & SomeDoc` which would allow the collection to remain generally untyped while still statically enforcing the `_id` type.
 *
 * > **💡Tip:** See the {@link SomeId} type for more information, and concrete examples, on this subject.
 *
 * ---
 *
 * ##### The default ID
 *
 * By default, if no `_id` fields are provided in any inserted document, it will be automatically generated and set as a string UUID (not an actual {@link UUID} type).
 *
 * You can modify this behavior by changing the {@link CollectionDefinition.defaultId} type when creating the collection; this allows it to generate a {@link UUID} or {@link ObjectId} instead of a string UUID.
 *
 * > **💡Tip:** See {@link SomeId} and {@link CollectionDefinition.defaultId} for more information, and concrete examples, on this subject.
 *
 * @see Collection.insertMany
 * @see CollectionInsertManyOptions
 *
 * @public
 */
export declare interface CollectionInsertManyResult<RSchema> {
    /**
     * The ID of the inserted documents. These may have been autogenerated if no `_id` was present in any of the inserted documents.
     *
     * See {@link CollectionInsertManyResult} for more information about the inserted id.
     */
    insertedIds: IdOf<RSchema>[];
    /**
     * The number of documents that were inserted into the collection.
     *
     * This is **always** equal to the length of the `insertedIds` array.
     */
    insertedCount: number;
}

/**
 * ##### Overview
 *
 * The options for an `insertOne` command on a {@link Collection}.
 *
 * @example
 * ```ts
 * const result = await collection.insertOne({
 *   name: 'John',
 *   age: 30,
 * }, {
 *   timeout: 10000,
 * });
 * ```
 *
 * ---
 *
 * ##### Datatypes
 *
 * See {@link Collection}'s documentation for information on the available datatypes for collections.
 *
 * @see Collection.insertOne
 * @see CollectionInsertOneResult
 *
 * @public
 */
export declare type CollectionInsertOneOptions = GenericInsertOneOptions;

/**
 * ##### Overview
 *
 * Represents the result of an `insertOne` command on a {@link Collection}.
 *
 * @example
 * ```ts
 * const result = await collection.insertOne({
 *   name: 'John',
 *   age: 30,
 * });
 *
 * console.log(result.insertedId);
 * ```
 *
 * ---
 *
 * ##### The `_id` field
 *
 * The type of the `_id` field is inferred from the {@link Collection}'s type, if it is present.
 *
 * > **⚠️Warning:** It is the user's responsibility to ensure that the ID type accommodates all possible variations—including auto-generated IDs and any user-provided ones.
 *
 * If the collection is "untyped", or no `_id` field is present in its type, then it will default to {@link SomeId}, which is a union type covering all possible types for a document ID.
 *
 * You may mitigate this concern on untyped collections by using a type such as `{ _id: string } & SomeDoc` which would allow the collection to remain generally untyped while still statically enforcing the `_id` type.
 *
 * > **💡Tip:** See the {@link SomeId} type for more information, and concrete examples, on this subject.
 *
 * ---
 *
 * ##### The default ID
 *
 * By default, if no `_id` field is provided in the inserted document, it will be automatically generated and set as a string UUID (not an actual {@link UUID} type).
 *
 * You can modify this behavior by changing the {@link CollectionDefinition.defaultId} type when creating the collection; this allows it to generate a {@link UUID} or {@link ObjectId} instead of a string UUID.
 *
 * > **💡Tip:** See {@link SomeId} and {@link CollectionDefinition.defaultId} for more information, and concrete examples, on this subject.
 *
 * @see Collection.insertOne
 * @see CollectionInsertOneOptions
 *
 * @public
 */
export declare interface CollectionInsertOneResult<RSchema> {
    /**
     * The ID of the inserted document. This may have been autogenerated if no `_id` was present in the inserted document.
     *
     * See {@link CollectionInsertOneResult} for more information about the inserted id.
     */
    insertedId: IdOf<RSchema>;
}

/**
 * @public
 */
export declare interface CollectionLexicalOptions {
    enabled: boolean;
    analyzer?: string | Record<string, unknown>;
}

/**
 * Weaker version of StrictNumberUpdate which allows for more flexibility in typing number update operations.
 *
 * @public
 */
export declare type CollectionNumberUpdate<Schema> = {
    [K in keyof Schema as IsNum<Schema[K]> extends true ? K : never]?: number | bigint;
};

/**
 * Options for spawning a new `Collection` instance through {@link db.collection} or {@link db.createCollection}.
 *
 * Note that these are not all the options available for when you're actually creating a table—see {@link CreateCollectionOptions} for that.
 *
 * @field embeddingApiKey - The embedding service's API-key/headers (for $vectorize)
 * @field timeoutDefaults - Default timeouts for all collection operations
 * @field logging - Logging configuration overrides
 * @field serdes - Additional serialization/deserialization configuration
 *
 * @public
 */
export declare interface CollectionOptions extends WithKeyspace {
    /**
     * The API key for the embedding service to use, or the {@link EmbeddingHeadersProvider} if using
     * a provider that requires it (e.g. AWS bedrock).
     */
    embeddingApiKey?: string | EmbeddingHeadersProvider;
    /**
     * The API key for the reranking service to use, or the {@link RerankingHeadersProvider} if using
     * a provider that requires it (e.g. AWS bedrock).
     */
    rerankingApiKey?: string | RerankingHeadersProvider;
    /**
     * The configuration for logging events emitted by the {@link DataAPIClient}.
     *
     * This can be set at any level of the major class hierarchy, and will be inherited by all child classes.
     *
     * See {@link LoggingConfig} for *much* more information on configuration, outputs, and inheritance.
     */
    logging?: LoggingConfig;
    /**
     * Advanced & currently somewhat unstable features related to customizing the collection's ser/des behavior at a lower level.
     *
     * Use with caution. See official DataStax documentation for more info.
     *
     * @beta
     */
    serdes?: CollectionSerDesConfig;
    /**
     * ##### Overview
     *
     * The default timeout options for any operation performed on this {@link Collection} instance.
     *
     * See {@link TimeoutDescriptor} for much more information about timeouts.
     *
     * @example
     * ```ts
     * // The request timeout for all operations is set to 1000ms.
     * const client = new DataAPIClient('...', {
     *   timeoutDefaults: { requestTimeoutMs: 1000 },
     * });
     *
     * // The request timeout for all operations borne from this Db is set to 2000ms.
     * const db = client.db('...', {
     *   timeoutDefaults: { requestTimeoutMs: 2000 },
     * });
     * ```
     *
     * ##### Inheritance
     *
     * The timeout options are inherited by all child classes, and can be overridden at any level, including the individual method level.
     *
     * Individual-method-level overrides can vary in behavior depending on the method; again, see {@link TimeoutDescriptor}.
     *
     * ##### Defaults
     *
     * The default timeout options are as follows:
     * - `requestTimeoutMs`: 15000
     * - `generalMethodTimeoutMs`: 30000
     * - `collectionAdminTimeoutMs`: 60000
     * - `tableAdminTimeoutMs`: 30000
     * - `databaseAdminTimeoutMs`: 600000
     * - `keyspaceAdminTimeoutMs`: 30000
     *
     * @see TimeoutDescriptor
     */
    timeoutDefaults?: Partial<TimeoutDescriptor>;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - The `defaultMaxTimeMS` option is no longer available here; the timeouts system has been overhauled, and defaults should now be set using the `timeoutDefaults` option.
     */
    defaultMaxTimeMS?: 'ERROR: The `defaultMaxTimeMS` option is no longer available here; the timeouts system has been overhauled, and defaults should now be set using the `timeoutDefaults` option';
}

/**
 * Weaker version os StrictPop which allows for more flexibility in typing pop operations.
 *
 * @public
 */
export declare type CollectionPop<Schema> = {
    [K in keyof CollectionArrayUpdate<Schema>]?: number;
};

/**
 * Weaker version of StrictPush which allows for more flexibility in typing push operations.
 *
 * @public
 */
export declare type CollectionPush<Schema> = {
    [K in keyof CollectionArrayUpdate<Schema>]?: (CollectionArrayUpdate<Schema>[K] | {
        $each: CollectionArrayUpdate<Schema>[K][];
        $position?: number;
    });
};

/**
 * Represents the options for the `replaceOne` command.
 *
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field sort - The sort order to pick which document to replace if the filter selects multiple documents.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.replaceOne
 *
 * @public
 */
export declare type CollectionReplaceOneOptions = GenericReplaceOneOptions;

/**
 * Represents the result of a replaceOne operation.
 *
 * @example
 * ```typescript
 * const result = await collection.replaceOne({
 *   _id: 'abc'
 * }, {
 *   name: 'John'
 * }, {
 *   upsert: true
 * });
 *
 * if (result.upsertedCount) {
 *   console.log(`Document with ID ${result.upsertedId} was upserted`);
 * }
 * ```
 *
 * @field matchedCount - The number of documents that matched the filter.
 * @field modifiedCount - The number of documents that were actually modified.
 * @field upsertedCount - The number of documents that were upserted.
 * @field upsertedId - The identifier of the upserted document if `upsertedCount > 0`.
 *
 * @see Collection.replaceOne
 *
 * @public
 */
export declare type CollectionReplaceOneResult<RSchema> = GenericUpdateResult<IdOf<RSchema>, 0 | 1>;

/**
 * @public
 */
export declare interface CollectionRerankOptions {
    enabled?: boolean;
    service: RerankServiceOptions;
}

/**
 * @beta
 */
export declare interface CollectionSerCtx extends BaseSerCtx<CollectionSerCtx> {
    bigNumsEnabled: boolean;
}

/**
 * @beta
 */
export declare interface CollectionSerDesConfig extends BaseSerDesConfig<CollectionSerCtx, CollectionDesCtx> {
    /**
     * ##### Overview
     *
     * By default, large numbers (such as `bigint` and {@link BigNumber}) are disabled during serialization and deserialization.
     * _This means that attempts to serialize such numbers will result in errors, and they may lose precision during deserialization._
     *
     * To enable big numbers, you may set configure this option to select which numerical type each field is deserialized to.
     *
     * ---
     *
     * ##### Why is this not enabled by default?
     *
     * This errorful behavior exists for two primary reasons:
     * 1. **Performance:** Enabling big numbers necessitates usage of a specialized JSON library which is capable of serializing/deserializing these numbers without loss of precision, which is much slower than the native JSON library.
     *     - Realistically, however, the difference is likely negligible for most cases
     * 2. **Ambiguity in Deserialization**: There is an inherent ambiguity in deciding how to deserialize big numbers, as certain numbers may be representable in various different numerical formats, and not in an easily predictable way.
     *     - For example, `9007199254740992` is equally representable as either a `number`, `bigint`, a `BigNumber`, or even a `string`.
     *
     * Luckily, there is no such ambiguity in serialization, as any number is just a series of digits in JSON.
     *
     * ---
     *
     * ##### Configuring this option
     *
     * Deserialization behavior must be configured to enable big numbers on a collection-by-collection basis.
     *
     * Serialization behavior requires no such configuration, as there is no serialization ambiguity as aforementioned.
     *
     * This option can be configured in two ways:
     * - **As a function**, which takes in the path of the field being deserialized and returns a coercion type.
     *   - See {@link CollNumCoercionFn} for more details.
     * - **As a configuration object**, which allows you to specify the coercion type for any path.
     *   - See {@link CollNumCoercionCfg} for more details.
     *
     * The coercion type itself (a {@link CollNumCoercion}) is either:
     * - A string representing a pre-defined numerical coercion, or
     * - A function which takes in the value and the path of the field being deserialized, and returns the coerced value.
     *
     * See {@link CollNumCoercion} for the different coercion types, and any additional caveats on a per-type basis.
     *
     * ---
     *
     * ##### Examples
     *
     * The following example uses `bigint` for monetary fields, and `number`s for all other fields.
     *
     * **It's heavily recommended that you read the documentation for {@link CollNumCoercion} to understand the implications of each coercion type.**
     *
     * @example
     * ```ts
     * interface Order {
     *   discount: bigint,
     *   statusCode: number,
     *   items: {
     *     productID: UUID,
     *     quantity: number,
     *     price: BigNumber,
     *   }[],
     * }
     *
     * const orders = db.collection<Order>('orders', {
     *   serdes: {
     *     enableBigNumbers: {
     *       '*': 'number',
     *       'discount': 'bigint',
     *       'items.*.price': 'bignumber',
     *     },
     *   },
     * });
     *
     * const { insertedId } = await orders.insertOne({
     *   discount: 123n,
     *   statusCode: 1,
     *   items: [
     *     {
     *       productID: uuid.v4(),
     *       quantity: 2,
     *       price: BigNumber(100),
     *     },
     *   ],
     * });
     *
     * const order = await orders.findOne({ _id: insertedId });
     *
     * console.log(order.discount); // 123n
     * console.log(order.statusCode); // 1
     * console.log(order.items[0].price); // BigNumber(100)
     * ```
     *
     * @see CollNumCoercionFn
     * @see CollNumCoercionCfg
     * @see CollNumCoercion
     */
    enableBigNumbers?: CollNumCoercionFn | CollNumCoercionCfg;
    codecs?: RawCollCodecs[];
}

/**
 * Represents the update filter to specify how to update a document.
 *
 * @example
 * ```typescript
 * const updateFilter: UpdateFilter<SomeDoc> = {
 *   $set: {
 *     'customer.name': 'Jim B.'
 *   },
 *   $unset: {
 *     'customer.phone': ''
 *   },
 *   $inc: {
 *     'customer.age': 1
 *   },
 * }
 * ```
 *
 * @field $set - Set the value of a field in the document.
 * @field $setOnInsert - Set the value of a field in the document if an upsert is performed.
 * @field $unset - Remove the field from the document.
 * @field $inc - Increment the value of a field in the document.
 * @field $push - Add an element to an array field in the document.
 * @field $pop - Remove an element from an array field in the document.
 * @field $rename - Rename a field in the document.
 * @field $currentDate - Set the value of a field to the current date.
 * @field $min - Only update the field if the specified value is less than the existing value.
 * @field $max - Only update the field if the specified value is greater than the existing value.
 * @field $mul - Multiply the value of a field in the document.
 * @field $addToSet - Add an element to an array field in the document if it does not already exist.
 *
 * @public
 */
export declare interface CollectionUpdateFilter<Schema extends SomeDoc> {
    /**
     * Set the value of a field in the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $set: {
     *     'customer.name': 'Jim B.'
     *   }
     * }
     * ```
     */
    $set?: Partial<Schema> & SomeDoc;
    /**
     * Set the value of a field in the document if an upsert is performed.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $setOnInsert: {
     *     'customer.name': 'Jim B.'
     *   }
     * }
     * ```
     */
    $setOnInsert?: Partial<Schema> & SomeDoc;
    /**
     * Remove the field from the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $unset: {
     *     'customer.phone': ''
     *   }
     * }
     * ```
     */
    $unset?: Record<string, '' | true | 1>;
    /**
     * Increment the value of a field in the document if it's potentially a `number`.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $inc: {
     *     'customer.age': 1
     *   }
     * }
     * ```
     */
    $inc?: CollectionNumberUpdate<Schema> & Record<string, number>;
    /**
     * Add an element to an array field in the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $push: {
     *     'items': 'Extended warranty - 5 years'
     *   }
     * }
     * ```
     */
    $push?: CollectionPush<Schema> & SomeDoc;
    /**
     * Remove an element from an array field in the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $pop: {
     *     'items': -1
     *   }
     * }
     * ```
     */
    $pop?: CollectionPop<Schema> & Record<string, number>;
    /**
     * Rename a field in the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $rename: {
     *     'customer.name': 'client.name'
     *   }
     * }
     * ```
     */
    $rename?: Record<string, string>;
    /**
     * Set the value of a field to the current date.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $currentDate: {
     *     'purchase_date': true
     *   }
     * }
     * ```
     */
    $currentDate?: CollectionCurrentDate<Schema> & Record<string, boolean>;
    /**
     * Only update the field if the specified value is less than the existing value.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $min: {
     *     'customer.age': 18
     *   }
     * }
     * ```
     */
    $min?: (CollectionNumberUpdate<Schema> | CollectionDateUpdate<Schema>) & Record<string, number | bigint | Date | {
        $date: number;
    }>;
    /**
     * Only update the field if the specified value is greater than the existing value.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $max: {
     *     'customer.age': 65
     *   }
     * }
     * ```
     */
    $max?: (CollectionNumberUpdate<Schema> | CollectionDateUpdate<Schema>) & Record<string, number | bigint | Date | {
        $date: number;
    }>;
    /**
     * Multiply the value of a field in the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $mul: {
     *     'customer.age': 1.1
     *   }
     * }
     * ```
     */
    $mul?: CollectionNumberUpdate<Schema> & Record<string, number>;
    /**
     * Add an element to an array field in the document if it does not already exist.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $addToSet: {
     *     'items': 'Extended warranty - 5 years'
     *   }
     * }
     * ```
     */
    $addToSet?: CollectionPush<Schema> & SomeDoc;
}

/**
 * ##### Overview
 *
 * Represents an error that occurred during an `updateMany` operation (which is, generally, paginated).
 *
 * Contains the number of documents that were successfully matched and/or modified, as well as the cumulative errors
 * that occurred during the operation.
 *
 * @example
 * ```ts
 * try {
 *   await collection.updateMany({ age: 30 }, { $inc: { age: 1 } });
 * } catch (e) {
 *   if (e instanceof CollectionUpdateManyError) {
 *     console.log(e.cause);
 *     console.log(e.partialResult);
 *   }
 * }
 * ```
 *
 * @see Collection.updateMany
 *
 * @public
 */
export declare class CollectionUpdateManyError extends DataAPIError {
    /**
     * The name of the error. This is always 'UpdateManyError'.
     */
    name: string;
    /**
     * The partial result of the `UpdateMany` operation that was performed. This is *always* defined, and is the result
     * of the operation up to the point of the first error.
     */
    readonly partialResult: CollectionUpdateManyResult<SomeDoc>;
    /**
     * The error that caused the operation to fail.
     */
    readonly cause: Error;
    /* Excluded from this release type: __constructor */
}

/**
 Options for an `updateMany` command on a collection.
 *
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.updateMany
 *
 * @public
 */
export declare type CollectionUpdateManyOptions = GenericUpdateManyOptions;

/**
 * Represents the result of an `updateMany` command on a collection.
 *
 * @example
 * ```typescript
 * const result = await collections.updateMany({
 *   name: 'Jane',
 * }, {
 *   $set: { name: 'John' }
 * }, {
 *   upsert: true
 * });
 *
 * if (result.upsertedCount) {
 *   console.log(`Document with ID ${JSON.stringify(result.upsertedId)} was upserted`);
 * }
 * ```
 *
 * @field matchedCount - The number of documents that matched the filter.
 * @field modifiedCount - The number of documents that were actually modified.
 * @field upsertedCount - The number of documents that were upserted.
 * @field upsertedId - The identifier of the upserted document if `upsertedCount > 0`.
 *
 * @see Collection.updateMany
 *
 * @public
 */
export declare type CollectionUpdateManyResult<RSchema> = GenericUpdateResult<IdOf<RSchema>, number>;

/**
 * ##### Overview
 *
 * The options for an `updateOne` command on a {@link Collection}.
 *
 * @example
 * ```ts
 * const result = await collection.updateOne(
 *   { name: 'John' },
 *   { $set: { dob: new Date('1990-01-01'), updatedAt: { $currentDate: true } } },
 *   { upsert: true, sort: { $vector: [...] } },
 * );
 * ```
 *
 * ---
 *
 * ##### Datatypes
 *
 * See {@link Collection}'s documentation for information on the available datatypes for collections.
 *
 * ---
 *
 * ##### Update operations
 *
 * See {@link CollectionUpdateFilter}'s documentation for information on the available update operations.
 *
 * @see Collection.updateOne
 * @see CollectionUpdateOneResult
 *
 * @public
 */
export declare type CollectionUpdateOneOptions = GenericUpdateOneOptions;

/**
 * ##### Overview
 *
 * Represents the result of an `updateOne` command on a {@link Collection}.
 *
 * > **🚨Important:** The exact result type depends on the `upsertedCount` field of the result:
 * - If `upsertedCount` is `0`, the result will be of type {@link GuaranteedUpdateResult} & {@link NoUpsertUpdateResult}.
 * - If `upsertedCount` is `1`, the result will be of type {@link GuaranteedUpdateResult} & {@link UpsertedUpdateResult}.
 *
 * @example
 * ```typescript
 * const result = await collection.updateOne(
 *   { _id: 'abc' },
 *   { $set: { name: 'John' } },
 *   { upsert: true },
 * );
 *
 * if (result.upsertedCount) {
 *   console.log(`Document with ID ${result.upsertedId} was upserted`);
 * }
 * ```
 *
 * @see Collection.updateOne
 * @see CollectionUpdateOneOptions
 *
 * @public
 */
export declare type CollectionUpdateOneResult<RSchema> = GenericUpdateResult<IdOf<RSchema>, 0 | 1>;

/**
 * Represents the options for the vector search.
 *
 * @field dimension - The dimension of the vectors.
 * @field metric - The similarity metric to use for the vector search.
 * @field service - Options related to configuring the automatic embedding service (vectorize)
 *
 * @public
 */
export declare interface CollectionVectorOptions {
    /**
     * The dimension of the vectors stored in the collections.
     *
     * If `service` is not provided, this must be set. Otherwise, the necessity of this being set comes on a per-model
     * basis:
     * - Some models have default vector dimensions which may be flexibly modified
     * - Some models have no default dimension, and must be given an explicit one
     * - Some models require a specific dimension that's already set by default
     *
     * You can find out more information about each model in the [DataStax docs](https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html),
     * or through {@link DbAdmin.findEmbeddingProviders}.
     */
    dimension?: number;
    /**
     * The similarity metric to use for the vector search.
     *
     * See [intro to vector databases](https://docs.datastax.com/en/astra/astra-db-vector/get-started/concepts.html#metrics) for more details.
     */
    metric?: 'cosine' | 'euclidean' | 'dot_product';
    /**
     * The options for defining the embedding service used for vectorize, to automatically transform your
     * text into a vector ready for semantic vector searching.
     *
     * You can find out more information about each provider/model in the [DataStax docs](https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html),
     * or through {@link DbAdmin.findEmbeddingProviders}.
     */
    service?: VectorizeServiceOptions;
    /**
     * Configures the index with the fastest settings for a given source of embeddings vectors.
     *
     * As of time of writing, example `sourceModel`s include `'openai-v3-large'`, `'cohere-v3'`, `'bert'`, and a handful of others.
     *
     * If no source model if provided, this setting will default to `'other'`.
     */
    sourceModel?: LitUnion<'other'>;
}

/**
 * @beta
 */
export declare type CollNominalCodecOpts = NominalCodecOpts<CollectionSerCtx, CollectionDesCtx>;

/**
 * ##### Overview
 *
 * > **💡Tip:** read the documentation for {@link CollectionSerDesConfig.enableBigNumbers} before reading this.
 *
 * The `CollNumCoercion` type is used to define how numeric values should be coerced when deserializing data in collections.
 *
 * Each type of coercion has its own characteristics, and the choice of coercion should be well-thought-out, as misuse may lead to unexpected behavior and even damaged data.
 *
 * ---
 *
 * ##### Under the hood
 *
 * > **✏️Note:** in this context, "large" means that a number is not perfectly representable as a JS `number`.
 *
 * Under the hood, the specialized JSON parser converts every number to either a `number` or a `BigNumber`, depending on its size. From there, the coercion function is applied to the value to convert it to the desired type.
 *
 * **This means that coercion is applied after parsing, and certain coercions may fail if the value is not compatible with the coercion type.**
 * - For example, coercing a `BigNumber` to a `number` may fail if the value is too large to fit in a `number`.
 * - In this case, the coercion function will throw a {@link NumCoercionError} error.
 *
 * ---
 *
 * ##### Predefined coercions
 *
 * **Type:** `number`
 *   - **Description:** Coerces the value to a `number`, possibly losing precision if the value is too large.
 *   - **Throws?:** No.
 *
 * **Type:** `strict_number`
 *   - **Description:** Coerces the value to a `number`, only if the value not too large to be a `number`.
 *   - **Throws?:** Yes, if the value is too large to fit in a `number`.
 *
 * **Type:** `bigint`
 *   - **Description:** Coerces the value to a `bigint`, only if the value is an integer.
 *   - **Throws?:** Yes, if the value is not an integer.
 *
 * **Type:** `bignumber`
 *   - **Description:** Coerces the value to a `BigNumber`.
 *   - **Throws?:** No.
 *
 * **Type:** `string`
 *   - **Description:** Coerces the value to a `string`.
 *   - **Throws?:** No.
 *
 * **Type:** `number_or_string`
 *   - **Description:** Coerces the value to a `number` if it is not too large, otherwise coerces it to a `string`.
 *   - **Throws?:** No.
 *
 * ---
 *
 * ##### Custom coercions
 *
 * You can also use a custom coercion function as the coercion type, which takes the value and the path as arguments and returns the coerced value.
 *
 * @example
 * ```ts
 * const coll = db.collection('coll', {
 *   serdes: {
 *     enableBigNumbers: {
 *       '*': number,
 *       'items.*.price': (val, path) => {
 *          // nonsensical but demonstrative example
 *          const itemIndex = path[1];
 *          return BigNumber(value).times(itemIndex);
 *       },
 *     }
 *   },
 * });
 *
 * const { insertedId } = await coll.insertOne({
 *   itemCount: 3,
 *   items: [{ price: 10 }, { price: 20 }, { price: 30 }],
 * });
 *
 * const item = await coll.findOne({ _id: insertedId });
 *
 * console.log(item.itemCount); // 3
 * console.log(item.items[0].price); // BigNumber(0)
 * console.log(item.items[1].price); // BigNumber(20)
 * console.log(item.items[2].price); // BigNumber(60)
 * ```
 *
 * @see CollectionSerDesConfig.enableBigNumbers
 * @see CollNumCoercionFn
 * @see CollNumCoercionCfg
 * @see NumCoercionError
 *
 * @public
 */
export declare type CollNumCoercion = 'number' | 'strict_number' | 'bigint' | 'bignumber' | 'string' | 'number_or_string' | ((val: number | BigNumber, path: readonly PathSegment[]) => unknown);

/**
 * ##### Overview
 *
 * > **💡Tip:** read the documentation for {@link CollectionSerDesConfig.enableBigNumbers} before reading this.
 *
 * This method of configuring the numerical deserialization behavior uses a configuration object that maps paths to coercion types.
 *
 * If you'd prefer to use a more flexible approach, you can use the {@link CollNumCoercionFn} type to define the coercion for each path.
 *
 * @example
 * ```ts
 * const orders = db.collection<Order>('orders', {
 *   serdes: {
 *     enableBigNumbers: {
 *       '*': 'number',
 *       'discount': 'bigint',
 *       'items.*.price': 'bignumber',
 *     },
 *   },
 * });
 * ```
 *
 * ---
 *
 * ##### The configuration object
 *
 * The configuration object is a map of paths to coercion types.
 *
 * These paths may also contain wildcards (`'*'`), which matches any single element in the path at that position.
 * - However, it will *not* match multiple elements (or no elements) in the path.
 * - For example, `'foo.*'` will match `'foo.bar'`, but _not_ `'foo'` or `'foo.bar.baz'`.
 *
 * Paths containing numbers (e.g. `'arr.0'`) will match both `arr: ['me!']` and `arr: { '0': 'me!' }`.
 *
 * > **🚨Important:** There must be a `'*'` key in the configuration object, which will be used as the default coercion for all paths that do not have a specific coercion defined.
 * > - This key is required, and the configuration will throw an error if it is not present.
 *
 * ---
 *
 * ##### Using a single {@link CollNumCoercion}
 *
 * You may simply use `{ '*': '<type>' }` to return a single coercion type for all paths.
 *
 * This is specifically optimized to be just as fast as using `() => '<type>'`.
 *
 * @see CollectionSerDesConfig.enableBigNumbers
 * @see CollNumCoercionFn
 * @see CollNumCoercion
 *
 * @public
 */
export declare interface CollNumCoercionCfg {
    '*': CollNumCoercion;
    [path: string]: CollNumCoercion;
}

/**
 * ##### Overview
 *
 * > **💡Tip:** read the documentation for {@link CollectionSerDesConfig.enableBigNumbers} before reading this.
 *
 * This method of configuring the numerical deserialization behavior uses a function that takes the path of the field being deserialized, and returns the coercion type to be used for that path.
 *
 * If you'd prefer to use a more declarative approach, you can use the {@link CollNumCoercionCfg} type to define the coercion for each path.
 *
 * @example
 * ```ts
 * const coll = db.collection('coll', {
 *   serdes: {
 *     enableBigNumbers(path, matches) {
 *       if (path[0] === 'discount') {
 *         return 'bigint';
 *       }
 *
 *       if (matches(['items', '*', 'price'])) {
 *         return 'bignumber';
 *       }
 *
 *       return 'number';
 *     },
 *   }
 * });
 * ```
 *
 * ---
 *
 * ##### Using the function
 *
 * The function is called for each field being deserialized, and it receives two arguments:
 * - `path`: the path of the field being deserialized, as an array of strings.
 * - `matches`: a utility function that takes a "path matcher" as an argument and returns `true` if it matches the current path being deserialized.
 *
 * The matcher must be an array of strings and numbers, but it may also contain wildcards (`'*'`) to match any single field.
 * - The wildcard `'*'` matches a single element in the path at that position.
 *   - However, it will *not* match multiple elements (or no elements) in the path.
 *   - For example, `['foo', '*']` will match `['foo', 'bar']`, but _not_ `['foo']` or `['foo', 'bar', 'baz']`.
 * - Strings and numbers are strictly compared.
 *   - For example, `['foo', 1]` will _not_ match `['foo', '1']`.
 *   - The exception is the wildcard `'*'`, which will match any string or number.
 *
 * This function can then return any {@link CollNumCoercion} in order to coerce the value to the desired type.
 *
 * ---
 *
 * ##### Using a single {@link CollNumCoercion}
 *
 * You may simply use `() => '<type>'` to return a single coercion type for all paths.
 *
 * @see CollectionSerDesConfig.enableBigNumbers
 * @see CollNumCoercionCfg
 * @see CollNumCoercion
 *
 * @public
 */
export declare type CollNumCoercionFn = (path: readonly PathSegment[], matches: (path: readonly PathSegment[]) => boolean) => CollNumCoercion;

/**
 * @beta
 */
export declare type CollTypeCodecOpts = TypeCodecOpts<CollectionSerCtx, CollectionDesCtx>;

declare type Cols2CqlTypes<Columns extends CreateTableColumnDefinitions, Overrides extends TableSchemaTypeOverrides> = {
    -readonly [P in keyof Columns]: CqlType2TSType<Columns[P], Overrides>;
};

/**
 * Common base class for all command events.
 *
 * **Note that these emit *real* commands, not any abstracted commands like "insertMany" or "updateMany",
 * which may be split into multiple of those commands under the hood.**
 *
 * @public
 */
export declare abstract class CommandEvent extends BaseClientEvent {
    /**
     * The command object. Equal to the response body of the HTTP request.
     *
     * Note that this is the actual raw command object; it's not necessarily 1:1 with methods called on the collection/db.
     *
     * @example
     * ```typescript
     * {
     *   insertOne: { document: { name: 'John' } }
     * }
     * ```
     */
    readonly command: Record<string, any>;
    /**
     * The target of the command.
     */
    readonly target: Readonly<CommandEventTarget>;
    /* Excluded from this release type: __constructor */
    /**
     * The command name.
     *
     * This is the key of the command object. For example, if the command object is
     * `{ insertOne: { document: { name: 'John' } } }`, the command name is `insertOne`.
     */
    get commandName(): string;
    getMessagePrefix(): string;
    /* Excluded from this release type: _extraLogInfoAsString */
    /* Excluded from this release type: _modifyEventForFormatVerbose */
}

/**
 * The events emitted by the {@link DataAPIClient}. These events are emitted at various stages of the
 * command's lifecycle. Intended for use for monitoring and logging purposes.
 *
 * **Note that these emit *real* commands, not any abstracted commands like "insertMany" or "updateMany",
 * which may be split into multiple of those commands under the hood.**
 *
 * @public
 */
export declare type CommandEventMap = {
    /**
     * Emitted when a command is started, before the initial HTTP request is made.
     */
    commandStarted: CommandStartedEvent;
    /**
     * Emitted when a command has succeeded.
     */
    commandSucceeded: CommandSucceededEvent;
    /**
     * Emitted when a command has errored.
     */
    commandFailed: CommandFailedEvent;
    /**
     * Emitted when a command has warnings.
     */
    commandWarnings: CommandWarningsEvent;
};

/**
 * The target of the command.
 *
 * @public
 */
export declare type CommandEventTarget = {
    url: string;
    keyspace?: never;
    table?: never;
    collection?: never;
} | {
    url: string;
    keyspace: string;
    table?: never;
    collection?: never;
} | {
    url: string;
    keyspace: string;
    table?: never;
    collection: string;
} | {
    url: string;
    keyspace: string;
    table: string;
    collection?: never;
};

/**
 * Emitted when a command has errored.
 *
 * **Note that these emit *real* commands, not any abstracted commands like "insertMany" or "updateMany",
 * which may be split into multiple of those commands under the hood.**
 *
 * See {@link CommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class CommandFailedEvent extends CommandEvent {
    /* Excluded from this release type: _permits */
    /**
     * The duration of the command, in milliseconds.
     */
    readonly duration: number;
    /**
     * The error that caused the command to fail.
     *
     * Typically, some {@link DataAPIError}, commonly a {@link DataAPIResponseError} or one of its subclasses.
     */
    readonly error: Error;
    /**
     * The response object from the Data API, if available.
     */
    readonly response?: RawDataAPIResponse;
    /* Excluded from this release type: __constructor */
    getMessage(): string;
    trimDuplicateFields(): this;
}

/**
 * Emitted when a command is started, before the initial HTTP request is made.
 *
 * **Note that these emit *real* commands, not any abstracted commands like "insertMany" or "updateMany",
 * which may be split into multiple of those commands under the hood.**
 *
 * See {@link CommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class CommandStartedEvent extends CommandEvent {
    /* Excluded from this release type: _permits */
    /**
     * The timeout for the command, in milliseconds.
     */
    readonly timeout: Partial<TimeoutDescriptor>;
    /* Excluded from this release type: __constructor */
    getMessage(): string;
}

/**
 * Emitted when a command has succeeded.
 *
 * **Note that these emit *real* commands, not any abstracted commands like "insertMany" or "updateMany",
 * which may be split into multiple of those commands under the hood.**
 *
 * See {@link CommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class CommandSucceededEvent extends CommandEvent {
    /* Excluded from this release type: _permits */
    /**
     * The duration of the command, in milliseconds. Starts counting from the moment of the initial HTTP request.
     */
    readonly duration: number;
    /**
     * The response object from the Data API.
     */
    readonly response: RawDataAPIResponse;
    /* Excluded from this release type: __constructor */
    getMessage(): string;
}

/**
 * Event emitted when the Data API returned a warning for some command.
 *
 * See {@link CommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class CommandWarningsEvent extends CommandEvent {
    /* Excluded from this release type: _permits */
    /**
     * The warnings that occurred.
     */
    readonly warnings: ReadonlyNonEmpty<DataAPIWarningDescriptor>;
    /* Excluded from this release type: __constructor */
    getMessage(): string;
}

/* Excluded from this release type: ConsoleLike */

/**
 * Checks if the schema contains a date type.
 *
 * @public
 */
export declare type ContainsDate<Schema> = IsDate<Schema[keyof Schema]>;

declare interface CqlGenericType2TSTypeDict<Def, Overrides extends TableSchemaTypeOverrides> {
    map: CqlMapType2TsType<Def, Overrides>;
    list: CqlListType2TsType<Def, Overrides>;
    set: CqlSetType2TsType<Def, Overrides>;
    vector: CqlVectorType2TsType<Def> | null;
}

declare type CqlListType2TsType<Def, Overrides extends TableSchemaTypeOverrides> = Def extends {
    valueType: infer ValueType extends string;
} ? (CqlType2TSTypeInternal<ValueType, never, Overrides> & {})[] : TypeErr<`Invalid definition for 'list'; should be of format { type: 'list', valueType: <scalar> }`>;

declare type CqlMapType2TsType<Def, Overrides extends TableSchemaTypeOverrides> = Def extends {
    keyType: infer KeyType extends string;
    valueType: infer ValueType extends string;
} ? Map<CqlType2TSTypeInternal<KeyType, never, Overrides> & {}, CqlType2TSTypeInternal<ValueType, never, Overrides> & {}> : TypeErr<`Invalid definition for 'map'; should be of format { type: 'map', keyType: <scalar>, valueType: <scalar> }`>;

declare interface CqlNonGenericType2TSTypeDict {
    ascii: string | null;
    bigint: bigint | null;
    blob: DataAPIBlob | null;
    boolean: boolean | null;
    counter: bigint | null;
    date: DataAPIDate | null;
    decimal: BigNumber | null;
    double: number | null;
    duration: DataAPIDuration | null;
    float: number | null;
    int: number | null;
    inet: DataAPIInet | null;
    smallint: number | null;
    text: string | null;
    time: DataAPITime | null;
    timestamp: Date | null;
    timeuuid: UUID | null;
    tinyint: number | null;
    uuid: UUID | null;
    varchar: string | null;
    varint: bigint | null;
}

declare type CqlSetType2TsType<Def, Overrides extends TableSchemaTypeOverrides> = Def extends {
    valueType: infer ValueType extends string;
} ? Set<CqlType2TSTypeInternal<ValueType, never, Overrides> & {}> : TypeErr<`Invalid definition for 'set'; should be of format { type: 'set', valueType: <scalar> }`>;

/**
 * ##### Overview
 *
 * Converts a CQL type to its TS equivalent.
 *
 * This interprets both {@link StrictCreateTableColumnDefinition} and {@link LooseCreateTableColumnDefinition} equally.
 * - Though note that the former type _must_ be used for collection/`vector` types
 *
 * @example
 * ```ts
 * // number | null
 * CqlType2TSType<'int', ...>
 *
 * // DataAPIDuration  | null
 * CqlType2TSType<{ type: 'duration }, ...>
 *
 * // Map<string, number>
 * CqlType2TSType<{ type: 'map', keyType: 'text', valueType: 'int' }>
 *
 * // unknown
 * CqlType2TSType<'idk', ...>
 *
 * // TypeErr<`Invalid definition for 'map'; should be of format { ... }`>
 * CqlType2TSType<'map'>
 * ```
 *
 * ##### Getting rid of the `| null`
 *
 * As this type is intended primarily for internal usage within the {@link InferTableSchema}-like types, it will return `<type> | null` for all scalar values, as they all may be `null` when returned back from the Data API
 * - Collection types are excluded from this rule as, when returned from the Data API, they will just be set to their empty value.
 *
 * You can simply do `CqlType2TSType<...> & {}` to get rid of the `| null` type (or use type overrides as explained below).
 *
 * ##### Type overrides
 *
 * When working with custom ser/des, you may find it necessary to override the type of a specific datatype.
 *
 * See {@link TableSchemaTypeOverrides} for more information on this subject.
 *
 * @example
 * ```ts
 * // BigNumber | null
 * CqlType2TSType<'bigint', { bigint: BigNumber | null }>
 * ```
 *
 * @see InferTableSchema
 *
 * @public
 */
export declare type CqlType2TSType<Def extends CreateTableColumnDefinitions[string], Overrides extends TableSchemaTypeOverrides = Record<never, never>> = CqlType2TSTypeInternal<PickCqlType<Def>, Def, Overrides>;

declare type CqlType2TSTypeInternal<Type, Def, Overrides extends TableSchemaTypeOverrides> = Type extends keyof Overrides ? Overrides[Type] : Type extends keyof CqlNonGenericType2TSTypeDict ? CqlNonGenericType2TSTypeDict[Type] : Type extends keyof CqlGenericType2TSTypeDict<Def, Overrides> ? CqlGenericType2TSTypeDict<Def, Overrides>[Type] : unknown;

declare type CqlVectorType2TsType<Def> = Def extends {
    service: unknown;
} ? DataAPIVector | string : DataAPIVector;

/**
 * ##### Overview
 *
 * Represents the client-side options for creating a new vector-enabled DataStax Astra database.
 *
 * These options include the blocking options, the timeout, and any custom options for the {@link Db} instance underlying the {@link AstraDbAdmin} that is returned once the database is created.
 *
 * **Disclaimer: database creation is a lengthy operation, and may take upwards of 2-3 minutes**
 *
 * ---
 *
 * ##### Example
 *
 * These options are used in the second parameter of the `createDatabase` method.
 *
 * @example
 * ```ts
 * const dbAdmin = await admin.createDatabase({
 *   name: 'my-db',
 *   cloudProvider: 'GCP',
 *   region: 'us-central1',
 * }, {
 *   databaseAdminTimeoutMs: 240000,
 *   pollInterval: 20000,
 *   dbOptions: { logging: 'all' },
 * });
 * ```
 *
 * @see AstraAdmin.createDatabase
 * @see AstraDatabaseConfig
 *
 * @public
 */
export declare type CreateAstraDatabaseOptions = AstraAdminBlockingOptions & WithTimeout<'databaseAdminTimeoutMs'> & {
    /**
     * Optional overrides for the {@link Db} instance underlying the {@link AstraDbAdmin} that is returned once the database is created.
     *
     * The {@link AdminOptions} for the spawned {@link AstraDbAdmin} are simply copied from the {@link AstraAdmin} instance performing the operation.
     */
    dbOptions?: DbOptions;
};

/**
 * Represents the common options for creating a keyspace through the `astra-db-ts` client.
 *
 * See {@link AstraAdminBlockingOptions} for more options about blocking behavior.
 *
 * If `updateDbKeyspace` is set to true, the underlying `Db` instance used to create the `DbAdmin` will have its
 * current working keyspace set to the newly created keyspace immediately (even if the keyspace isn't technically
 * yet created).
 *
 * @example
 * ```typescript
 * // If using non-astra, this may be a common idiom:
 * const client = new DataAPIClient({ environment: 'dse' });
 * const db = client.db('<endpoint>', { token: '<token>' });
 *
 * // Will internally call `db.useKeyspace('new_keyspace')`
 * await db.admin().createKeyspace('new_keyspace', {
 *   updateDbKeyspace: true,
 * });
 *
 * // Creates collections in keyspace `new_keyspace` by default now
 * const coll = db.createCollection('my_coll');
 * ```
 *
 * @see DbAdmin.createKeyspace
 *
 * @public
 */
export declare type CreateAstraKeyspaceOptions = AstraAdminBlockingOptions & WithTimeout<'keyspaceAdminTimeoutMs'> & {
    updateDbKeyspace?: boolean;
};

/**
 * Options for creating a new collection (via {@link Db.createCollection}).
 *
 * See {@link Db.createCollection} & {@link Collection} for more information.
 *
 * @field vector - The vector configuration for the collections.
 * @field indexing - The indexing configuration for the collections.
 * @field defaultId - The default ID for the collections.
 * @field keyspace - Overrides the keyspace for the collections.
 * @field timeout - The timeout override for this method
 *
 * @see Db.createCollection
 *
 * @public
 */
export declare interface CreateCollectionOptions<Schema extends SomeDoc> extends CollectionDefinition<Schema>, CollectionOptions {
    timeout?: number | Pick<Partial<TimeoutDescriptor>, 'collectionAdminTimeoutMs'>;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - The `maxTimeMS` option is no longer available here; the timeouts system has been overhauled, and defaults should now be set using the `timeoutDefaults` option.
     */
    maxTimeMS?: 'ERROR: The `maxTimeMS` option is no longer available here; the timeouts system has been overhauled, and defaults should now be set using the `timeoutDefaults` option';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - The client-side `checkExists` option has been removed due to it being unnecessary and prone to check-then-act race conditions. `createCollection` is a no-op if a collection is created with the same options; it will however still throw an error if the options differ.
     */
    checkExists?: 'ERROR: `checkExists` has been removed. It is equivalent to being always `false` now.';
}

/**
 * Represents the options for creating a keyspace on a non-Astra database (i.e. blocking options + keyspace creation options).
 *
 * If no replication options are provided, it will default to `'SimpleStrategy'` with a replication factor of `1`.
 *
 * See {@link AstraAdminBlockingOptions} for more options about blocking behavior.
 *
 * If `updateDbKeyspace` is set to true, the underlying `Db` instance used to create the `DbAdmin` will have its
 * current working keyspace set to the newly created keyspace immediately (even if the keyspace isn't technically
 * yet created).
 *
 * @example
 * ```typescript
 * // If using non-astra, this may be a common idiom:
 * const client = new DataAPIClient({ environment: 'dse' });
 * const db = client.db('<endpoint>', { token: '<token>' });
 *
 * // Will internally call `db.useKeyspace('new_keyspace')`
 * await db.admin().createKeyspace('new_keyspace', {
 *   updateDbKeyspace: true,
 * });
 *
 * // Creates collections in keyspace `new_keyspace` by default now
 * const coll = db.createCollection('my_coll');
 * ```
 *
 * @public
 */
export declare interface CreateDataAPIKeyspaceOptions extends WithTimeout<'keyspaceAdminTimeoutMs'> {
    replication?: KeyspaceReplicationOptions;
    updateDbKeyspace?: boolean;
}

/**
 * ##### Overview
 *
 * Represents the syntax for defining a new column through the bespoke Data API schema definition syntax, in which there
 * are two branching ways to define a column.
 *
 * @example
 * ```ts
 * await db.createTable('my_table', {
 *   definition: {
 *     columns: {
 *       id: 'uuid',
 *       name: { type: 'text' },
 *       set: { type: 'set', valueType: 'text' },
 *     },
 *     primaryKey: ...,
 *   },
 * });
 * ```
 *
 * ##### The "loose" column definition
 *
 * The loose column definition is a shorthand for the strict version, and follows the following example form:
 *
 * ```ts
 * columns: {
 *   textCol: 'text',
 *   uuidCol: 'uuid',
 * }
 * ```
 *
 * In this form, the key is the column name, and the value is the type of the scalar column.
 *
 * If you need to define a column with a more complex type (i.e. for maps, sets, lists, and vectors), you must use the strict column definition.
 *
 * Plus, while it still provides autocomplete, the loose column definition does not statically enforce the type of the column, whereas the strict column definition does.
 *
 * ##### The "strict" column definition
 *
 * The strict column definition is the more structured way to define a column, and follows the following example form:
 *
 * ```ts
 * columns: {
 *   uuidCol: { type: 'uuid' },
 *   mapCol: { type: 'map', keyType: 'text', valueType: 'int' },
 *   listCol: { type: 'list', valueType: 'text' },
 *   vectorCol: { type: 'vector', dimension: 3 },
 * }
 * ```
 *
 * In this form, the key is the column name, and the value is an object with a `type` field that specifies the type of the column.
 *
 * The object may also contain additional fields that are specific to the type of the column:
 * - For `map`, you _must_ specify the `keyType` and `valueType` fields.
 *   - The `keyType` must, for the time being, be either `'text'` or `'ascii'`.
 *   - The `valueType` must be a scalar type.
 * - For `list`s and `set`s, you _must_ specify the `valueType` field.
 *   - The `valueType` must be a scalar type.
 * - For `vector`s, you _must_ specify the `dimension` field.
 *   - You may optionally provide a `service` field to enable vectorize.
 *   - Note that you still need to create a vector index on the column to actually use vector search.
 *
 * @see LooseCreateTableColumnDefinition
 * @see StrictCreateTableColumnDefinition
 *
 * @public
 */
export declare type CreateTableColumnDefinitions = Record<string, LooseCreateTableColumnDefinition | StrictCreateTableColumnDefinition>;

/**
 * The definition for creating a new table through the Data API, using a bespoke schema definition syntax.
 *
 * See {@link Db.createTable} for more info.
 *
 * @public
 */
export declare interface CreateTableDefinition<Def extends CreateTableDefinition<Def> = any> {
    /**
     * The columns to create in the table.
     */
    readonly columns: CreateTableColumnDefinitions;
    /**
     * The primary key definition for the table.
     */
    readonly primaryKey: TablePrimaryKeyDefinition<keyof Def['columns'] & string>;
}

/**
 * Options for creating a new table (via {@link Db.createTable}).
 *
 * See {@link Db.createTable} & {@link Table} for more information.
 *
 * @field definition - The bespoke columns/primary-key definition for the table.
 * @field ifNotExists - Makes operation a no-op if the table already exists.
 * @field keyspace - Overrides the keyspace for the table (from the `Db`'s working keyspace).
 * @field embeddingApiKey - The embedding service's API-key/headers (for $vectorize)
 * @field timeoutDefaults - Default timeouts for all table operations
 * @field logging - Logging configuration overrides
 * @field serdes - Additional serialization/deserialization configuration
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare interface CreateTableOptions<Def extends CreateTableDefinition<Def> = CreateTableDefinition> extends WithTimeout<'tableAdminTimeoutMs'>, TableOptions {
    definition: Def;
    ifNotExists?: boolean;
}

declare type CropTrailingDot<Str extends string> = Str extends `${infer T}.` ? T : Str;

/**
 * ##### Overview
 *
 * A generic exception that may be thrown whenever something non-request-related goes wrong with a cursor.
 *
 * Errors like {@link DataAPIResponseError}s and {@link DataAPITimeoutError}s which occur during an actually request of the cursor will still be thrown directly.
 *
 * This error is intended for errors more-so related to validation & the cursor's lifecycle.
 *
 * @public
 */
export declare class CursorError extends DataAPIError {
    /**
     * The underlying cursor which caused this error.
     */
    readonly cursor: AbstractCursor<unknown>;
    /**
     * The status of the cursor when the error occurred.
     */
    readonly state: CursorState;
    /* Excluded from this release type: __constructor */
}

/**
 * ##### Overview
 *
 * Represents the status of some {@link AbstractCursor}.
 *
 * | Status         | Description                                                                        |
 * |----------------|------------------------------------------------------------------------------------|
 * | `idle`         | The cursor is uninitialized/not in use, and may be modified freely.                |
 * | `started`      | The cursor is currently in use, and cannot be modified w/out rewinding or cloning. |
 * | `closed`       | The cursor is closed, and cannot be used w/out rewinding or cloning.               |
 *
 * @public
 *
 * @see AbstractCursor.state
 */
export declare type CursorState = 'idle' | 'started' | 'closed';

/**
 * @public
 */
export declare type CustomCodecOpts<SerCtx, DesCtx> = CustomCodecSerOpts<SerCtx> & ({
    deserialize: SerDesFn<DesCtx>;
    deserializeGuard: SerDesGuard<DesCtx>;
} | {
    deserialize?: never;
});

/**
 * @public
 */
export declare type CustomCodecSerOpts<SerCtx> = {
    serialize: SerDesFn<SerCtx>;
    serializeGuard: SerDesGuard<SerCtx>;
    serializeClass?: 'One (and only one) of `serializeClass` or `serializeGuard` should be present if `serialize` is present.';
} | {
    serialize: SerDesFn<SerCtx>;
    serializeClass: SomeConstructor;
    serializeGuard?: 'One (and only one) of `serializeClass` or `serializeGuard` should be present if `serialize` is present.';
} | {
    serialize?: never;
};

/**
 * ##### Overview
 *
 * Allows you to use your own custom HTTP request strategy, rather than the default `fetch` or `fetch-h2` implementations.
 *
 * It may also be used to wrap an existing {@link Fetcher} implementation (i.e. {@link FetchNative} or {@link FetchH2}) with your own custom logic or to add extra logging/debug information.
 *
 * ##### Implementation Details
 *
 * See the {@link Fetcher} classes for details on implementing your own custom fetcher, along with a checklist of things to consider.
 *
 * Be wary of the potential for errors or unexpected behavior if you do not take all request information into account when making the request, or make some other mistake with the fetcher.
 *
 * @example
 * ```ts
 * class CustomFetcher implements Fetcher {
 *   async fetch(info: FetcherRequestInfo): Promise<FetcherResponseInfo> {
 *     // Custom fetch implementation
 *   }
 * }
 *
 * const client = new DataAPIClient({
 *   httpOptions: { client: 'custom', fetcher: new CustomFetcher() },
 * });
 * ```
 *
 * ##### Examples
 *
 * *For advanced examples & more information, see the `examples/customize-http` directory in the [astra-db-ts repository](https://github.com/datastax/astra-db-ts)*
 *
 * @see Fetcher
 * @see HttpOptions
 *
 * @public
 */
export declare interface CustomHttpClientOptions {
    /**
     * Tells the Data API client to use your custom "fetcher" for making HTTP requests.
     *
     * See {@link HttpOptions} for the other options available.
     */
    client: 'custom';
    /**
     * The custom "fetcher" to use.
     */
    fetcher: Fetcher;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - The `maxTimeMS` option is no longer available here; the timeouts system has been overhauled, and defaults should now be set using the `timeoutDefaults` option.
     */
    maxTimeMS?: 'ERROR: The `maxTimeMS` option is no longer available here; the timeouts system has been overhauled, and defaults should now be set using the `timeoutDefaults` option';
}

/**
 * Represents a `blob` column for Data API tables.
 *
 * See {@link DataAPIBlobLike} for the types that can be converted into a `DataAPIBlob`.
 *
 * You may use the {@link blob} function as a shorthand for creating a new `DataAPIBlob`.
 *
 * See the official DataStax documentation for more information.
 *
 * @public
 */
export declare class DataAPIBlob implements TableCodec<typeof DataAPIBlob> {
    private readonly _raw;
    /**
     * Errorful implementation of `$SerializeForCollection` for {@link TableCodec}
     *
     * Throws a human-readable error message warning that this datatype may not be used with collections without writing a custom ser/des codec.
     */
    [$SerializeForCollection](): void;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, ({
        $binary: string;
    } | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: any, ctx: TableDesCtx): readonly [0, (DataAPIBlob | undefined)?];
    /**
     * Creates a new `DataAPIBlob` instance from a blob-like value.
     *
     * You can set `validate` to `false` to bypass any validation if you're confident the value is a valid blob.
     *
     * @param blob - The blob-like value to convert to a `DataAPIBlob`
     * @param validate - Whether to validate the blob-like value (default: `true`)
     *
     * @throws TypeError If `blob` is not a valid blob-like value
     */
    constructor(blob: DataAPIBlobLike, validate?: boolean);
    /**
     * Gets the byte length of the blob, agnostic of the underlying type.
     *
     * @returns The byte length of the blob
     */
    get byteLength(): number;
    /**
     * Gets the raw underlying implementation of the blob.
     *
     * @returns The raw blob
     */
    raw(): Exclude<DataAPIBlobLike, DataAPIBlob>;
    /**
     * Returns the blob as an `ArrayBuffer`, converting between types if necessary.
     *
     * @returns The blob as an `ArrayBuffer`
     */
    asArrayBuffer(): ArrayBuffer;
    /**
     * Returns the blob as a `Buffer`, if available, converting between types if necessary.
     *
     * @returns The blob as a `Buffer`
     */
    asBuffer(): MaybeBuffer;
    /**
     * Returns the blob as a base64 string, converting between types if necessary.
     *
     * @returns The blob as a base64 string
     */
    asBase64(): string;
    /**
     * Returns a pretty string representation of the `DataAPIBlob`.
     */
    toString(): string;
    /**
     * Determines whether the given value is a blob-like value (i.e. it's {@link DataAPIBlobLike}.
     *
     * @param value - The value to check
     *
     * @returns `true` if the value is a blob-like value; `false` otherwise
     */
    static isBlobLike(this: void, value: unknown): value is DataAPIBlobLike;
}

/**
 * Represents any type that can be converted into a {@link DataAPIBlob}
 *
 * @public
 */
export declare type DataAPIBlobLike = DataAPIBlob | ArrayBuffer | MaybeBuffer | {
    $binary: string;
};

/**
 * ##### Overview
 *
 * The main entrypoint into working with the Data API. It sits at the top of the
 * [conceptual hierarchy](https://github.com/datastax/astra-db-ts/tree/b2b79c15a388d2373e884e8921530d81f3593431?tab=readme-ov-file#high-level-architecture)
 * of the SDK.
 *
 * The client may take in a default token, which can be overridden by a stronger/weaker token when spawning a new
 * {@link Db} or {@link AstraAdmin} instance.
 *
 * It also takes in a set of default options (see {@link DataAPIClientOptions}) that may also generally be overridden in lower classes.
 *
 * @example
 * ```typescript
 * // Client with default token
 * const client = new DataAPIClient('<token>');
 * const db = client.db('http://localhost:port');
 *
 * // Client with no default token; must provide token in .db() or .admin()
 * const client = new DataAPIClient();
 * const db = client.db('https://<db_id>-<region>.apps.astra.datastax.com', { token });
 *
 * const coll = await db.collection('my_collection');
 *
 * const admin1 = client.admin();
 * const admin2 = client.admin({ adminToken: '<stronger_token>' });
 *
 * console.log(await coll.insertOne({ name: 'John Joe' }));
 * console.log(await admin1.listDatabases());
 * ```
 *
 * ---
 *
 * ##### The options hierarchy
 *
 * Like the class hierarchy aforementioned, the options for each class also form an [adjacent hierarchy](https://github.com/datastax/astra-db-ts/tree/b2b79c15a388d2373e884e8921530d81f3593431?tab=readme-ov-file#options-hierarchy).
 *
 * The options for any class are a deep merge of the options for the class itself and the options for its parent classes.
 *
 * For example, you may set default {@link CollectionOptions.logging} options in {@link DataAPIClientOptions.logging}, and override them in the {@link CollectionOptions} themselves as desired.
 *
 * @example
 * ```ts
 * const client = new DataAPIClient({
 *   logging: [{ events: 'all', emits: 'event' }],
 * });
 * const db = client.db('<endpoint>', { token });
 *
 * // Everything will still be emitted as an event,
 * // But now, `commandFailed` events from this collection will also log to stderr
 * const coll = db.collection('<name>', {
 *   logging: [{ events: 'commandFailed', emits: ['event', 'stderr'] }],
 * });
 * ```
 *
 * ---
 *
 * ##### Non-Astra support (DSE, HCD, etc.)
 *
 * Depending on the Data API backend used, you may need to set the environment option in certain places to "dse", "hcd", etc.
 *
 * See {@link DataAPIEnvironment} for all possible backends; it defaults to "astra" if not specified.
 *
 * > **🚨Important:** If you're not using Astra, you need to specify the environment when:
 * > - Creating the {@link DataAPIClient}
 * > - Using {@link Db.admin}
 *
 * @example
 * ```ts
 * // Client connecting to a local DSE instance
 * const dseToken = new UsernamePasswordTokenProvider('username', 'password');
 * const client = new DataAPIClient(dseToken, { environment: 'dse' });
 * ```
 *
 * @public
 *
 * @see DataAPIEnvironment
 * @see DataAPIClientOptions
 */
export declare class DataAPIClient extends HierarchicalLogger<DataAPIClientEventMap> {    /**
     * ##### Overview
     *
     * Constructs a new instance of the {@link DataAPIClient} without a default token. The token will instead need to
     * be specified when calling `.db()` or `.admin()`.
     *
     * > **💡Tip:** Prefer this overload when using a db-scoped token instead of a more universal token.
     *
     * @example
     * ```typescript
     * const client = new DataAPIClient();
     *
     * // OK
     * const db1 = client.db('<endpoint>', { token: '<token>' });
     *
     * // Will throw error as no token is ever provided
     * const db2 = client.db('<endpoint>');
     * ```
     *
     * @param options - The default options to use when spawning new instances of {@link Db} or {@link AstraAdmin}.
     */
    constructor(options?: DataAPIClientOptions);
    /**
     * ##### Overview
     *
     * Constructs a new instance of the {@link DataAPIClient} with a default token. This token will be used everywhere
     * if no overriding token is provided in `.db()` or `.admin()`.
     *
     * > **💡Tip:** Prefer this overload when using a universal/admin-scoped token.
     *
     * @example
     * ```typescript
     * const client = new DataAPIClient('<default_token>');
     *
     * // OK
     * const db1 = client.db('<endpoint>', { token: '<weaker_token>' });
     *
     * // OK; will use <default_token>
     * const db2 = client.db('<endpoint>');
     * ```
     *
     * @param token - The default token to use when spawning new instances of {@link Db} or {@link AstraAdmin}.
     * @param options - The default options to use when spawning new instances of {@link Db} or {@link AstraAdmin}.
     */
    constructor(token: string | TokenProvider | undefined, options?: DataAPIClientOptions);
    /**
     * ##### Overview
     *
     * Spawns a new {@link Db} instance using a direct endpoint and given options.
     *
     * @example
     * ```ts
     * const db = client.db('http://localhost:8181');
     *
     * const db = client.db('https://<db_id>-<region>.apps.astra.datastax.com', {
     *   keyspace: 'my_keyspace',
     *   token: 'AstraCS:...',
     * });
     * ```
     *
     * ---
     *
     * ##### Disclaimer
     *
     * > **🚨Important**: This does _not_ verify the existence of the database—it only creates a reference.
     * >
     * > Use {@link AstraAdmin.createDatabase} to create a new database if you need to.
     *
     * It is on the user to ensure that the database endpoint is correct.
     *
     * ---
     *
     * ##### The API endpoint
     *
     * This endpoint should include the protocol and the hostname, but not the path.
     *
     * If you're using Astra, this will typically be of the form `https://<db_id>-<region>.apps.astra.datastax.com` (the exception being private endpoints); any other database may have a completely unique domain.
     *
     * > **⚠️Warning:** Spawning a db using an ID and region is no longer supported in `astra-db-ts v2.0+`.
     * >
     * > Use the {@link buildAstraEndpoint} to create the endpoint if you need to.
     *
     * ---
     *
     * ##### The options hierarchy
     *
     * The options for the {@link Db} instance are a deep merge of the options for the {@link DataAPIClient} and the options for the {@link Db} itself.
     *
     * Any options provided to {@link DbOptions} may generally also be overridden in any spawned classes' options (e.g. {@link CollectionOptions}).
     *
     * @example
     * ```typescript
     * const db = client.db('https://<db_id>-<region>.apps.astra.datastax.com', {
     *   keyspace: 'my_keyspace',
     *   token: 'AstraCS:...',
     * });
     *
     * const coll = db.collection('my_coll', {
     *   keyspace: 'other_keyspace',
     * });
     * ```
     *
     * @param endpoint - The direct endpoint to use.
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link Db} instance.
     */
    db(endpoint: string, options?: DbOptions): Db;
    /**
     * ##### Overview (Astra-only)
     *
     * Spawns a new {@link AstraAdmin} instance using the given options to work with the DevOps API (for admin
     * work such as creating/managing databases).
     *
     * > **⚠️Warning:** This method is only available for Astra databases. If you try to use it with a non-Astra database, it will throw an error.
     *
     * @example
     * ```typescript
     * const admin1 = client.admin();
     * const admin2 = client.admin({ adminToken: '<stronger_token>' });
     *
     * const dbs = await admin1.listDatabases();
     * console.log(dbs);
     * ```
     *
     * ---
     *
     * ##### The options hierarchy
     *
     * The options for the {@link AstraAdmin} instance are a deep merge of the options for the {@link DataAPIClient} and the options for the {@link AstraAdmin} itself.
     *
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link AstraAdmin} instance.
     */
    admin(options?: AdminOptions): AstraAdmin;
    /**
     * ##### Overview
     *
     * Closes the client and disconnects all underlying connections. This should be called when the client is no longer
     * needed to free up resources.
     *
     * > **🚨Important:** The client will be no longer usable after this method is called.
     *
     * @example
     * ```ts
     * const client = new DataAPIClient(...);
     * await client.close();
     *
     * // Error: Can't make requests on a closed client
     * const coll = client.db(...).collection(...);
     * await coll.findOne();
     * ```
     * ---
     *
     * ##### Idempotency
     *
     * This method is idempotent and can be called multiple times without issue.
     *
     * ---
     *
     * ##### When to call this method
     *
     * For most users, this method is **not necessary to call**, as resources will be freed up when the server is shut down or the process is killed.
     *
     * However, it's useful in long-running processes or when you want to free up resources immediately.
     *
     * Think of it as using malloc or using a file descriptor. Freeing them isn't *strictly* necessary when the resources are used for the duration of the program, but it's there for when you need it.
     *
     * @returns A promise that resolves when the client has been closed.
     */
    close(): Promise<void>;
}

/**
 * Represents the different events that can be emitted/logged by the {@link DataAPIClient}.
 *
 * Equivalent to `DataAPIClientEventMap[keyof DataAPIClientEventMap]`.
 *
 * Please see {@link DataAPIClientEventMap} instead for more information on the different types of events.
 *
 * @see DataAPIClientEventMap
 *
 * @public
 */
export declare type DataAPIClientEvent = DataAPIClientEventMap[keyof DataAPIClientEventMap];

/**
 * #### Overview
 *
 * An enumeration of the events that may be emitted by the {@link DataAPIClient}, or any of its children classes, when logging is enabled.
 *
 * See {@link LoggingConfig} for more information on how to configure logging, and enable/disable specific events.
 *
 * ###### When to prefer events
 *
 * Events can be thought of as a "generic logging interface" for Data API & DevOps operations.
 *
 * Though the {@link LoggingConfig}, you can also enable logging to the console, but:
 * - You're forced to use stdout/stderr as outputs
 * - You can't programmatically interact with the log data
 * - You can't filter the logs
 *
 * {@link BaseClientEvent}s are a more flexible way to interact with the logs, allowing you to basically plug in, or
 * even build, your own logging system around them.
 *
 * And, of course, you're free to use both events and console logging in tandem, if you so choose.
 *
 * ###### Disclaimer
 *
 * **Note that these emit *real* commands, not any abstracted commands, such as `insertMany` or `updateMany`,
 * which may be split into multiple of those commands under the hood.**
 *
 * #### Event types
 *
 * There are two major categories of events emitted by the {@link DataAPIClient}:
 * - {@link CommandEvent}s - Events related to the execution of a command
 *   - i.e. `Db`, `Collection`, `Table` operations
 * - {@link AdminCommandEvent}s - Events related to the execution of an admin command
 *   - i.e. `AstraAdmin`, `DbAdmin` operations
 *
 * Every event may be enabled/disabled individually, independent of one another.
 *
 * View each command's documentation for more information on the specific events they emit.
 *
 * ###### Commands
 *
 * | Name                                       | Description                                                                                       | Default behavior if enabled   |
 * |--------------------------------------------|---------------------------------------------------------------------------------------------------|-------------------------------|
 * | `commandStarted`                           | Emitted when a command is started, before the initial HTTP request is made.                       | Emit as event; does not log   |
 * | `commandSucceeded`                         | Emitted when a command has succeeded (i.e. the status code is 200, and no `errors` are returned). | Emit as event; does not log   |
 * | `commandFailed`                            | Emitted when a command has errored (i.e. the status code is not 200, or `errors` are returned).   | Emit as event; logs to stderr |
 * | `commandWarnings`                          | Emitted when a command has warnings (i.e. when the `status.warnings` field is present).           | Emit as event; logs to stderr |
 *
 * ###### Admin commands
 *
 * | Name                                                              | Description                                                                                                   | Default behavior if enabled     |
 * |-------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------|---------------------------------|
 * | `adminCommandStarted`                                             | Emitted when an admin command is started, before the initial HTTP request is made.                            | Emits the event; logs to stderr |
 * | `adminCommandPolling`                                             | Emitted when a command is polling in a long-running operation (i.e. {@link AstraAdmin.createDatabase}).       | Emits the event; logs to stderr |
 * | `adminCommandSucceeded`                                           | Emitted when an admin command has succeeded, after any necessary polling (i.e. when an HTTP 200 is returned). | Emits the event; logs to stderr |
 * | `adminCommandFailed`                                              | Emitted when an admin command has failed (i.e. when an HTTP 4xx/5xx is returned, even if while polling).      | Emits the event; logs to stderr |
 * | `adminCommandWarnings`                                            | Emitted when an admin command has warnings (i.e. when the `status.warnings` field is present).                | Emits the event; logs to stderr |
 *
 * @see LoggingConfig
 * @see CommandEventMap
 * @see AdminCommandEventMap
 *
 * @public
 */
export declare type DataAPIClientEventMap = AdminCommandEventMap & CommandEventMap;

/**
 * The default options for the {@link DataAPIClient}. The Data API & DevOps specific options may be overridden
 * when spawning a new instance of their respective classes.
 *
 * @public
 */
export declare interface DataAPIClientOptions {
    /**
     * The configuration for logging events emitted by the {@link DataAPIClient}.
     *
     * This can be set at any level of the major class hierarchy, and will be inherited by all child classes.
     *
     * See {@link LoggingConfig} for *much* more information on configuration, outputs, and inheritance.
     *
     * **TL;DR: Set `logging: 'all'` for a sane default.**
     */
    logging?: LoggingConfig;
    /**
     * Sets the Data API "backend" that is being used (e.g. 'dse', 'hcd', 'cassandra', or 'other'). Defaults to 'astra'.
     *
     * Generally, the majority of operations stay the same between backends. However, authentication may differ, and
     * availability of admin operations does as well.
     *
     * - With Astra databases, you'll use an `'AstraCS:...'` token; for other backends, you'll generally want to use the
     *   {@link UsernamePasswordTokenProvider}, or, rarely, even create your own.
     *
     * - {@link AstraAdmin} is only available on Astra databases. {@link AstraDbAdmin} is also only available on Astra
     *   databases, but the {@link DataAPIDbAdmin} alternative is used for all other backends, albeit the expense of a
     *   couple extra features.
     *
     * - Some functions/properties may also not be available on non-Astra backends, such as {@link Db.id} or {@link Db.info}.
     *
     * @remarks
     * No error will be thrown if this is set incorrectly, but bugs may appear in your code, with some operations just
     * throwing errors and refusing to work properly.
     *
     * @defaultValue "astra"
     */
    environment?: DataAPIEnvironment;
    /**
     * The client-wide options related to http operations.
     *
     * Click on {@link HttpOptions} for more information.
     */
    httpOptions?: HttpOptions;
    /**
     * The default options when spawning a {@link Db} instance.
     */
    dbOptions?: RootDbOptions;
    /**
     * The default options when spawning an {@link AstraAdmin} instance.
     */
    adminOptions?: RootAdminOptions;
    /**
     * ##### Overview
     *
     * The caller information to send with requests, of the form `[name, version?]`, or an array of such.
     *
     * **Intended generally for integrations or frameworks that wrap the client.**
     *
     * The caller information is used to identify the client making requests to the server.
     *
     * It will be sent in the headers of the request as such:
     * ```
     * User-Agent: ...<name>/<version> astra-db-ts/<version>
     * ```
     *
     * If no caller information is provided, the client will simply be identified as `astra-db-ts/<version>`.
     *
     * **NB. If providing an array of callers, they should be ordered from most important to least important.**
     * @example
     * ```typescript
     * // 'my-app/1.0.0 astra-db-ts/1.0.0'
     * const client1 = new DataAPIClient('AstraCS:...', {
     *   caller: ['my-app', '1.0.0'],
     * });
     *
     * // 'my-app/1.0.0 my-other-app astra-db-ts/1.0.0'
     * const client2 = new DataAPIClient('AstraCS:...', {
     *   caller: [['my-app', '1.0.0'], ['my-other-app']],
     * });
     * ```
     */
    caller?: OneOrMany<Caller>;
    /**
     * ##### Overview
     *
     * The default timeout options for anything spawned by this {@link DataAPIClient} instance.
     *
     * See {@link TimeoutDescriptor} for much more information about timeouts.
     *
     * @example
     * ```ts
     * // The request timeout for all operations is set to 1000ms.
     * const client = new DataAPIClient('...', {
     *   timeoutDefaults: { requestTimeoutMs: 1000 },
     * });
     *
     * // The request timeout for all operations borne from this Db is set to 2000ms.
     * const db = client.db('...', {
     *   timeoutDefaults: { requestTimeoutMs: 2000 },
     * });
     * ```
     *
     * ##### Inheritance
     *
     * The timeout options are inherited by all child classes, and can be overridden at any level, including the individual method level.
     *
     * Individual-method-level overrides can vary in behavior depending on the method; again, see {@link TimeoutDescriptor}.
     *
     * ##### Defaults
     *
     * The default timeout options are as follows:
     * - `requestTimeoutMs`: 15000
     * - `generalMethodTimeoutMs`: 30000
     * - `collectionAdminTimeoutMs`: 60000
     * - `tableAdminTimeoutMs`: 30000
     * - `databaseAdminTimeoutMs`: 600000
     * - `keyspaceAdminTimeoutMs`: 30000
     *
     * @see TimeoutDescriptor
     */
    timeoutDefaults?: Partial<TimeoutDescriptor>;
    /**
     * ##### Overview
     *
     * Additional headers to include in the HTTP requests to both the Data API & the DevOps API.
     *
     * Headers specific to admin & non-admin related operations may be set in {@link DbOptions.additionalHeaders} and {@link AdminOptions.additionalHeaders}.
     *
     * ##### Disclaimer
     *
     * This is an "escape hatch", of sorts, for setting arbitrary headers which are not covered by other options.
     *
     * In the vast majority of cases, you may want to use other alternatives instead for setting appropriate headers, such as:
     * - Parameters which accept {@link TokenProvider}s
     * - Parameters such as
     *   - {@link CollectionOptions.embeddingApiKey}
     *   - {@link CollectionOptions.rerankingApiKey}
     *   - (or their {@link TableOptions} equivalents!)
     *
     * ##### Inheritance
     *
     * The additional headers set here will be inherited by, and may be overwritten by, the {@link DbOptions.additionalHeaders} and {@link AdminOptions.additionalHeaders} options.
     */
    additionalHeaders?: AdditionalHeaders;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - This property is no longer supported. Use `httpOptions` instead with the `fetch-h2` client enabled.
     */
    preferHttp2?: 'ERROR: This property is no longer supported. Use `httpOptions` instead with the `fetch-h2` client enabled';
}

/**
 * @public
 */
export declare type DataAPICodec<Class extends CollectionCodecClass & TableCodecClass> = InstanceType<Class>;

/**
 * ##### Overview
 *
 * Represents a `date` column for Data API tables,
 *
 * ##### Format
 *
 * `date`s consist simply of a year, a month, and a date.
 *
 * - The year may be either positive or negative, and must be at least four digits long (with leading padding zeros if necessary).
 *
 * - The month must be between 1-12 (not zero-indexed like JS dates), and must be two digits long.
 *
 * - The day must be a valid day for the given month, and starts at 1. It must also be two digits long. Feb 29th is allowed on leap years
 *
 * Together, the hypothetical pseudo-regex would be as such: `[+-]?YYY(Y+)-MM-DD`.
 *
 * **Note that the `DataAPIDate`'s parser is lenient on if the leading `+` is included or not.** For example, `+2000-01-01` is accepted, even if it is not technically valid; same with `10000-01-01`. A plus will be prepended in {@link DataAPIDate.toString} as necessary.
 *
 * ##### Creation
 *
 * There are a number of different ways to initialize a `DataAPIDate`:
 *
 * @example
 * ```ts
 * // Convert a native JS `Date` to a `DataAPIDate` (extracting only the local date)
 * new DataAPIDate(new Date('2004-09-14T12:00:00.000')) // '2004-09-14'
 *
 * // Parse a date given the above date-string format
 * new DataAPIDate('+2004-09-14')
 *
 * // Create a `DataAPIDate` from a year, a month, and a date
 * new DataAPIDate(2004, 9, 14)
 *
 * // Get the current date (using the local timezone)
 * DataAPIDate.now()
 *
 * // Get the current date (using UTC)
 * DataAPIDate.utcnow()
 *
 * // Create a `DataAPIDate` from a year and a valid day of the year
 * DataAPIDate.ofYearDay(2004, 258) // '2004-09-14'
 *
 * // Create a `DataAPIDate` given the number of days since the epoch (can be negative)
 * DataAPIDate.ofEpochDay(12675) // '2004-09-14'
 * ```
 *
 * ##### The `date` shorthand
 *
 * You may use the {@link date} shorthand function-object anywhere when creating new `DataAPIDate`s.
 *
 * @example
 * ```ts
 * // equiv. to `new DataAPIDate('2004-09-14')`
 * date('2004-09-14')
 *
 * // equiv. to `new DataAPIDate(2004, 9, 14)`
 * date(2004, 9, 14)
 *
 * // equiv. to `DataAPIDate.now()`
 * date.now()
 * ```
 *
 * See the official DataStax documentation for more information.
 *
 * @see date
 *
 * @public
 */
export declare class DataAPIDate implements TableCodec<typeof DataAPIDate> {
    /**
     * The year component of this `DataAPIDate`.
     *
     * May be negative.
     */
    readonly year: number;
    /**
     * The month component of this `DataAPIDate`.
     *
     * Must be between 1-12.
     */
    readonly month: number;
    /**
     * The date component of this `DataAPIDate`.
     *
     * Must be a valid day for the given month.
     */
    readonly date: number;
    /**
     * Errorful implementation of `$SerializeForCollection` for {@link TableCodec}
     *
     * Throws a human-readable error message warning that this datatype may not be used with collections without writing a custom ser/des codec.
     */
    [$SerializeForCollection](): void;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (string | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: string, ctx: TableDesCtx): readonly [0, (DataAPIDate | undefined)?];
    /**
     * ##### Overview
     *
     * Returns the current date in the local timezone.
     *
     * Equivalent to `new DataAPIDate(new Date())`.
     *
     * @example
     * ```ts
     * const now = date.now();
     * // or
     * const now = DataAPIDate.now()
     * ```
     *
     * @returns The current date in the local timezone
     */
    static now(this: void): DataAPIDate;
    /**
     * ##### Overview
     *
     * Returns the current date in UTC.
     *
     * Uses `Date.now()` under the hood.
     *
     * @example
     * ```ts
     * const now = date.utcnow();
     * // or
     * const now = DataAPIDate.utcnow()
     * ```
     *
     * @returns The current date in UTC
     */
    static utcnow(this: void): DataAPIDate;
    /**
     * ##### Overview
     *
     * Creates a `DataAPIDate` from the number of days since the epoch.
     *
     * The number may be negative, but must be an integer within the range `[-100_000_000, 100_000_000]`.
     *
     * @example
     * ```ts
     * DataAPIDate.ofEpochDay(0) // '1970-01-01'
     *
     * date.ofEpochDay(12675) // '2004-09-14'
     *
     * date.ofEpochDay(-1) // '1969-12-31'
     * ```
     *
     * @param epochDays - The number of days since the epoch (may be negative)
     *
     * @returns The date representing the given number of days since the epoch
     */
    static ofEpochDay(this: void, epochDays: number): DataAPIDate;
    /**
     * ##### Overview
     *
     * Creates a `DataAPIDate` from a year and a valid day of the year.
     *
     * The year may be negative.
     *
     * The day-of-year must be valid for the year, otherwise an exception will be thrown.
     *
     * @example
     * ```ts
     * DataAPIDate.ofYearDay(2004, 258) // 2004-09-14
     *
     * date.ofYearDay(2004, 1) // 2004-01-01
     *
     * date.ofYearDay(2004, 366) // 2004-12-31 (ok b/c 2004 is a leap year)
     * ```
     *
     * @param year - The year to use
     * @param dayOfYear - The day of the year to use (1-indexed)
     *
     * @returns The date representing the given year and day of the year
     */
    static ofYearDay(this: void, year: number, dayOfYear: number): DataAPIDate;
    /**
     * ##### Overview
     *
     * Converts a native JS `Date` to a `DataAPIDate` (extracting only the local date).
     *
     * @example
     * ```ts
     * new DataAPIDate(new Date('2004-09-14T12:00:00.000')) // '2004-09-14'
     *
     * date(new Date('-200004-09-14')) // '200004-09-14'
     * ```
     *
     * @param date - The `Date` object to convert
     */
    constructor(date: Date);
    /**
     * ##### Overview
     *
     * Parses a `DataAPIDate` from a string in the format `[+-]?YYY(Y+)-MM-DD`.
     *
     * See {@link DataAPIDate} for more info about the exact format.
     *
     * @example
     * ```ts
     * new DataAPIDate('2004-09-14') // '2004-09-14'
     *
     * date('-2004-09-14') // '-2004-09-14'
     *
     * date('+123456-09-14') // '123456-09-14'
     * ```
     *
     * @param date - The date to parse
     */
    constructor(date: string);
    /* Excluded from this release type: __constructor */
    /**
     * ##### Overview
     *
     * Creates a `DataAPIDate` from a year, a month, and a date.
     *
     * The year may be negative. The month and day are both 1-indexed.
     *
     * The date must be valid for the given month, otherwise an exception will be thrown.
     *
     * @example
     * ```ts
     * new DataAPIDate(2004, 9, 14) // '2004-09-14'
     *
     * date(-200004, 9, 14) // '-200004-09-14'
     * ```
     *
     * @param year - The year to use
     * @param month - The month to use (1-indexed)
     * @param date - The date to use (1-indexed)
     */
    constructor(year: number, month: number, date: number);
    /**
     * ##### Overview
     *
     * Converts this `DataAPIDate` to a `Date` object in the local timezone.
     *
     * If no `base` date/time is provided, the time component defaults to `00:00:00` (local time).
     *
     * If the `base` parameter is a `DataAPITime`, it is interpreted as being in the local timezone, not UTC.
     *
     * See {@link DataAPIDate.toDateUTC} for a UTC-based alternative to this method.
     *
     * @example
     * ```ts
     * // Assuming the local timezone is UTC-6 (CST) //
     *
     * // Local Time: '2000-01-01T12:00:00'
     * // UTC Time:   '2000-01-01T18:00:00Z'
     * date('2000-01-01').toDate(new Date('1970-01-01T12:00:00'));
     *
     * // Local Time: '2000-01-01T06:00:00'
     * // UTC Time:   '2000-01-01T12:00:00Z'
     * date('2000-01-01').toDate(new Date('1970-01-01T12:00:00Z'));
     *
     * // Local Time: '2000-01-01T12:00:00'
     * // UTC Time:   '2000-01-01T18:00:00Z'
     * date('2000-01-01').toDate(new DataAPITime('12:00:00'));
     *
     * // Local Time: '2000-01-01T00:00:00'
     * // UTC Time:   '2000-01-01T06:00:00Z'
     * date('2000-01-01').toDate();
     * ```
     *
     * @param base - The base date/time to use for the time component. If omitted, defaults to `00:00:00` (local time).
     *
     * @returns The `Date` object representing this `DataAPIDate` in the local timezone.
     *
     * @see DataAPIDate.toDateUTC
     */
    toDate(base?: Date | DataAPITime): Date;
    /**
     * ##### Overview
     *
     * Converts this `DataAPIDate` to a `Date` object in UTC.
     *
     * If no `base` date/time is provided, the time component defaults to `00:00:00` (UTC).
     *
     * If the `base` parameter is a `DataAPITime`, it is interpreted as being in the UTC timezone.
     *
     * See {@link DataAPIDate.toDate} for a local-time-based alternative to this method.
     *
     * @example
     * ```ts
     * // Assuming the local timezone is UTC-6 (CST) //
     *
     * // Local Time: '2000-01-01T12:00:00'
     * // UTC Time:   '2000-01-01T18:00:00Z'
     * date('2000-01-01').toDateUTC(new Date('1970-01-01T12:00:00'));
     *
     * // Local Time: '2000-01-01T06:00:00'
     * // UTC Time:   '2000-01-01T12:00:00Z'
     * date('2000-01-01').toDateUTC(new Date('1970-01-01T12:00:00Z'));
     *
     * // Local Time: '2000-01-01T12:00:00'
     * // UTC Time:   '2000-01-01T18:00:00Z'
     * date('2000-01-01').toDateUTC(new DataAPITime('12:00:00'));
     *
     * // Local Time: '1999-12-31T18:00:00'
     * // UTC Time:   '2000-01-01T00:00:00Z'
     * date('2000-01-01').toDateUTC();
     * ```
     *
     * @param base - The base time to use for the time component. If omitted, defaults to `00:00:00` UTC.
     *
     * @returns The `Date` object representing this `DataAPIDate` in UTC.
     *
     * @see DataAPIDate.toDate
     */
    toDateUTC(base?: Date | DataAPITime): Date;
    /**
     * ##### Overview
     *
     * Adds a {@link DataAPIDuration} or a duration string to this `DataAPIDate`.
     *
     * Duration strings will be parsed into a {@link DataAPIDuration} before being added.
     *
     * Durations may be negative, in which case the duration will be subtracted from this date.
     *
     * @example
     * ```ts
     * date('2000-01-01').plus('1y47h59m') // '2001-01-02'
     *
     * date('2000-01-01').plus('365d') // '2000-12-31'
     *
     * date('2000-01-01').plus('366d') // '2001-01-01'
     * ```
     *
     * @param duration - The duration to add to this `DataAPIDate`
     *
     * @returns A new `DataAPIDate` representing the result of adding the duration to this date
     */
    plus(duration: DataAPIDuration | string): DataAPIDate;
    /**
     * ##### Overview
     *
     * Returns the string representation of this `DataAPIDate`
     *
     * Note that a `+` is prepended to the year if it is greater than or equal to 10000.
     *
     * @example
     * ```ts
     * date('2004-09-14').toString() // '2004-09-14'
     *
     * date(-2004, 9, 14).toString() // '-2004-09-14'
     *
     * date('123456-01-01').toString() // '+123456-01-01'
     * ```
     *
     * @returns The string representation of this `DataAPIDate`
     */
    toString(): string;
    /**
     * ##### Overview
     *
     * Compares this `DataAPIDate` to another `DataAPIDate`
     *
     * @example
     * ```ts
     * date('2004-09-14').compare(date(2004, 9, 14)) // 0
     *
     * date('2004-09-14').compare(date(2004, 9, 15)) // -1
     *
     * date('2004-09-15').compare(date(2004, 9, 14)) // 1
     * ```
     *
     * @param other - The other `DataAPIDate` to compare to
     *
     * @returns `0` if the dates are equal, `-1` if this date is before the other, and `1` if this date is after the other
     */
    compare(other: DataAPIDate): -1 | 0 | 1;
    /**
     * ##### Overview
     *
     * Checks if this `DataAPIDate` is equal to another `DataAPIDate`
     *
     * @example
     * ```ts
     * date('2004-09-14').equals(date(2004, 9, 14)) // true
     *
     * date('2004-09-14').equals(date(2004, 9, 15)) // false
     *
     * date('2004-09-15').equals(date(2004, 9, 14)) // false
     * ```
     *
     * @param other - The other `DataAPIDate` to compare to
     *
     * @returns `true` if the dates are equal, and `false` otherwise
     */
    equals(other: DataAPIDate): boolean;
}

/**
 * An administrative class for managing non-Astra databases, including creating, listing, and deleting keyspaces.
 *
 * **Shouldn't be instantiated directly; use {@link Db.admin} to obtain an instance of this class.**
 *
 * **Note that the `environment` parameter MUST match the one used in the `DataAPIClient` options.**
 *
 * @example
 * ```typescript
 * const client = new DataAPIClient('*TOKEN*');
 *
 * // Create an admin instance through a Db
 * const db = client.db('*ENDPOINT*');
 * const dbAdmin1 = db.admin({ environment: 'dse' });
 * const dbAdmin2 = db.admin({ environment: 'dse', adminToken: 'stronger-token' });
 *
 * await admin1.createKeyspace({
 *   replication: {
 *     class: 'NetworkTopologyStrategy',
 *     datacenter1: 3,
 *     datacenter2: 2,
 *   },
 * });
 *
 * const keyspaces = await admin1.listKeyspaces();
 * console.log(keyspaces);
 * ```
 *
 * @see Db.admin
 * @see DataAPIDbAdmin.dbAdmin
 *
 * @public
 */
export declare class DataAPIDbAdmin extends DbAdmin {    /* Excluded from this release type: __constructor */
    /**
     * Gets the underlying `Db` object. The options for the db were set when the `DataAPIDbAdmin` instance, or whatever
     * spawned it, was created.
     *
     * @example
     * ```typescript
     * const dbAdmin = client.admin().dbAdmin('<endpoint>', {
     *   keyspace: 'my_keyspace',
     *   useHttp2: false,
     * });
     *
     * const db = dbAdmin.db();
     * console.log(db.keyspace);
     * ```
     *
     * @returns The underlying `Db` object.
     */
    db(): Db;
    /**
     * Lists the keyspaces in the database.
     *
     * The first element in the returned array is the default keyspace of the database, and the rest are additional
     * keyspaces in no particular order.
     *
     * @example
     * ```typescript
     * const keyspaces = await dbAdmin.listKeyspaces();
     *
     * // ['default_keyspace', 'my_other_keyspace']
     * console.log(keyspaces);
     * ```
     *
     * @returns A promise that resolves to list of all the keyspaces in the database.
     */
    listKeyspaces(options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<string[]>;
    /**
     * Creates a new, additional, keyspace for this database.
     *
     * **NB. The operation will always wait for the operation to complete, regardless of the {@link AstraAdminBlockingOptions}. Expect it to take roughly 8-10 seconds.**
     *
     * @example
     * ```typescript
     * await dbAdmin.createKeyspace('my_keyspace');
     *
     * await dbAdmin.createKeyspace('my_keyspace', {
     *   replication: {
     *     class: 'SimpleStrategy',
     *     replicationFactor: 3,
     *   },
     * });
     *
     * await dbAdmin.createKeyspace('my_keyspace', {
     *   replication: {
     *     class: 'NetworkTopologyStrategy',
     *     datacenter1: 3,
     *     datacenter2: 2,
     *   },
     * });
     * ```
     *
     * @param keyspace - The name of the new keyspace.
     * @param options - The options for the timeout & replication behavior of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     */
    createKeyspace(keyspace: string, options?: CreateDataAPIKeyspaceOptions): Promise<void>;
    /**
     * Drops a keyspace from this database.
     *
     * **NB. The operation will always wait for the operation to complete, regardless of the {@link AstraAdminBlockingOptions}. Expect it to take roughly 8-10 seconds.**
     *
     * @example
     * ```typescript
     * // ['default_keyspace', 'my_other_keyspace']
     * console.log(await dbAdmin.listKeyspaces());
     *
     * await dbAdmin.dropKeyspace('my_other_keyspace');
     *
     * // ['default_keyspace', 'my_other_keyspace']
     * console.log(await dbAdmin.listKeyspaces());
     * ```
     *
     * @param keyspace - The name of the keyspace to drop.
     * @param options - The options for the timeout of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     */
    dropKeyspace(keyspace: string, options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<void>;
    get _httpClient(): OpaqueHttpClient;
    /* Excluded from this release type: _getDataAPIHttpClient */
}

/**
 * #### Overview
 *
 * Represents a `duration` column for Data API tables.
 *
 * Internally represented as a number of months, days, and nanoseconds (units which are not directly convertible to each other).
 *
 * #### Format
 *
 * The duration may be one of four different formats:
 *
 * ###### Standard duration format
 *
 * Matches `-?(<number><unit>)+`, where the unit is one of:
 * - `y` (years; 12 months)
 * - `mo` (months)
 * - `w` (weeks; 7 days)
 * - `d` (days)
 * - `h` (hours; 3,600,000,000,000 nanoseconds)
 * - `m` (minutes; 60,000,000,000 nanoseconds)
 * - `s` (seconds; 1,000,000,000 nanoseconds)
 * - `ms` (milliseconds; 1,000,000 nanoseconds)
 * - `us` or `µs` (microseconds; 1,000 nanoseconds)
 * - `ns` (nanoseconds)
 *
 * At least one of the above units must be present, and they must be in the order shown above.
 *
 * Units in this format are case-insensitive.
 *
 * @example
 * ```ts
 * duration('1y2mo3w4d5h6m7s8ms9us10ns');
 * duration('-2w');
 * duration('0s');
 * ```
 *
 * ###### ISO 8601 duration format
 *
 * Matches `-?P<date>[T<time>]?`, where `<date>` is `(<number><date_unit>)*` and `<time>` is `(<number><time_unit>)+`.
 *
 * `<date_unit>` is one of:
 * - `Y` (years)
 * - `M` (months)
 * - `D` (days)
 *
 * `<time_unit>` is one of:
 * - `H` (hours)
 * - `M` (minutes)
 * - `S` (seconds)
 *
 * The P delimiter is required, and the T delimiter is only required if `<time>` is present.
 *
 * Units (case-sensitive) must appear in the order shown above.
 *
 * Milli/micro/nanoseconds may be provided as a fractional component of the seconds unit.
 *
 * @example
 * ```ts
 * duration('P1Y2M3DT4H5M6.007S');
 * duration('-P7D');
 * duration('PT0S');
 * ```
 *
 * ###### ISO 8601 week duration format
 *
 * Matches `-?P<weeks>W` exactly. No trailing T, or any other units, are allowed in this (case-sensitive) format.
 *
 * @example
 * ```ts
 * duration('P2W');
 * duration('-P2W');
 * ```
 *
 * ###### ISO 8601 alternate duration format
 *
 * Matches `-?P<YYYY>-<MM>-<DD>T<hh>:<mm>:<ss>` exactly.
 *
 * The date and time components must be in the order, length, and case shown, and the P & T delimiters are required.
 *
 * @example
 * ```ts
 * duration('-P0001-02-03T04:05:06');
 * ```
 *
 * #### Creation
 *
 * There are a few different ways to initialize a new `DataAPIDuration`:
 *
 * @example
 * ```ts
 * // Parse a duration given one of the above duration-string formats
 * new DataAPIDuration('1y2mo3w4d5h6m7s8ms9us10ns');
 * new DataAPIDuration('P1Y2M3DT4H5M6.007S');
 * new DataAPIDuration('-P2W');
 * new DataAPIDuration('P0001-02-03T04:05:06');
 *
 * // Create a `DataAPIDuration` from months, days, and nanoseconds
 * new DataAPIDuration(0, 10, 1000 * 60 * 60 * 24 * 3).negate();
 *
 * // Create a `DataAPIDuration` using the builder class
 * DataAPIDuration.builder()
 *   .addYears(1)
 *   .addDays(3)
 *   .addSeconds(5)
 *   .negate()
 *   .build();
 * ```
 *
 * #### The `duration` shorthand
 *
 * You may use the {@link duration} shorthand function-object anywhere when creating new `DataAPIDuration`s.
 *
 * @example
 * ```ts
 * // equiv. to `new DataAPIDuration('-2w')`
 * duration('-2w')
 *
 * // equiv. to `new DataAPIDuration(2, 1, 0)`
 * duration(12, 1, 0)
 *
 * // equiv. to `DataAPIDuration.builder().build()`
 * duration.builder().build()
 * ```
 *
 * See the official DataStax documentation for more information.
 *
 * @see duration
 * @see DataAPIDurationBuilder
 *
 * @public
 */
export declare class DataAPIDuration implements TableCodec<typeof DataAPIDuration> {
    /**
     * Nanoseconds per hour.
     */
    static readonly NS_PER_HOUR = 3600000000000n;
    /**
     * Nanoseconds per minute.
     */
    static readonly NS_PER_MIN = 60000000000n;
    /**
     * Nanoseconds per second.
     */
    static readonly NS_PER_SEC = 1000000000n;
    /**
     * Nanoseconds per millisecond.
     */
    static readonly NS_PER_MS = 1000000n;
    /**
     * Nanoseconds per microsecond.
     */
    static readonly NS_PER_US = 1000n;
    /**
     * The months component of this `DataAPIDuration`.
     *
     * May be negative if and only if the other components are also negative.
     */
    readonly months: number;
    /**
     * The days component of this `DataAPIDuration`.
     *
     * May be negative if and only if the other components are also negative.
     */
    readonly days: number;
    /**
     * The nanoseconds component of this `DataAPIDuration`.
     *
     * May be negative if and only if the other components are also negative.
     */
    readonly nanoseconds: bigint;
    /**
     * Errorful implementation of `$SerializeForCollection` for {@link TableCodec}
     *
     * Throws a human-readable error message warning that this datatype may not be used with collections without writing a custom ser/des codec.
     */
    [$SerializeForCollection](): void;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (string | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: any, ctx: TableDesCtx): readonly [0, (DataAPIDuration | undefined)?];
    /**
     * ##### Overview
     *
     * Helpful utility for manually creating new `DataAPIDuration` instances.
     *
     * Contains builder methods for incrementally adding duration components, and negating the final result.
     *
     * ##### Usage
     *
     * You may call each `.add*()` method any number of times, in any order, before calling `build`.
     *
     * The `.negate(sign?)` method may be called at any time to negate the final result.
     * - You may pass a boolean to `.negate(sign?)` to definitively set the sign
     * - Otherwise, the sign will be toggled.
     *
     * A `base` duration may be provided to initialize the builder with its components and its sign.
     *
     * @example
     * ```ts
     * const base = duration('1y');
     *
     * // '-1y3d15h'
     * const span = duration.builder(base)
     *   .addHours(10)
     *   .addDays(3)
     *   .addHours(5)
     *   .negate()
     *   .build();
     * ```
     *
     * @param base - The base `DataAPIDuration` to initialize the builder with, if any
     *
     * @see DataAPIDurationBuilder
     */
    static builder(this: void, base?: DataAPIDuration): DataAPIDurationBuilder;
    /**
     * ##### Overview
     *
     * Parses a `DataAPIDuration` from a string in one of the supported formats.
     *
     * See {@link DataAPIDuration} for more info about the supported formats.
     *
     * @example
     * ```ts
     * new DataAPIDuration('1y2mo3w4d5h6m7s8ms9us10ns');
     *
     * new DataAPIDuration('P1Y2M3DT4H5M6.007S');
     *
     * duration('-2w');
     *
     * duration('P0001-02-03T04:05:06');
     * ```
     *
     * @param duration - The duration to parse
     */
    constructor(duration: string);
    /* Excluded from this release type: __constructor */
    /**
     * ##### Overview
     *
     * Creates a `DataAPIDuration` from the given months, days, and nanoseconds.
     *
     * Either all parts must be positive, or all parts must be negative, to represent the duration's sign.
     *
     * The parts must be integers in the following ranges:
     * - `months` and `days` must be less than or equal to `2147483647` *(2^31 - 1)*
     * - `nanoseconds` must be less than or equal to `9223372036854775807` *(2^31 - 1)*
     *
     * @example
     * ```ts
     * new DataAPIDuration(2, 1, 0);
     *
     * duration(0, 10, 1000 * 60 * 60 * 24 * 3).negate();
     * ```
     *
     * @param months - The months component of the duration
     * @param days - The days component of the duration
     * @param nanoseconds - The nanoseconds component of the duration
     */
    constructor(months: number, days: number, nanoseconds: number | bigint);
    /**
     * ##### Overview
     *
     * Checks if this `DataAPIDuration` is equal to another `DataAPIDuration`.
     *
     * Two durations are only equal if all of their individuals components are equal to each other.
     *
     * @example
     * ```ts
     * duration('1y2d').equals(duration('P1Y2D')) // true
     *
     * duration('-7d').equals(duration('-P1W')) // true
     *
     * duration('1y').equals(duration('12mo')) // true
     *
     * duration('1y').equals(duration('365d')) // false
     * ```
     *
     * @param other - The other `DataAPIDuration` to compare to
     *
     * @returns `true` if the durations are exactly equal, or `false` otherwise
     */
    equals(other: DataAPIDuration): boolean;
    /**
     * ##### Overview
     *
     * Checks if this `DataAPIDuration` has day precision—that is, if the nanoseconds component is zero.
     *
     * This means that no hours, minutes, seconds, milliseconds, microseconds, or nanoseconds are present.
     *
     * @returns `true` if this `DataAPIDuration` has day precision, or `false` otherwise
     */
    hasDayPrecision(): boolean;
    /**
     * ##### Overview
     *
     * Checks if this `DataAPIDuration` has millisecond precision—that is, if the nanoseconds component is a multiple of 1,000,000.
     *
     * This means that no microseconds or nanoseconds are present.
     *
     * If `true`, it entails that {@link DataAPIDuration.nanoseconds} & {@link DataAPIDuration.toMicros} may be safely cast to `number`.
     *
     * @returns `true` if this `DataAPIDuration` has millisecond precision, or `false` otherwise
     */
    hasMillisecondPrecision(): boolean;
    /**
     * ##### Overview
     *
     * Checks if the sign of this `DataAPIDuration` is negative.
     *
     * @returns `true` if the sign of this `DataAPIDuration` is negative, or `false` otherwise
     */
    isNegative(): boolean;
    /**
     * ##### Overview
     *
     * Checks if this `DataAPIDuration` is zero—that is, if all components are zero.
     *
     * @returns `true` if this `DataAPIDuration` is zero, or `false` otherwise
     */
    isZero(): boolean;
    /**
     * ##### Overview
     *
     * Returns a new `DataAPIDuration` that is the sum of this `DataAPIDuration` and another `DataAPIDuration`.
     *
     * Each component of the other `DataAPIDuration` is added to the corresponding component of this `DataAPIDuration`.
     *
     * **However, if the signs of the two durations differ, `null` is returned.** A positive duration cannot be added to a negative duration, and vice versa.
     *
     * @example
     * ```ts
     * duration('1y').plus(duration('1y')) // '2y'
     *
     * duration('1y').plus(duration('1mo1s')) // '1y1mo1s'
     *
     * duration('1y').plus(duration('-1mo').abs()) // '1y1mo'
     *
     * duration('1y').plus(duration('-1mo')) // null
     * ```
     *
     * Note that this may lead to an error being thrown if any of the individual components exceed their maximum values.
     *
     * @param other - The other `DataAPIDuration` to add to this `DataAPIDuration`
     *
     * @returns A new `DataAPIDuration` that is the sum of this `DataAPIDuration` and the other `DataAPIDuration`, or `null` if the signs differ
     */
    plus(other: DataAPIDuration): DataAPIDuration | null;
    /**
     * ##### Overview
     *
     * Flips the sign of this `DataAPIDuration`.
     *
     * @example
     * ```ts
     * duration('1y').negate() // '-1y'
     *
     * duration('-1y').negate() // '1y'
     * ```
     *
     * @returns A new `DataAPIDuration` with the sign flipped
     */
    negate(): DataAPIDuration;
    /**
     * ##### Overview
     *
     * Makes this `DataAPIDuration` unconditionally positive.
     *
     * @example
     * ```ts
     * duration('1y').abs() // '1y'
     *
     * duration('-1y').abs() // '1y'
     * ```
     *
     * @returns A new `DataAPIDuration` with the sign flipped
     */
    abs(): DataAPIDuration;
    /**
     * ##### Overview
     *
     * Returns the number of years in this `DataAPIDuration`, calculated solely from the `months` component.
     *
     * **Note: this does _not_ factor in the `days` or `nanoseconds` components.**
     *
     * Equivalent to `Math.floor(duration.months / 12)`.
     *
     * @example
     * ```ts
     * duration('1y15mo').toYears() // 2
     *
     * duration('-1y15mo').toYears() // -2
     *
     * duration('1y800d').toYears() // 1
     * ```
     *
     * @returns The number of years in this `DataAPIDuration` derived from the `months` component
     */
    toYears(): number;
    /**
     * ##### Overview
     *
     * Returns the number of hours in this `DataAPIDuration`, calculated solely from the `nanoseconds` component.
     *
     * **Note: this does _not_ factor in the `months` or `days` components.**
     *
     * Equivalent to `Number(duration.nanoseconds / 3_600_000_000_000)`.
     *
     * @example
     * ```ts
     * duration('10m').toHours() // 0
     *
     * duration('-50h150m').toHours() // -52
     *
     * duration('1y15mo1h').toHours() // 1
     *
     * duration('500d').toHours() // 0
     * ```
     *
     * @returns The number of hours in this `DataAPIDuration` derived from the `nanoseconds` component
     */
    toHours(): number;
    /**
     * ##### Overview
     *
     * Returns the number of minutes in this `DataAPIDuration`, calculated solely from the `nanoseconds` component.
     *
     * **Note: this does _not_ factor in the `months` or `days` components.**
     *
     * Equivalent to `Number(duration.nanoseconds / 60_000_000_000)`.
     *
     * @example
     * ```ts
     * duration('10ms').toMinutes() // 0
     *
     * duration('2y50h150m').toMinutes() // 3150
     *
     * duration('-1y15mo1h').toMinutes() // -60
     * ```
     *
     * @returns The number of minutes in this `DataAPIDuration` derived from the `nanoseconds` component
     */
    toMinutes(): number;
    /**
     * ##### Overview
     *
     * Returns the number of seconds in this `DataAPIDuration`, calculated solely from the `nanoseconds` component.
     *
     * **Note: this does _not_ factor in the `months` or `days` components.**
     *
     * Equivalent to `Number(duration.nanoseconds / 1_000_000_000)`.
     *
     * @example
     * ```ts
     * duration('10ns').toSeconds() // 0
     *
     * duration('1y50h150m').toSeconds() // 189000
     *
     * duration('-1y15mo1h').toSeconds() // -3600
     * ```
     *
     * @returns The number of seconds in this `DataAPIDuration` derived from the `nanoseconds` component
     */
    toSeconds(): number;
    /**
     * ##### Overview
     *
     * Returns the number of milliseconds in this `DataAPIDuration`, calculated solely from the `nanoseconds` component.
     *
     * **Note: this does _not_ factor in the `months` or `days` components.**
     *
     * Equivalent to `Number(duration.nanoseconds / 1_000_000)`.
     *
     * @example
     * ```ts
     * duration('10ns').toMillis() // 0
     *
     * duration('1y50h150m').toMillis() // 189000000
     *
     * duration('-1y15mo1h').toMillis() // -3600000
     * ```
     *
     * @returns The number of milliseconds in this `DataAPIDuration` derived from the `nanoseconds` component
     */
    toMillis(): number;
    /**
     * ##### Overview
     *
     * Returns the number of microseconds in this `DataAPIDuration`, calculated solely from the `nanoseconds` component.
     *
     * **Note: this does _not_ factor in the `months` or `days` components.**
     *
     * Equivalent to `Number(duration.nanoseconds / 1_000)`.
     *
     * @example
     * ```ts
     * duration('1y50us').toMicros() // 50n
     *
     * duration('1y50ns').toMicros() // 0n
     *
     * duration('1h50ns').toMicros() // 3600000000n
     * ```
     *
     * @returns The number of microseconds in this `DataAPIDuration` derived from the `nanoseconds` component
     */
    toMicros(): bigint;
    /**
     * ##### Overview
     *
     * Returns the human-friendly string representation of this `DataAPIDuration`
     *
     * @example
     * ```ts
     * duration('15mo').toString() // '1y3mo'
     *
     * duration('-5ms10000us').toString() // '-15ms'
     * ```
     *
     * @returns The string representation of this `DataAPIDuration`
     */
    toString(): string;
}

/**
 * ##### Overview
 *
 * A helpful builder class for manually creating new `DataAPIDuration` instances.
 *
 * Provides methods for incrementally adding duration components, and negating the final result.
 *
 * Should be instantiated using {@link DataAPIDuration.builder}/{@link duration.builder}.
 *
 * ##### Usage
 *
 * You may call each `.add*()` method any number of times, in any order, before calling `build`.
 *
 * The `.negate(sign?)` method may be called at any time to negate the final result.
 * - You may pass a boolean to `.negate(sign?)` to definitively set the sign
 * - Otherwise, the sign will be toggled.
 *
 * A `base` duration may be provided to initialize the builder with its components and its sign.
 *
 * @example
 * ```ts
 * const base = duration('1y');
 *
 * // '-1y3d15h'
 * const span = duration.builder(base)
 *  .addHours(10)
 *  .addDays(3)
 *  .addHours(5)
 *  .negate()
 *  .build();
 * ```
 *
 * @see DataAPIDuration
 *
 * @public
 */
export declare class DataAPIDurationBuilder {
    private readonly _validateOrder;
    private _months;
    private _days;
    private _nanoseconds;
    private _index;
    private _negative;
    /* Excluded from this release type: __constructor */
    /**
     * ##### Overview
     *
     * Negates the final result of this `DataAPIDurationBuilder`.
     *
     * A boolean parameter may be provided to force the sign to be negative/positive—otherwise, it defaults to toggling the sign.
     *
     * **Note that negation does not take place until the `.build()` method is called.** It simply marks the final result as to-be-negated or not.
     *
     * @example
     * ```ts
     * // '-10h'
     * const span = duration.builder()
     *  .addHours(10)
     *  .negate()
     *  .build();
     *
     * // '10h'
     * const span = duration.builder()
     *  .addHours(10)
     *  .negate(true)
     *  .negate(false)
     *  .build();
     * ```
     *
     * @param negative - Whether to set the sign to negative; defaults to the opposite of the current sign
     *
     * @returns The mutated builder instance
     */
    negate(negative?: boolean): this;
    /**
     * ##### Overview
     *
     * Adds the given number of years to this `DataAPIDurationBuilder`.
     *
     * Years are converted to months before being added (1 year = 12 months).
     *
     * If the total number of months exceeds `2147483647` *(2^31 - 1)*, a `RangeError` is thrown.
     *
     * The years may be negative to perform a subtraction operation, but if the total number of months becomes negative, a `RangeError` also is thrown. To negate the final result, use the `.negate()` method.
     *
     * @example
     * ```ts
     * // '2y'
     * const span = duration.builder()
     *  .addYears(1)
     *  .addYears(1)
     *  .build();
     *
     * // true
     * duration('24mo').equals(span)
     * ```
     *
     * @param years - The number of years to add
     */
    addYears(years: number): this;
    /**
     * ##### Overview
     *
     * Adds the given number of months to this `DataAPIDurationBuilder`.
     *
     * If the total number of months exceeds `2147483647` *(2^31 - 1)*, a `RangeError` is thrown.
     *
     * The months may be negative to perform a subtraction operation, but if the total number of months becomes negative, a `RangeError` also is thrown. To negate the final result, use the `.negate()` method.
     *
     * @example
     * ```ts
     * // '24mo'
     * const span = duration.builder()
     *  .addMonths(24)
     *  .build();
     *
     * // true
     * duration('2y').equals(span)
     * ```
     *
     * @param months - The number of months to add
     *
     * @returns The mutated builder instance
     */
    addMonths(months: number): this;
    /**
     * ##### Overview
     *
     * Adds the given number of weeks to this `DataAPIDurationBuilder`.
     *
     * Weeks are converted to days before being added (1 week = 7 days).
     *
     * If the total number of days exceeds `2147483647` *(2^31 - 1)*, a `RangeError` is thrown.
     *
     * The weeks may be negative to perform a subtraction operation, but if the total number of days becomes negative, a `RangeError` also is thrown. To negate the final result, use the `.negate()` method.
     *
     * @example
     * ```ts
     * // '2w'
     * const span = duration.builder()
     *  .addWeeks(2)
     *  .build();
     *
     * // true
     * duration('14d').equals(span)
     * ```
     *
     * @param weeks - The number of weeks to add
     *
     * @returns The mutated builder instance
     */
    addWeeks(weeks: number): this;
    /**
     * ##### Overview
     *
     * Adds the given number of days to this `DataAPIDurationBuilder`.
     *
     * If the total number of days exceeds `2147483647` *(2^31 - 1)*, a `RangeError` is thrown.
     *
     * The days may be negative to perform a subtraction operation, but if the total number of days becomes negative, a `RangeError` also is thrown. To negate the final result, use the `.negate()` method.
     *
     * @example
     * ```ts
     * // '14d'
     * const span = duration.builder()
     *  .addDays(14)
     *  .build();
     *
     * // true
     * duration('2w').equals(span)
     * ```
     *
     * @param days - The number of days to add
     *
     * @returns The mutated builder instance
     */
    addDays(days: number): this;
    /**
     * ##### Overview
     *
     * Adds the given number of hours to this `DataAPIDurationBuilder`.
     *
     * Hours are converted to nanoseconds before being added (1 hour = 3,600,000,000,000 nanoseconds).
     *
     * If the total number of nanoseconds exceeds `9223372036854775807n` *(2^63 - 1)*, a `RangeError` is thrown.
     *
     * The hours may be negative to perform a subtraction operation, but if the total number of nanoseconds becomes negative, a `RangeError` also is thrown. To negate the final result, use the `.negate()` method.
     *
     * @example
     * ```ts
     * // '10h'
     * const span = duration.builder()
     *  .addHours(10)
     *  .build();
     *
     * // true
     * duration('600m').equals(span)
     * ```
     *
     * @param hours - The number of hours to add
     *
     * @returns The mutated builder instance
     */
    addHours(hours: number | bigint): this;
    /**
     * ##### Overview
     *
     * Adds the given number of minutes to this `DataAPIDurationBuilder`.
     *
     * Minutes are converted to nanoseconds before being added (1 minute = 60,000,000,000 nanoseconds).
     *
     * If the total number of nanoseconds exceeds `9223372036854775807n` *(2^63 - 1)*, a `RangeError` is thrown.
     *
     * The minutes may be negative to perform a subtraction operation, but if the total number of nanoseconds becomes negative, a `RangeError` also is thrown. To negate the final result, use the `.negate()` method.
     *
     * @example
     * ```ts
     * // '10m'
     * const span = duration.builder()
     *  .addMinutes(10)
     *  .build();
     *
     * // true
     * duration('600s').equals(span)
     * ```
     *
     * @param minutes - The number of minutes to add
     *
     * @returns The mutated builder instance
     */
    addMinutes(minutes: number | bigint): this;
    /**
     * ##### Overview
     *
     * Adds the given number of seconds to this `DataAPIDurationBuilder`.
     *
     * Seconds are converted to nanoseconds before being added (1 second = 1,000,000,000 nanoseconds).
     *
     * If the total number of nanoseconds exceeds `9223372036854775807n` *(2^63 - 1)*, a `RangeError` is thrown.
     *
     * The seconds may be negative to perform a subtraction operation, but if the total number of nanoseconds becomes negative, a `RangeError` also is thrown. To negate the final result, use the `.negate()` method.
     *
     * @example
     * ```ts
     * // '10s'
     * const span = duration.builder()
     *  .addSeconds(10)
     *  .build();
     *
     * // true
     * duration('10000ms').equals(span)
     * ```
     *
     * @param seconds - The number of seconds to add
     *
     * @returns The mutated builder instance
     */
    addSeconds(seconds: number | bigint): this;
    /**
     * ##### Overview
     *
     * Adds the given number of milliseconds to this `DataAPIDurationBuilder`.
     *
     * Milliseconds are converted to nanoseconds before being added (1 millisecond = 1,000,000 nanoseconds).
     *
     * If the total number of nanoseconds exceeds `9223372036854775807n` *(2^63 - 1)*, a `RangeError` is thrown.
     *
     * The milliseconds may be negative to perform a subtraction operation, but if the total number of nanoseconds becomes negative, a `RangeError` also is thrown. To negate the final result, use the `.negate()` method.
     *
     * @example
     * ```ts
     * // '1000ms'
     * const span = duration.builder()
     *  .addMillis(1000)
     *  .build();
     *
     * // true
     * duration('1s').equals(span)
     * ```
     *
     * @param milliseconds - The number of milliseconds to add
     *
     * @returns The mutated builder instance
     */
    addMillis(milliseconds: number | bigint): this;
    /**
     * ##### Overview
     *
     * Adds the given number of microseconds to this `DataAPIDurationBuilder`.
     *
     * Microseconds are converted to nanoseconds before being added (1 microsecond = 1,000 nanoseconds).
     *
     * If the total number of nanoseconds exceeds `9223372036854775807n` *(2^63 - 1)*, a `RangeError` is thrown.
     *
     * The microseconds may be negative to perform a subtraction operation, but if the total number of nanoseconds becomes negative, a `RangeError` also is thrown. To negate the final result, use the `.negate()` method.
     *
     * @example
     * ```ts
     * // '1000us'
     * const span = duration.builder()
     *  .addMicros(1000)
     *  .build();
     *
     * // true
     * duration('1ms').equals(span)
     * ```
     *
     * @returns The mutated builder instance
     *
     * @param microseconds - The number of microseconds to add
     */
    addMicros(microseconds: number | bigint): this;
    /**
     * ##### Overview
     *
     * Adds the given number of nanoseconds to this `DataAPIDurationBuilder`.
     *
     * If the total number of nanoseconds exceeds `9223372036854775807n` *(2^63 - 1)*, a `RangeError` is thrown.
     *
     * The nanoseconds may be negative to perform a subtraction operation, but if the total number of nanoseconds becomes negative, a `RangeError` also is thrown. To negate the final result, use the `.negate()` method.
     *
     * @example
     * ```ts
     * // '1000ns'
     * const span = duration.builder()
     *  .addNanos(1000)
     *  .build();
     *
     * // true
     * duration('1us').equals(span)
     * ```
     *
     * @param nanoseconds - The number of nanoseconds to add
     *
     * @returns The mutated builder instance
     */
    addNanos(nanoseconds: number | bigint): this;
    /**
     * ##### Overview
     *
     * Builds a new `DataAPIDuration` instance from the components added to this `DataAPIDurationBuilder`.
     *
     * May be called at any time to retrieve the current state of the builder as a `DataAPIDuration`.
     *
     * @example
     * ```ts
     * const builder = duration
     *   .builder()
     *   .addYears(1);
     *
     * // '1y'
     * const span1 = builder.build().toString();
     *
     * builder
     *   .negate()
     *   .addMonths(1);
     *
     * // '-1y1mo'
     * const span2 = builder.build().toString();
     * ```
     *
     * @returns A new `DataAPIDuration` instance derived from this `DataAPIDurationBuilder`
     */
    build(): DataAPIDuration;
    /**
     * ##### Overview
     *
     * Clones this `DataAPIDurationBuilder` instance.
     *
     * The cloned instance will have the same components as this one, but will be a separate object.
     *
     * ```ts
     * const builder = duration.builder().addYears(1);
     * const clone = builder.clone();
     * builder.addMonths(1);
     *
     * // '1y'
     * clone.build().toString();
     *
     * // '1y1mo'
     * builder.build().toString();
     * ```
     *
     * @returns A new `DataAPIDurationBuilder` instance with the same components as this one
     */
    clone(): DataAPIDurationBuilder;
    /* Excluded from this release type: raw */
    private _validateMonths;
    private _validateDays;
    private _validateNanos;
    private _validateIndex;
}

/**
 * All the available Data API backends the Typescript client recognizes.
 *
 * If using a non-Astra database as the backend, the `environment` option should be set in the `DataAPIClient` options,
 * as well as in the `db.admin()` options.
 *
 * @public
 */
export declare type DataAPIEnvironment = typeof DataAPIEnvironments[number];

/**
 * All the available Data API backends the Typescript client recognizes.
 *
 * If using a non-Astra database as the backend, the `environment` option should be set in the `DataAPIClient` options,
 * as well as in the `db.admin()` options.
 *
 * @public
 */
export declare const DataAPIEnvironments: readonly ["astra", "dse", "hcd", "cassandra", "other"];

/**
 * ##### Overview
 *
 * An abstract class representing some exception that occurred related to the Data API. This is the base class for all
 * Data API errors, and will never be thrown directly.
 *
 * This is mainly useful for `instanceof` checks in `catch` blocks.
 *
 * > **⚠️Note:** While HTTP errors and timeouts may be represented by subclasses of this type, certain errors, such as connection errors, {@link TypeError}s, etc. may be thrown by the underlying code directly.
 *
 * @public
 */
export declare abstract class DataAPIError extends Error {
    /* Excluded from this release type: withTransientDupesForEvents */
}

/**
 * ##### Overview
 *
 * An object representing a single "soft" (2XX) error returned from the Data API, typically with an error code and a
 * human-readable message. An API request may return with an HTTP 200 success error code, but contain a nonzero
 * amount of these, such as for duplicate inserts, or invalid IDs.
 *
 * ##### Disclaimer
 *
 * > **🚨Important:** This is *not* used for non-2XX errors, such as:
 * > - 4XX or 5XX errors. Those are represented by the {@link DataAPIHttpError} class.
 * > - Connection errors and the like, which would be thrown by the underlying HTTP client directly.
 *
 * @example
 * ```typescript
 * {
 *   family: 'REQUEST',
 *   scope: 'DOCUMENT',
 *   errorCode: 'MISSING_PRIMARY_KEY_COLUMNS',
 *   title: 'Primary key columns missing'
 *   id: 'f785ebb9-a375-4d96-842f-31e23a10a1a5',
 *   message: `
 *     All primary key columns must be provided when inserting a document into a table.
 *
 *     The table default_keyspace.test_table defines the primary key columns:
 *       text(text), int(int).
 *
 *     The command included values for primary key columns: [None].
 *     The command did not include values for primary key columns: int(int), text(text).
 *
 *     Resend the command including the missing primary key columns.
 *   `,
 * }
 * ```
 *
 * @see DataAPIResponseError
 *
 * @public
 */
export declare interface DataAPIErrorDescriptor {
    /**
     * A unique UUID V4 identifier for this instance of the error.
     */
    readonly id: string;
    /**
     * The top level of the hierarchy of errors.
     *
     * Informs if the error was due to their request or server side processing.
     *
     * Expected to only ever be `'REQUEST' | 'SERVER'`, but left open for unlikely future expansion.
     */
    readonly family: LitUnion<'REQUEST' | 'SERVER'>;
    /**
     * Optional, second level of the hierarchy of errors.
     *
     * Informs what area of the request failed.
     *
     * Will be something like `'DATABASE'`, `'EMBEDDING'`, `'FILTER'`, `'DOCUMENT'`, `'AUTHORIZATION'`, etc.
     */
    readonly scope?: string;
    /**
     * Leaf level of the hierarchy of errors.
     *
     * Informs the exact error that occurred.
     *
     * Error codes will be unique within the combination of family and scope, at the very least.
     * - (They will most likely be unique across the entire API).
     *
     * Will be something like `'DOCUMENT_ALREADY_EXISTS'`, `'MISSING_PRIMARY_KEY_COLUMNS'`, etc.
     */
    readonly errorCode: string;
    /**
     * A short, human-readable summary of the error.
     *
     * The title will NOT change for between instances of the same error code.
     *
     * _(that is, every instance of the MULTIPLE_ID_FILTER error returned by the API will have the same title)_.
     *
     * Will be something like
     * - `'Primary key columns missing'`
     * - `'Document already exists with the given _id'`
     * - etc.
     */
    readonly title: string;
    /**
     * A longer human-readable description of the error that contains information specific to the error.
     *
     * > **⚠️Note:** This may contain newlines and other formatting characters.
     */
    readonly message: string;
}

/* Excluded from this release type: DataAPIHttpClient */

/* Excluded from this release type: DataAPIHttpClientOpts */

/**
 * ##### Overview
 *
 * An error thrown on non-2XX status codes from the Data API, such as 4XX or 5XX errors.
 *
 * This is relatively rare compared to the {@link DataAPIResponseError}.
 *
 * > **⚠️Note:** This is not used for connection errors and the like, which would be thrown by the underlying HTTP client directly.
 * >
 * > This only represents HTTP errors, such as 4XX or 5XX errors.
 *
 * @public
 */
export declare class DataAPIHttpError extends DataAPIError {
    /**
     * The error descriptors returned by the API to describe what went wrong.
     */
    readonly status: number;
    /**
     * The raw string body of the HTTP response, if it exists
     */
    readonly body?: string;
    /**
     * The "raw", errored response from the API.
     */
    readonly raw: FetcherResponseInfo;
    /* Excluded from this release type: __constructor */
}

/**
 * Represents an `inet` column for Data API tables.
 *
 * You may use the {@link inet} function as a shorthand for creating a new `DataAPIInet`.
 *
 * See the official DataStax documentation for more information.
 *
 * @public
 */
export declare class DataAPIInet implements TableCodec<typeof DataAPIInet> {
    readonly _raw: string;
    _version: 4 | 6 | nullish;
    /**
     * Errorful implementation of `$SerializeForCollection` for {@link TableCodec}
     *
     * Throws a human-readable error message warning that this datatype may not be used with collections without writing a custom ser/des codec.
     */
    [$SerializeForCollection](): void;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (string | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: any, ctx: TableDesCtx): readonly [0, (DataAPIInet | undefined)?];
    /**
     * Checks if a string is a valid IPv6 address.
     *
     * **NOTE:** Will cover all common cases of IP addresses, but may reject otherwise valid addresses in more esoteric, yet still technically legal, forms.
     *
     * However, this will never return `true` on an IP which is actually invalid.
     */
    static isIPv6(raw: string): boolean;
    /**
     * Checks if a string is a valid IPv4 address.
     *
     * **NOTE:** Will cover all common cases of IP addresses, but may reject otherwise valid addresses in more esoteric, yet still technically legal, forms.
     *
     * However, this will never return `true` on an IP which is actually invalid.
     */
    static isIPv4(raw: string): boolean;
    /**
     * Creates a new `DataAPIInet` instance from a vector-like value.
     *
     * If you pass a `version`, the value will be validated as an IPv4 or IPv6 address; otherwise, it'll be validated as
     * either, and the version will be inferred from the value.
     *
     * You can set `validate` to `false` to bypass any validation if you're confident the value is a valid inet address.
     *
     * @param address - The address to create the `DataAPIInet` from
     * @param version - The IP version to validate the address as
     * @param validate - Whether to actually validate the address
     *
     * @throws TypeError If the address is not a valid IPv4 or IPv6 address
     */
    constructor(address: string | DataAPIInet, version?: 4 | 6 | null, validate?: boolean);
    /**
     * Returns the IP version of the inet address.
     *
     * @returns The IP version of the inet address
     */
    get version(): 4 | 6;
    /**
     * Returns the string representation of the inet address.
     *
     * @returns The string representation of the inet address
     */
    toString(): string;
}

/* Excluded from this release type: DataAPIRequestInfo */

/**
 * ##### Overview
 *
 * An error representing a 2XX error returned from the Data API (such as duplicate ID errors, certain validation errors, etc.)
 *
 * @public
 */
export declare class DataAPIResponseError extends DataAPIError {
    /**
     * A human-readable message describing the *first* error.
     *
     * This is *always* equal to `errorDescriptors[0]?.message` if it exists, otherwise it's given a generic
     * default message.
     */
    readonly message: string;
    /**
     * The original command that was sent to the API, as a plain object. This is the *raw* command, not necessarily in
     * the exact format the client may use, in some rare cases.
     *
     * @example
     * ```typescript
     * {
     *   insertOne: {
     *     document: { _id: 'doc10', name: 'Document 10' },
     *   },
     * }
     * ```
     */
    readonly command: Record<string, any>;
    /**
     * The raw response from the API
     *
     * @example
     * ```typescript
     * {
     *   status: {
     *     insertedIds: [ 'id1', 'id2', 'id3']
     *   },
     *   errors: [
     *     {
     *       family: 'REQUEST',
     *       scope: 'DOCUMENT',
     *       errorCode: 'DOCUMENT_ALREADY_EXISTS',
     *       id: 'e4be94b6-e8b5-4652-961b-5c9fe12d2f1a',
     *       title: 'Document already exists with the given _id',
     *       message: 'Document already exists with the given _id',
     *     },
     *   ]
     * }
     * ```
     */
    readonly rawResponse: RawDataAPIResponse & {
        errors: ReadonlyNonEmpty<DataAPIErrorDescriptor>;
    };
    /* Excluded from this release type: __constructor */
    /**
     * A list of error descriptors representing the individual errors returned by the API.
     *
     * This will likely be a singleton list in many cases, such as for `insertOne` or `deleteOne` commands, but may be
     * longer for bulk operations like `insertMany` which may have multiple insertion errors.
     */
    get errorDescriptors(): ReadonlyNonEmpty<DataAPIErrorDescriptor>;
    /**
     * A list of error descriptors representing the individual errors returned by the API.
     *
     * This will likely be a singleton list in many cases, such as for `insertOne` or `deleteOne` commands, but may be
     * longer for bulk operations like `insertMany` which may have multiple insertion errors.
     */
    get warnings(): readonly DataAPIWarningDescriptor[];
    /* Excluded from this release type: withTransientDupesForEvents */
}

/**
 * ##### Overview
 *
 * Represents a `time` column for Data API tables.
 *
 * ##### Format
 *
 * `time`s consist of an hour, a minute, and optional second and nanosecond components.
 *
 * - The hour is a number from 0 to 23, and must be positive.
 * - The minute is a number from 0 to 59.
 * - The second is a number from 0 to 59, and will default to 0 if not provided.
 * - The nanosecond is a fractional component of the second, and will default to 0 if not provided.
 *   - It is a number up to 9 digits long.
 *   - If any digits are omitted, they are assumed to be 0.
 *   - e.g. `12:34:56.789` is equivalent to `12:34:56.789000000`.
 *   - Seconds must be provided if nanoseconds are provided.
 *
 * Together, the format would be as such: `HH:MM[:SS[.NNNNNNNNN]]`.
 *
 * ##### Creation
 *
 * There are a number of different ways to initialize a `DataAPITime`:
 *
 * @example
 * ```ts
 * // Convert a native JS `Date` to a `DataAPITime` (extracting only the local time)
 * new DataAPITIme(new Date('2004-09-14T12:00:00.000')) // '12:00:00.000000000'
 *
 * // Parse a time given the above time-string format
 * new DataAPITime('12:34:56.78') // '12:34:56.780000000'
 *
 * // Create a `DataAPIDate` from an hour, a minute, and optional second and nanosecond components
 * new DataAPITime(12, 34, 56, 78) // '12:34:56.000000078'
 *
 * // Get the current time (using the local timezone)
 * DataAPITime.now()
 *
 * // Get the current time (using UTC)
 * DataAPITime.utcnow()
 *
 * // Create a `DataAPITime` from the number of nanoseconds since the start of the day
 * DataAPITime.ofNanoOfDay(12_345_678_912_345) // '03:25:45.678912345'
 *
 * // Create a `DataAPITime` from the number of seconds since the start of the day
 * DataAPITime.ofSecondOfDay(12_345) // '03:25:45.000000000'
 * ```
 *
 * ##### The `time` shorthand
 *
 * You may use the {@link time} shorthand function-object anywhere when creating new `DataAPITime`s.
 *
 * @example
 * ```ts
 * // equiv. to `new DataAPITime('12:34:56')`
 * time('12:34:56')
 *
 * // equiv. to `new DataAPITime(12, 34, 56)`
 * time(12, 34, 56)
 *
 * // equiv. to `DataAPITime.now()`
 * time.now()
 * ```
 *
 * See the official DataStax documentation for more information.
 *
 * @see time
 *
 * @public
 */
export declare class DataAPITime implements TableCodec<typeof DataAPITime> {
    /**
     * The hour component of this `DataAPITime`.
     *
     * Must be between 0-23.
     */
    readonly hours: number;
    /**
     * The minute component of this `DataAPITime`.
     *
     * Must be between 0-59.
     */
    readonly minutes: number;
    /**
     * The second component of this `DataAPITime`.
     *
     * Must be between 0-59.
     */
    readonly seconds: number;
    /**
     * The nanosecond component of this `DataAPITime`.
     *
     * Must be between 0-999,999,999.
     */
    readonly nanoseconds: number;
    /**
     * Errorful implementation of `$SerializeForCollection` for {@link TableCodec}
     *
     * Throws a human-readable error message warning that this datatype may not be used with collections without writing a custom ser/des codec.
     */
    [$SerializeForCollection](): void;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (string | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: any, ctx: TableDesCtx): readonly [0, (DataAPITime | undefined)?];
    /**
     * ##### Overview
     *
     * Returns the current time in the local timezone.
     *
     * Equivalent to `new DataAPITime(new Date())`.
     *
     * @example
     * ```ts
     * const now = time.now();
     * // or
     * const now = DataAPITime.now()
     * ```
     *
     * @returns The current time in the local timezone
     */
    static now(this: void): DataAPITime;
    /**
     * ##### Overview
     *
     * Returns the current time in UTC.
     *
     * Uses `Date.now()` under the hood.
     *
     * @example
     * ```ts
     * const now = time.utcnow();
     * // or
     * const now = DataAPITime.utcnow()
     * ```
     *
     * @returns The current time in UTC
     */
    static utcnow(this: void): DataAPITime;
    /**
     * ##### Overview
     *
     * Creates a `DataAPITime` from the number of nanoseconds since the start of the day .
     *
     * The number must be a positive integer in the range [0, 86,399,999,999,999].
     *
     * @example
     * ```ts
     * DataAPITime.ofNanoOfDay(0) // '00:00:00.000000000'
     *
     * date.ofNanoOfDay(12_345_678_912_345) // '03:25:45.678912345'
     * ```
     *
     * @param nanoOfDay - The number of nanoseconds since the start of the day
     *
     * @returns The `DataAPITime` representing the given number of nanoseconds
     */
    static ofNanoOfDay(this: void, nanoOfDay: number): DataAPITime;
    /**
     * ##### Overview
     *
     * Creates a `DataAPITime` from the number of seconds since the start of the day.
     *
     * The number must be a positive integer in the range [0, 86,399].
     *
     * @example
     * ```ts
     * DataAPITime.ofSecondOfDay(0) // '00:00:00.000000000'
     *
     * DataAPITime.ofSecondOfDay(12_345) // '03:25:45.000000000'
     * ```
     *
     * @param secondOfDay - The number of seconds since the start of the day
     *
     * @returns The `DataAPITime` representing the given number of seconds
     */
    static ofSecondOfDay(this: void, secondOfDay: number): DataAPITime;
    /**
     * ##### Overview
     *
     * Converts a native JS `Date` to a `DataAPITime` (extracting only the local time).
     *
     * @example
     * ```ts
     * new DataAPITime(new Date('2004-09-14T12:00:00.000')) // '12:00:00.000000000'
     *
     * time(new Date('12:34:56.78')) // '12:34:56.780000000'
     * ```
     *
     * @param time - The `Date` object to convert
     */
    constructor(time: Date);
    /**
     * ##### Overview
     *
     * Parses a `DataAPITime` from a string in the format `HH:MM[:SS[.NNNNNNNNN]]`.
     *
     * See {@link DataAPITime} for more info about the exact format.
     *
     * @example
     * ```ts
     * new DataAPITime('12:00') // '12:00:00.000000000'
     *
     * time('12:34:56.78') // '12:34:56.780000000'
     * ```
     *
     * @param time - The time string to parse
     */
    constructor(time: string);
    /* Excluded from this release type: __constructor */
    /**
     * ##### Overview
     *
     * Creates a `DataAPITime` from an hour, a minute, and optional second and nanosecond components.
     *
     * All components must be zero-indexed positive integers within the following ranges:
     * - `hour`: [0, 23]
     * - `minute`: [0, 59]
     * - `second`: [0, 59]
     * - `nanosecond`: [0, 999,999,999]
     *
     * @example
     * ```ts
     * new DataAPIDate(20, 15) // '20:15:00.000000000'
     *
     * date(12, 12, 12, 12) // '12:12:12.000000012'
     * ```
     *
     * @param hours - The hour to use
     * @param minutes - The minute to use
     * @param seconds - The second to use (defaults to 0)
     * @param nanoseconds - The nanosecond to use (defaults to 0)
     */
    constructor(hours: number, minutes: number, seconds?: number, nanoseconds?: number);
    /**
     * ##### Overview
     *
     * Converts this `DataAPITime` to a `Date` object in the local timezone.
     *
     * If no `base` date is provided, the time component defaults to the current local date.
     *
     * If the `base` parameter is a `DataAPIDate`, it is interpreted as being in the local timezone, not UTC.
     *
     * See {@link DataAPITime.toDateUTC} for a UTC-based alternative to this method.
     *
     * @example
     * ```ts
     * // Assuming the local timezone is UTC-6 (CST) //
     *
     * // Local Time: '2000-01-01T12:00:00'
     * // UTC Time:   '2000-01-01T18:00:00Z'
     * time('12:00:00').toDate(new Date('2000-01-01T00:00:00'));
     *
     * // Local Time: '1999-12-31T12:00:00'
     * // UTC Time:   '1999-12-31T18:00:00Z'
     * time('12:00:00').toDate(new Date('2000-01-01T00:00:00Z'));
     *
     * // Local Time: '2000-01-01T12:00:00'
     * // UTC Time:   '2000-01-01T18:00:00Z'
     * time('12:00:00').toDate(new DataAPIDate('2000-01-01'));
     *
     * // Local Time: '2025-01-22T12:00:00'
     * // UTC Time:   '2025-01-22T18:00:00Z'
     * time('12:00:00').toDate();
     * ```
     *
     * @param base - The base date to use for the date component. If omitted, defaults to the current local date.
     *
     * @returns The `Date` object representing this `DataAPITime` in the local timezone.
     *
     * @see DataAPITime.toDateUTC
     */
    toDate(base?: Date | DataAPIDate): Date;
    /**
     * ##### Overview
     *
     * Converts this `DataAPITime` to a `Date` object in UTC.
     *
     * If no `base` date is provided, the time component defaults to the current date in UTC.
     *
     * If the `base` parameter is a `DataAPIDate`, it is interpreted as being in the UTC timezone.
     *
     * See {@link DataAPITime.toDate} for a local-date-based alternative to this method.
     *
     * @example
     * ```ts
     * // Assuming the local timezone is UTC-6 (CST) //
     *
     * // Local Time: '2000-01-01T06:00:00'
     * // UTC Time:   '2000-01-01T12:00:00Z'
     * time('12:00:00').toDateUTC(new Date('2000-01-01T00:00:00'));
     *
     * // Local Time: '2000-01-01T06:00:00Z'
     * // UTC Time:   '2000-01-01T12:00:00Z'
     * time('12:00:00').toDateUTC(new Date('2000-01-01T00:00:00Z'));
     *
     * // Local Time: '2000-01-01T06:00:00'
     * // UTC Time:   '2000-01-01T12:00:00Z'
     * time('12:00:00').toDateUTC(new DataAPIDate('2000-01-01'));
     *
     * // Local Time: '2025-01-22T06:00:00'
     * // UTC Time:   '2025-01-22T12:00:00Z'
     * time('12:00:00').toDateUTC();
     * ```
     *
     * @param base - The base date to use for the date component. If omitted, defaults to the current date in UTC.
     *
     * @returns The `Date` object representing this `DataAPITime` in UTC.
     *
     * @see DataAPITime.toDate
     */
    toDateUTC(base?: Date | DataAPIDate): Date;
    /**
     * ##### Overview
     *
     * Returns the string representation of this `DataAPITime`
     *
     * Note that it'll contain the second & nanosecond components, even if they weren't provided.
     *
     * @example
     * ```ts
     * time('12:00').toString() // '12:00:00.000000000'
     *
     * time(12, 34, 56, 78).toString() // '12:34:56.000000078'
     * ```
     *
     * @returns The string representation of this `DataAPITime`
     */
    toString(): string;
    /**
     * ##### Overview
     *
     * Compares this `DataAPITime` to another `DataAPITime`
     *
     * @example
     * ```ts
     * time('12:00').compare(time(12, 0)) // 0
     *
     * time('12:00').compare(time(12, 1)) // -1
     *
     * time('12:01').compare(time(12, 0)) // 1
     * ```
     *
     * @param other - The other `DataAPITime` to compare to
     *
     * @returns `0` if the times are equal, `-1` if this time is before the other, and `1` if this time is after the other
     */
    compare(other: DataAPITime): -1 | 0 | 1;
    /**
     * ##### Overview
     *
     * Checks if this `DataAPITime` is equal to another `DataAPITime`
     *
     * @example
     * ```ts
     * time('12:00').equals(time(12, 0)) // true
     *
     * time('12:00').equals(time(12, 1)) // false
     *
     * time('12:00').equals('12:00:00.000000000') // true
     * ```
     *
     * @param other - The other `DataAPITime` to compare to
     *
     * @returns `true` if the times are equal, and `false` otherwise
     */
    equals(other: DataAPITime | string): boolean;
}

/**
 * ##### Overview
 *
 * An error thrown when a Data API operation timed out.
 *
 * Depending on the method, this may be a request timeout occurring during a specific HTTP request, or can happen over
 * the course of a method involving several requests in a row, such as a paginated `insertMany`.
 *
 * @see TimeoutDescriptor
 *
 * @public
 */
export declare class DataAPITimeoutError extends DataAPIError {
    /**
     * The timeout that was set for the operation, in milliseconds.
     */
    readonly timeout: Partial<TimeoutDescriptor>;
    /**
     * Represents which timeouts timed out (e.g. `'requestTimeoutMs'`, `'tableAdminTimeoutMs'`, the provided timeout, etc.)
     */
    readonly timedOutCategories: TimedOutCategories;
    /* Excluded from this release type: __constructor */
    /* Excluded from this release type: mk */
}

/**
 * Represents a `vector` column for Data API tables.
 *
 * See {@link DataAPIVectorLike} for the types that can be converted into a `DataAPIVector`.
 *
 * You may use the {@link vector} function as a shorthand for creating a new `DataAPIVector`.
 *
 * See the official DataStax documentation for more information.
 *
 * @public
 */
export declare class DataAPIVector implements DataAPICodec<typeof DataAPIVector> {
    private readonly _vector;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (number[] | {
        $binary: string;
    } | undefined)?];
    /**
     * Implementation of `$SerializeForCollection` for {@link TableCodec}
     */
    [$SerializeForCollection](ctx: CollectionSerCtx): readonly [0, (number[] | {
        $binary: string;
    } | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: any, ctx: TableDesCtx): readonly [0, (DataAPIVector | undefined)?];
    /**
     * Implementation of `$DeserializeForCollection` for {@link TableCodec}
     */
    static [$DeserializeForCollection](value: any, ctx: CollectionDesCtx): readonly [0, (DataAPIVector | undefined)?];
    /**
     * Creates a new `DataAPIVector` instance from a vector-like value.
     *
     * You can set `validate` to `false` to bypass any validation if you're confident the value is a valid vector.
     *
     * @param vector - The vector-like value to convert to a `DataAPIVector`
     * @param validate - Whether to validate the vector-like value (default: `true`)
     *
     * @throws TypeError If `vector` is not a valid vector-like value
     */
    constructor(vector: DataAPIVectorLike, validate?: boolean);
    /**
     * Returns the length of the vector (# of floats), agnostic of the underlying type.
     *
     * @returns The length of the vector
     */
    get length(): number;
    /**
     * Gets the raw underlying implementation of the vector.
     *
     * @returns The raw vector
     */
    raw(): Exclude<DataAPIVectorLike, DataAPIVector>;
    /**
     * Returns the vector as a `number[]`, converting between types if necessary.
     *
     * @returns The vector as a `number[]`
     */
    asArray(): number[];
    /**
     * Returns the vector as a `Float32Array`, converting between types if necessary.
     *
     * @returns The vector as a `Float32Array`
     */
    asFloat32Array(): Float32Array;
    /**
     * Returns the vector as a base64 string, converting between types if necessary.
     *
     * @returns The vector as a base64 string
     */
    asBase64(): string;
    /**
     * Returns a pretty string representation of the `DataAPIVector`.
     */
    toString(): string;
    /**
     * Determines whether the given value is a vector-like value (i.e. it's {@link DataAPIVectorLike}).
     *
     * @param value - The value to check
     *
     * @returns `true` if the value is a vector-like value; `false` otherwise
     */
    static isVectorLike(value: unknown): value is DataAPIVectorLike;
    /* Excluded from this release type: serialize */
}

/**
 * Represents any type that can be converted into a {@link DataAPIVector}
 *
 * @public
 */
export declare type DataAPIVectorLike = number[] | {
    $binary: string;
} | Float32Array | DataAPIVector;

/**
 * ##### Overview
 *
 * A specialized subset of {@link DataAPIErrorDescriptor} that represents a warning returned by the Data API.
 *
 * This represents a warning that occurred during the operation which should likely be addressed by the user, but had no actual impact on the success or failure of the operation itself.
 *
 * > **⚠️Note**: This is identical to the {@link DataAPIErrorDescriptor} in every way, except {@link DataAPIErrorDescriptor.scope} is always `'WARNING'`.
 *
 * @see CommandWarningEvent
 * @see AdminCommandWarningEvent
 *
 * @public
 */
export declare type DataAPIWarningDescriptor = DataAPIErrorDescriptor & {
    scope: 'WARNING';
};

/**
 * ##### Overview
 *
 * A shorthand function-object for {@link DataAPIDate}. May be used anywhere when creating new `DataAPIDate`s.
 *
 * See {@link DataAPIDate} and its methods for information about input parameters, formats, functions, etc.
 *
 * @example
 * ```ts
 * // equiv. to `new DataAPIDate('2004-09-14')`
 * date('2004-09-14')
 *
 * // equiv. to `new DataAPIDate(2004, 9, 14)`
 * date(2004, 9, 14)
 *
 * // equiv. to `DataAPIDate.now()`
 * date.now()
 * ```
 *
 * @public
 */
export declare const date: ((...params: [string] | [Date] | [DataAPIDate] | [number, number, number]) => DataAPIDate) & {
    now: typeof DataAPIDate.now;
    utcnow: typeof DataAPIDate.utcnow;
    ofEpochDay: typeof DataAPIDate.ofEpochDay;
    ofYearDay: typeof DataAPIDate.ofYearDay;
};

/**
 * ##### Overview
 *
 * Represents an interface to some Data-API-enabled database instance. This is the entrypoint for database-level DML, such as
 * creating/deleting collections/tables, connecting to collections/tables, and executing arbitrary commands.
 *
 * > **⚠️Warning**: This shouldn't be instantiated directly; use {@link DataAPIClient.db} to spawn this class.
 *
 * Note that creating an instance of a `Db` doesn't trigger actual database creation; the database must have already
 * existed beforehand. If you need to create a new database, use the {@link AstraAdmin} class.
 *
 * @example
 * ```ts
 * // Connect to a database using a direct endpoint
 * const db = client.db('*ENDPOINT*');
 *
 * // Overrides default options from the DataAPIClient
 * const db = client.db('*ENDPOINT*', {
 *   keyspace: '*KEYSPACE*',
 *   token: '*TOKEN*',
 * });
 * ```
 *
 * ---
 *
 * ##### The "working keyspace"
 *
 * The `Db` class has a concept of a "working keyspace", which is the default keyspace used for all operations in the database. This can be overridden in each method call, but if not, the default keyspace is used.
 *
 * If no explicit keyspace is provided when creating the `Db` instance, it will default to:
 * - On DataStax Astra: `'default_keyspace'`
 * - On all other dbs, it will remain as `undefined`
 *   - In this case, the keyspace must be set using either:
 *     - The `db.useKeyspace()` mutator method
 *     - The `updateDbKeyspace` parameter in `dbAdmin.createKeyspace()`
 *
 * Changing the working namespaces does _NOT_ retroactively update any collections/tables spawned from this `Db` instance.
 *
 * See {@link Db.keyspace}, {@link Db.useKeyspace} and {@link DbAdmin.createKeyspace} for more information.
 *
 * @example
 * ```ts
 * // Method 1:
 * db.useKeyspace('my_keyspace');
 *
 * // Method 2:
 * // (If using non-astra, this may be a common idiom)
 * await db.admin().createKeyspace('my_keyspace', {
 *   updateDbKeyspace: true,
 * });
 * ```
 *
 * ---
 *
 * ##### Astra vs. non-Astra
 *
 * The `Db` class is designed to work with both Astra and non-Astra databases. However, there are some differences in behavior between the two:
 * - Astra DBs have an ID & region, which can be accessed using `db.id` and `db.region` respectively
 *   - Note that this is not available with Astra private endpoints
 * - Astra DBs have a `db.info()` method, which provides detailed information about the database
 *   - Note that this is not available with Astra private endpoints
 * - The `db.admin()` method will return differently depending on the environment
 *   - For Astra DBs, it will return an {@link AstraDbAdmin} instance
 *   - For non-Astra DBs, it will return a {@link DataAPIDbAdmin} instance
 *   - (The `environment` option must also be set in the `admin()` method)
 * - As aforementioned, the default keyspace is different between Astra and non-Astra databases
 *   - See the previous section for more information
 *
 * @see DataAPIClient.db
 * @see AstraAdmin.db
 * @see Table
 * @see Collection
 * @see DbAdmin
 *
 * @public
 */
export declare class Db extends HierarchicalLogger<CommandEventMap> {    /**
     * ##### Overview
     *
     * The endpoint of the database.
     *
     * This will be verbatim with the endpoint that was passed to `client.db()`, except any trailing slashes will be stripped.
     *
     * @example
     * ```ts
     * const db = client.db('https://<db_id>-<region>.apps.astra.datastax.com');
     * db.endpoint; // 'https://<db_id>-<region>.apps.astra.datastax.com'
     * ```
     */
    readonly endpoint: string;
    /* Excluded from this release type: __constructor */
    /**
     * ##### Overview
     *
     * The "working keyspace" used for all operations in this {@link Db} instance (unless overridden in a method call).
     *
     * See the {@link Db} class documentation for more information about the working keyspace.
     *
     * ##### Common examples
     *
     * See the following sections for examples specific to Astra & non-Astra (DSE, HCE, etc.) databases.
     *
     * @example
     * ```ts
     * // Uses 'my_keyspace' as the default keyspace for all future db spawns
     * const client = new DataAPIClient('*TOKEN*', {
     *   dbOptions: { keyspace: 'my_keyspace' },
     * });
     * client.db(...).keyspace // 'my_keyspace'
     * ```
     *
     * @example
     * ```ts
     * // Uses 'my_keyspace' for this specific db spawn
     * const client = new DataAPIClient('*TOKEN*');
     * client.db(..., { keyspace: 'my_keyspace' }).keyspace // 'default_keyspace'
     * ```
     *
     * ##### On Astra
     *
     * Note that on Astra databases, this will default to `default_keyspace` if not set explicitly.
     *
     * @example
     * ```ts
     * // Uses 'default_keyspace' as the default keyspace for all future db spawns
     * const client = new DataAPIClient('*TOKEN*');
     * client.db(...).keyspace // 'default_keyspace'
     * ```
     *
     * ---
     *
     * ##### On non-Astra (DSE, HCD, etc.)
     *
     * On non-Astra databases, this will be `undefined` if not set explicitly, as HCD, DSE, etc. are not guaranteed to have a default `default_keyspace`.
     *
     * You will need to either set the `keyspace` parameter somewhere, or update the {@link Db} instance's keyspace via either
     * - {@link Db.useKeyspace}
     * - The `updateDbKeyspace` parameter in {@link DbAdmin.createKeyspace}
     *
     * @example
     * ```ts
     * // No default keyspace on db spawns
     * const client = new DataAPIClient('*TOKEN*');
     * client.db(...).keyspace // undefined
     * ```
     *
     * @example
     * ```ts
     * // A potentially common idiom for non-Astra
     * const client = new DataAPIClient('*TOKEN*');
     *
     * const db = client.db(...);
     * db.keyspace // undefined
     *
     * await db.admin().createKeyspace('my_keyspace', {
     *   updateDbKeyspace: true,
     * });
     * db.keyspace // 'my_keyspace'
     * ```
     */
    get keyspace(): string;
    /**
     * ##### Overview
     *
     * The ID of the database (a UUID), if it's an Astra database.
     *
     * > **⚠️Warning**: This only works for Astra databases, which are not connected to via a private endpoint.
     *
     * @example
     * ```ts
     * const db = client.db('https://<db_id>-<region>.apps.astra-dev.datastax.com');
     * db.id; // '<db_id>'
     * ```
     *
     * @throws InvalidEnvironmentError - if the database is not an Astra database.
     */
    get id(): string;
    /**
     * The region of the database (e.g. `'us-east-1'`), if it's an Astra database.
     *
     * > **⚠️Warning**: This only works for Astra databases, which are not connected to via a private endpoint.
     *
     * @example
     * ```ts
     * const db = client.db('https://<db_id>-<region>.apps.astra-dev.datastax.com');
     * db.region; // '<region>'
     * ```
     *
     * @throws InvalidEnvironmentError - if the database is not an Astra database.
     */
    get region(): string;
    /**
     * ##### Overview
     *
     * Sets the default working keyspace of the `Db` instance. Does not retroactively update any previous collections
     * spawned from this `Db` to use the new keyspace.
     *
     * See {@link Db} for more info on "working keyspaces".
     *
     * @example
     * ```typescript
     * // Spawns a `Db` with default working keyspace `my_keyspace`
     * const db = client.db('<endpoint>', { keyspace: 'my_keyspace' });
     *
     * // Gets a collection from keyspace `my_keyspace`
     * const coll1 = db.collection('my_coll');
     *
     * // `db` now uses `my_other_keyspace` as the default keyspace for all operations
     * db.useKeyspace('my_other_keyspace');
     *
     * // Gets a collection from keyspace `my_other_keyspace`
     * // `coll1` still uses keyspace `my_keyspace`
     * const coll2 = db.collection('my_other_coll');
     *
     * // Gets `my_coll` from keyspace `my_keyspace` again
     * // (The default keyspace is still `my_other_keyspace`)
     * const coll3 = db.collection('my_coll', { keyspace: 'my_keyspace' });
     * ```
     *
     * ---
     *
     * ##### `updateDbKeyspace` in `DbAdmin.createKeyspace`
     *
     * If you want to create a `Db` in a not-yet-existing keyspace, you can use the `updateDbKeyspace` option in {@link DbAdmin.createKeyspace} to set the default keyspace of the `Db` instance to the new keyspace.
     *
     * This may be a common idiom when working with non-Astra databases.
     *
     * @example
     * ```typescript
     * const client = new DataAPIClient({ environment: 'dse' });
     * const db = client.db('<endpoint>', { token: '<token>' });
     *
     * // Will internally call `db.useKeyspace('new_keyspace')`
     * await db.admin().createKeyspace('new_keyspace', {
     *   updateDbKeyspace: true,
     * });
     *
     * // Creates collection in keyspace `new_keyspace` by default now
     * const coll = db.createCollection('my_coll');
     * ```
     *
     * @param keyspace - The keyspace to use
     */
    useKeyspace(keyspace: string): void;
    /**
     * ##### Overview (Astra overload)
     *
     * Spawns a new {@link AstraDbAdmin} instance for this database, used for performing administrative operations
     * on the database, such as managing keyspaces, or getting database information.
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * @example
     * ```typescript
     * const admin1 = db.admin();
     * const admin2 = db.admin({ adminToken: '<stronger-token>' });
     *
     * const keyspaces = await admin1.listKeyspaces();
     * console.log(keyspaces);
     * ```
     *
     * ---
     *
     * ##### Astra vs. non-Astra
     *
     * > **⚠️Warning**: If using a non-Astra backend, the `environment` option **must** be set as it is on the `DataAPIClient`.
     *
     * If on Astra, this method will return a new {@link AstraDbAdmin} instance, which provides a few extra methods for Astra databases, such as {@link AstraDbAdmin.info} or {@link AstraDbAdmin.drop}.
     *
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link AstraDbAdmin} instance for this database instance.
     *
     * @throws InvalidEnvironmentError - if the database is not an Astra database.
     */
    admin(options?: AdminOptions & {
        environment?: 'astra';
    }): AstraDbAdmin;
    /**
     * ##### Overview (Non-Astra overload)
     *
     * Spawns a new {@link DataAPIDbAdmin} instance for this database, used for performing administrative operations
     * on the database, such as managing keyspaces, or getting database information.
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * @example
     * ```typescript
     * const client = new DataAPIClient({ environment: 'dse' });
     * const db = client.db('*ENDPOINT*', { token });
     *
     * // OK
     * const admin1 = db.admin({ environment: 'dse' });
     *
     * // Will throw "mismatching environments" error
     * const admin2 = db.admin();
     *
     * const keyspaces = await admin1.listKeyspaces();
     * console.log(keyspaces);
     * ```
     *
     * ---
     *
     * ##### Astra vs. non-Astra
     *
     * > **⚠️Warning**: If using a non-Astra backend, the `environment` option **must** be set as it is on the `DataAPIClient`.
     *
     * If on non-Astra, this method will return a new {@link DataAPIDbAdmin} instance, which conforms strictly to the {@link DbAdmin} interface, with the {@link DataAPIDbAdmin.createKeyspace} method being the only method that differs slightly from the interface version.
     *
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link AstraDbAdmin} instance for this database instance.
     *
     * @throws InvalidEnvironmentError - if the database is an Astra database.
     */
    admin(options: AdminOptions & {
        environment: Exclude<DataAPIEnvironment, 'astra'>;
    }): DataAPIDbAdmin;
    /**
     * ##### Overview
     *
     * Fetches information about the database, such as the database name, region, and other metadata.
     *
     * > **⚠️Warning**: This only works for Astra databases, which are not connected to via a private endpoint.
     *
     * > **✏️Note**: For the full, complete, information, use {@link AstraDbAdmin.info} or {@link AstraAdmin.dbInfo} instead.
     *
     * The method issues a request to the DevOps API each time it is invoked, without caching mechanisms;
     * this ensures up-to-date information for usages such as real-time collection validation by the application.
     *
     * @example
     * ```typescript
     * const info = await db.info();
     * console.log(info.name);
     * ```
     *
     * ---
     *
     * ##### On non-Astra
     *
     * This operation requires a call to the DevOps API, which is only available on Astra databases. As such, this method will throw an error if the database is not an Astra database.
     *
     * @returns A promise that resolves to the database information.
     *
     * @throws Error - if the database is not an Astra database.
     */
    info(options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<AstraPartialDatabaseInfo>;
    /**
     * ##### Overview
     *
     * Establishes a reference to a collection in the database. This method does not perform any I/O.
     *
     * > **⚠️Warning**: This method does _not_ verify the existence of the collection; it simply creates a reference.
     *
     * @example
     * ```ts
     * interface User {
     *   name: string,
     *   age?: number,
     * }
     *
     * // Basic usage
     * const users1 = db.collection<User>('users');
     * users1.insertOne({ name: 'John' });
     *
     * // Untyped collection from different keyspace
     * const users2 = db.collection('users', {
     *   keyspace: 'my_keyspace',
     * });
     * users2.insertOne({ 'anything[you]$want': 'John' }); // Dangerous
     * ```
     *
     * ---
     *
     * ##### No I/O
     *
     * > **🚨Important**: Unlike the MongoDB Node.js driver, this method does not create a collection if it doesn't exist.
     * >
     * > Use {@link Db.createCollection} to create a new collection instead.
     *
     * It is on the user to ensure that the collection being connected to actually exists.
     *
     * ---
     *
     * ##### Typing the collection, and much more information
     *
     * See the {@link Collection} class's documentation for information on how and why the {@link Collection} class is typed, any disclaimers related to it, and for so much more information in general.
     *
     * > **⚠️Warning:** Collections are _inherently untyped_; any typing is client-side to help with bug-catching.
     *
     * @param name - The name of the collection.
     * @param options - Options for spawning the collection.
     *
     * @returns A new, unvalidated, reference to the collection.
     *
     * @see SomeDoc
     * @see VectorDoc
     * @see VectorizeDoc
     * @see db.createCollection
     */
    collection<WSchema extends SomeDoc, RSchema extends WithId<SomeDoc> = FoundDoc<WSchema>>(name: string, options?: CollectionOptions): Collection<WSchema, RSchema>;
    /**
     * ##### Overview
     *
     * Establishes a reference to a table in the database. This method does not perform any I/O.
     *
     * > **⚠️Warning**: This method does _not_ verify the existence of the table; it simply creates a reference.
     *
     * @example
     * ```ts
     * interface User {
     *   name: string,
     *   age?: number,
     * }
     *
     * // Basic usage
     * const users1 = db.table<User>('users');
     * users1.insertOne({ name: 'John' });
     *
     * // Untyped table from different keyspace
     * const users2 = db.table('users', {
     *   keyspace: 'my_keyspace',
     * });
     * users2.insertOne({ 'anything[you]$want': 'John' }); // Dangerous
     * ```
     *
     * ---
     *
     * ##### No I/O
     *
     * > **🚨Important**: This method does not create a table if it doesn't exist.
     * >
     * > Use {@link Db.createTable} to create a new table.
     *
     * It is on the user to ensure that the table being connected to actually exists.
     *
     * ---
     *
     * ##### Typing the table, and much more information
     *
     * > **💡Tip:** You can use {@link InferTableSchema} to infer the TS-equivalent-type of the table from the provided `CreateTableDefinition`.
     *
     * See the {@link Table} class's documentation for information on how and why the {@link Table} class is typed, any disclaimers related to it, and for so much more information in general.
     *
     * @param name - The name of the table.
     * @param options - Options for spawning the table.
     *
     * @returns A new, unvalidated, reference to the table.
     *
     * @see SomeRow
     * @see db.createTable
     * @see InferTableSchema
     * @see InferTablePrimaryKey
     */
    table<WSchema extends SomeRow, PKeys extends SomePKey = Partial<FoundRow<WSchema>>, RSchema extends SomeRow = FoundRow<WSchema>>(name: string, options?: TableOptions): Table<WSchema, PKeys, RSchema>;
    /**
     * ##### Overview
     *
     * Creates a new collection in the database, and establishes a reference to it.
     *
     * This is a **blocking** command which performs actual I/O (unlike {@link Db.collection}, which simply creates an
     * unvalidated reference to a collection).
     *
     * @example
     * ```ts
     * // Most basic usage
     * const users = await db.createCollection('users');
     *
     * // With custom options in a different keyspace
     * const users2 = await db.createCollection('users', {
     *   keyspace: 'my_keyspace',
     *   defaultId: {
     *     type: 'objectId',
     *   },
     * });
     * ```
     *
     * ---
     *
     * ##### Idempotency
     *
     * Creating a collection is **idempotent** as long as the options remain the same; if the collection already exists with the same options, a {@link DataAPIResponseError} will be thrown.
     *
     * ("options" meaning the `createCollection` options actually sent to the server, not things like `timeout` which are just client-side).
     *
     * ---
     *
     * ##### Enabling vector search
     *
     * *If vector options are not specified, the collection will not support vector search.*
     *
     * You can enable it by providing a `vector` option with the desired configuration, optionally with a `vector.service` block to enable vectorize (auto-embedding-generation).
     *
     * @example
     * ```ts
     * const users = await db.createCollection('users', {
     *   vector: {
     *     service: {
     *       provider: 'nvidia',
     *       modelName: 'NV-Embed-QA',
     *     },
     *   },
     * });
     *
     * // Now, `users` supports vector search
     * await users.insertOne({ $vectorize: 'I like cars!!!' });
     * await users.findOne({}, { sort: { $vectorize: 'I like cars!!!' } });
     * ```
     *
     * ----
     *
     * ##### Typing the collection, and much more information
     *
     * See the {@link Collection} class's documentation for information on how and why the {@link Collection} class is typed, any disclaimers related to it, and for so much more information in general.
     *
     * > **⚠️Warning:** Collections are _inherently untyped_; any typing is client-side to help with bug-catching.
     *
     * @param name - The name of the collection to create.
     * @param options - Options for the collection.
     *
     * @returns A promised reference to the newly created collection.
     *
     * @throws CollectionAlreadyExistsError - if the collection already exists and `checkExists` is `true` or unset.
     *
     * @see SomeDoc
     * @see db.collection
     */
    createCollection<WSchema extends SomeDoc, RSchema extends WithId<SomeDoc> = FoundDoc<WSchema>>(name: string, options?: CreateCollectionOptions<WSchema>): Promise<Collection<WSchema, RSchema>>;
    /**
     * ##### Overview (auto-infer-schema overload)
     *
     * Creates a new table in the database, and establishes a reference to it.
     *
     * This is a *blocking* command which performs actual I/O (unlike {@link Db.table}, which simply creates an
     * unvalidated reference to a table).
     *
     * ---
     *
     * ##### Overloads
     *
     * This overload of `createTable` infers the TS-equivalent schema of the table from the provided `CreateTableDefinition`.
     *
     * Provide an explicit `Schema` type to disable this (i.e. `db.createTable<Tyoe>(...)`).
     *
     * > **💡Tip**: You may use `db.createTable<SomeRow>(...)` to spawn an untyped table.
     *
     * ---
     *
     * ##### Type Inference
     *
     * The recommended way to type a table is to allow TypeScript to infer the type from the provided `CreateTableDefinition`.
     *
     * @example
     * ```ts
     * // Define the table schema
     * const UserSchema = Table.schema({
     *   columns: {
     *     name: 'text',
     *     dob: {
     *       type: 'timestamp',
     *     },
     *     friends: {
     *       type: 'set',
     *       valueType: 'text',
     *     },
     *   },
     *   primaryKey: {
     *     partitionBy: ['name'],
     *     partitionSort: { dob: 1 },
     *   },
     * });
     *
     * // Type inference is as simple as that
     * type User = InferTableSchema<typeof UserSchema>;
     *
     * // And now `User` can be used wherever.
     * const main = async () => {
     *   const table = await db.createTable('users', { definition: UserSchema });
     *   const found = await table.findOne({}); // found :: User | null
     * };
     * ```
     *
     * ---
     *
     * ##### Idempotency
     *
     * Creating a table is idempotent if the `ifNotExists` option is set to `true`. Otherwise, an error will be thrown if a table with the same name is thrown.
     *
     * > 🚨**Important:** When using `ifNotExists: true`, **only the existence of a table with the same name is checked.**
     * >
     * > If a table with that name already exists, but the columns (or any other options) you define differ from the existing table, **it won’t give you an error**; instead, it'll silently succeed, and the original table schema will be retained.
     *
     * ---
     *
     * ##### Typing the table, and much more information
     *
     * > **💡Tip:** You can use {@link InferTableSchema} to infer the TS-equivalent-type of the table from the provided `CreateTableDefinition`.
     *
     * See the {@link Table} class's documentation for information on how and why the {@link Table} class is typed, any disclaimers related to it, and for so much more information in general.
     *
     * @param name - The name of the table to create.
     * @param options - Options for the table.
     *
     * @returns A promised reference to the newly created table.
     *
     * @see SomeRow
     * @see db.table
     * @see InferTableSchema
     * @see InferTablePrimaryKey
     * @see CreateTableDefinition
     */
    createTable<const Def extends CreateTableDefinition>(name: string, options: CreateTableOptions<Def>): Promise<Table<InferTableSchema<Def>, InferTablePrimaryKey<Def>>>;
    /**
     * ##### Overview (explicit-schema overload)
     *
     * Creates a new table in the database, and establishes a reference to it.
     *
     * This is a *blocking* command which performs actual I/O (unlike {@link Db.table}, which simply creates an
     * unvalidated reference to a table).
     *
     * ---
     *
     * ##### Overloads
     *
     * This overload of `createTable` uses the provided `Schema` type to type the Table.
     *
     * > **💡Tip**: It's recommended to allow TypeScript infer the type of the table from the provided `CreateTableDefinition` for you, via {@link InferTableSchema}. See its documentation for more information.
     *
     * Don't provide a `Schema` type if you want to automagically infer it from the `CreateTableDefinition`.
     *
     * Regardless, here is what a manually-typed table would look like:
     *
     * @example
     * ```ts
     * interface User {
     *   name: string,
     *   dob: DataAPIDate,
     *   friends?: Set<string>,
     * }
     *
     * type UserPK = Pick<User, 'name' | 'dob'>;
     *
     * const table = await db.createTable<User, UserPK>('users', {
     *   definition: {
     *     columns: {
     *       name: 'text',
     *       dob: {
     *         type: 'timestamp',
     *       },
     *       friends: {
     *         type: 'set',
     *         valueType: 'text',
     *       },
     *     },
     *     primaryKey: {
     *       partitionBy: ['name'],
     *       partitionSort: { dob: 1 },
     *     },
     *   },
     * });
     *
     * // found :: User | null
     * const found = await table.findOne({});
     * ```
     *
     * ---
     *
     * ##### Idempotency
     *
     * Creating a table is idempotent if the `ifNotExists` option is set to `true`. Otherwise, an error will be thrown if a table with the same name is thrown.
     *
     * > 🚨**Important:** When using `ifNotExists: true`, **only the existence of a table with the same name is checked.**
     * >
     * > If a table with that name already exists, but the columns (or any other options) you define differ from the existing table, **it won’t give you an error**; instead, it'll silently succeed, and the original table schema will be retained.
     *
     * ---
     *
     * ##### Typing the table, and much more information
     *
     * > **💡Tip:** You can use {@link InferTableSchema} to infer the TS-equivalent-type of the table from the provided `CreateTableDefinition`.
     *
     * See the {@link Table} class's documentation for information on how and why the {@link Table} class is typed, any disclaimers related to it, and for so much more information in general.
     *
     * @param name - The name of the table to create.
     * @param options - Options for the table.
     *
     * @returns A promised reference to the newly created table.
     *
     * @see SomeRow
     * @see db.table
     * @see InferTableSchema
     * @see InferTablePrimaryKey
     * @see CreateTableDefinition
     */
    createTable<WSchema extends SomeRow, PKeys extends SomePKey = Partial<FoundRow<WSchema>>, RSchema extends SomeRow = FoundRow<WSchema>>(name: string, options: CreateTableOptions): Promise<Table<WSchema, PKeys, RSchema>>;
    /**
     * ##### Overview
     *
     * Drops a collection from the database, including all the contained documents.
     *
     * You can also specify a keyspace in the options parameter, which will override the working keyspace for this `Db`
     * instance.
     *
     * @example
     * ```typescript
     * // Uses db's working keyspace
     * const success1 = await db.dropCollection('users');
     * console.log(success1); // true
     *
     * // Overrides db's working keyspace
     * const success2 = await db.dropCollection('users', {
     *   keyspace: 'my_keyspace'
     * });
     * console.log(success2); // true
     * ```
     *
     * ---
     *
     * ##### Idempotency
     *
     * Dropping a collection is entirely idempotent; if the collection doesn't exist, it will simply do nothing.
     *
     * @param name - The name of the collection to drop.
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to `true` if the collection was dropped successfully.
     *
     * @remarks Use with caution. Have steel-toe boots on. Don't say I didn't warn you.
     */
    dropCollection(name: string, options?: DropCollectionOptions): Promise<void>;
    /**
     * ##### Overview
     *
     * Drops a table from the database, including all the contained rows.
     *
     * You can also specify a keyspace in the options parameter, which will override the working keyspace for this `Db`
     * instance.
     *
     * @example
     * ```typescript
     * // Uses db's working keyspace
     * const success1 = await db.dropTable('users');
     * console.log(success1); // true
     *
     * // Overrides db's working keyspace
     * const success2 = await db.dropTable('users', {
     *   keyspace: 'my_keyspace'
     * });
     * console.log(success2); // true
     * ```
     *
     * ---
     *
     * ##### Idempotency
     *
     * Dropping a table is entirely idempotent, _if_ the `ifExists` option is set to `true`, in which case, if the table doesn't exist, it will simply do nothing.
     *
     * If `ifExists` is `false` or unset, an error will be thrown if the table does not exist.
     *
     * @param name - The name of the table to drop.
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to `true` if the table was dropped successfully.
     *
     * @remarks Use with caution. Wear a mask. Don't say I didn't warn you.
     */
    dropTable(name: string, options?: DropTableOptions): Promise<void>;
    /**
     * ##### Overview
     *
     * Drops an index from the keyspace.
     *
     * See {@link Table.createIndex} & {@link Table.createVectorIndex} about creating indexes in the first place.
     *
     * ---
     *
     * ##### Name uniqueness
     *
     * > **🚨Important**: The name of the index is unique per keyspace.
     *
     * _This is why this is a database-level command: to make it clear that the index is being dropped from the keyspace, and not a specific table._
     *
     * ---
     *
     * ##### Idempotency
     *
     * Dropping an index is entirely idempotent, if the `ifExists` option is set to `true`, in which case, if the index doesn't exist, it will simply do nothing.
     *
     * If `ifExists` is `false` or unset, an error will be thrown if the index does not exist.
     *
     * @param name - The name of the index to drop.
     * @param options - The options for this operation.
     *
     * @returns A promise that resolves when the index is dropped.
     */
    dropTableIndex(name: string, options?: TableDropIndexOptions): Promise<void>;
    /**
     * ##### Overview (name-only overload)
     *
     * Lists the collection names in the database.
     *
     * > **💡Tip:** If you want to include the collections' options in the response, set `nameOnly` to `false` (or omit it completely) to use the other `listCollections` overload.
     *
     * You can specify a keyspace in the options parameter, which will override the working keyspace for this `Db`
     * instance.
     *
     * @example
     * ```typescript
     * // ['users', 'posts']
     * console.log(await db.listCollections({ nameOnly: true }));
     * ```
     *
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to an array of collection names.
     */
    listCollections(options: ListCollectionsOptions & {
        nameOnly: true;
    }): Promise<string[]>;
    /**
     * ##### Overview (full-info overload)
     *
     * Lists the collections in the database.
     *
     * > **💡Tip:** If you want to use only the collection names, set `nameOnly` to `true` to use the other `listCollections` overload.
     *
     * You can specify a keyspace in the options parameter, which will override the working keyspace for this `Db`
     * instance.
     *
     * @example
     * ```typescript
     * // [{ name: 'users' }, { name: 'posts', options: { ... } }]
     * console.log(await db.listCollections());
     * ```
     *
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to an array of collection info.
     */
    listCollections(options?: ListCollectionsOptions & {
        nameOnly?: false;
    }): Promise<CollectionDescriptor[]>;
    /**
     * ##### Overview (name-only overload)
     *
     * Lists the table names in the database.
     *
     * > **💡Tip:** If you want to include the tables' options in the response, set `nameOnly` to `false` (or omit it completely) to use the other `listTables` overload.
     *
     * You can specify a keyspace in the options parameter, which will override the working keyspace for this `Db`
     * instance.
     *
     * @example
     * ```typescript
     * // ['users', 'posts']
     * console.log(await db.listTables({ nameOnly: true }));
     * ```
     *
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to an array of table names.
     */
    listTables(options: ListTablesOptions & {
        nameOnly: true;
    }): Promise<string[]>;
    /**
     * ##### Overview (full-info overload)
     *
     * Lists the tables in the database.
     *
     * > **💡Tip:** If you want to use only the table names, set `nameOnly` to `true` to use the other `listTables` overload.
     *
     * You can specify a keyspace in the options parameter, which will override the working keyspace for this `Db`
     * instance.
     *
     * @example
     * ```typescript
     * // [{ name: 'users' }, { name: 'posts', definition: { ... } }]
     * console.log(await db.listTables());
     * ```
     *
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to an array of table info.
     */
    listTables(options?: ListTablesOptions & {
        nameOnly?: false;
    }): Promise<TableDescriptor[]>;
    /**
     * ##### Overview
     *
     * Sends a POST request to the Data API for this database with an arbitrary, caller-provided payload.
     *
     * You can specify a table/collection to target in the options parameter, thereby allowing you to perform
     * arbitrary table/collection-level operations as well.
     *
     * If the keyspace is set to `null`, the command will be run at the database level.
     *
     * If no table/collection is specified, the command will be executed at the keyspace level.
     *
     * You can also specify a keyspace in the options parameter, which will override the working keyspace for this `Db`
     * instance.
     *
     * @example
     * ```typescript
     * const colls = await db.command({ findCollections: {} });
     * console.log(colls); // { status: { collections: ['users'] } }
     *
     * const user = await db.command({ findOne: {} }, { collection: 'users' });
     * console.log(user); // { data: { document: null } }
     *
     * const post = await db.command({ findOne: {} }, { table: 'posts' });
     * console.log(post); // { data: { document: null } }
     * ```
     *
     * @param command - The command to send to the Data API.
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to the raw response from the Data API.
     */
    command(command: Record<string, any>, options?: RunCommandOptions): Promise<RawDataAPIResponse>;
    /**
     * Backdoor to the HTTP client for if it's absolutely necessary. Which it almost never (if even ever) is.
     */
    get _httpClient(): OpaqueHttpClient;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - The `namespace` terminology has been removed, and replaced with `keyspace` throughout the client.
     */
    useNamespace: 'ERROR: The `namespace` terminology has been removed, and replaced with `keyspace` throughout the client';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - `.collections` has been removed. Use `.listCollections` with `.map` instead (`await db.listCollections({ nameOnly: true }).then(cs => cs.map(c => db.collection(c))`)
     */
    collections: 'ERROR: `.collections` has been removed. Use `.listCollections` with `.map` instead';
}

/**
 * Represents some DatabaseAdmin class used for managing some specific database.
 *
 * This abstract version lists the core functionalities that any database admin class may have, but
 * subclasses may have additional methods or properties (e.g. {@link AstraDbAdmin}).
 *
 * Use {@link Db.admin} or {@link AstraAdmin.dbAdmin} to obtain an instance of this class.
 *
 * @public
 */
export declare abstract class DbAdmin extends HierarchicalLogger<AdminCommandEventMap> {
    /**
     * Gets the underlying `Db` object. The options for the db were set when the DbAdmin instance, or whatever spawned
     * it, was created.
     *
     * @example
     * ```typescript
     * const dbAdmin = client.admin().dbAdmin('<endpoint>', {
     *   keyspace: 'my_keyspace',
     *   useHttp2: false,
     * });
     *
     * const db = dbAdmin.db();
     * console.log(db.id);
     * ```
     *
     * @returns The underlying `Db` object.
     */
    abstract db(): Db;
    /**
     * Retrieves a list of all the keyspaces in the database.
     *
     * Semantic order is not guaranteed, but implementations are free to assign one. {@link AstraDbAdmin}, for example,
     * always has the first keyspace in the array be the default one.
     *
     * @example
     * ```typescript
     * const keyspaces = await dbAdmin.listKeyspaces();
     *
     * // ['default_keyspace', 'my_other_keyspace']
     * console.log(keyspaces);
     * ```
     *
     * @returns A promise that resolves to list of all the keyspaces in the database.
     */
    abstract listKeyspaces(options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<string[]>;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - The `namespace` terminology has been removed, and replaced with `keyspace` throughout the client.
     */
    listNamespaces: 'ERROR: The `namespace` terminology has been removed, and replaced with `keyspace` throughout the client';
    /**
     * Creates a new, additional, keyspace for this database.
     *
     * **NB. this is a "long-running" operation. See {@link AstraAdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 1 second. Expect it to take roughly 8-10 seconds to complete.
     *
     * @example
     * ```typescript
     * await dbAdmin.createKeyspace('my_other_keyspace1');
     *
     * // ['default_keyspace', 'my_other_keyspace1']
     * console.log(await dbAdmin.listKeyspaces());
     *
     * await dbAdmin.createKeyspace('my_other_keyspace2', {
     *   blocking: false,
     * });
     *
     * // Will not include 'my_other_keyspace2' until the operation completes
     * console.log(await dbAdmin.listKeyspaces());
     * ```
     *
     * @remarks
     * Note that if you choose not to block, the created keyspace will not be able to be used until the
     * operation completes, which is up to the caller to determine.
     *
     * @param keyspace - The name of the new keyspace.
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     */
    abstract createKeyspace(keyspace: string, options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<void>;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - The `namespace` terminology has been removed, and replaced with `keyspace` throughout the client.
     */
    createNamespace: 'ERROR: The `namespace` terminology has been removed, and replaced with `keyspace` throughout the client';
    /**
     * Drops a keyspace from this database.
     *
     * **NB. this is a "long-running" operation. See {@link AstraAdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 1 second. Expect it to take roughly 8-10 seconds to complete.
     *
     * @example
     * ```typescript
     * await dbAdmin.dropKeyspace('my_other_keyspace1');
     *
     * // ['default_keyspace', 'my_other_keyspace2']
     * console.log(await dbAdmin.listKeyspaces());
     *
     * await dbAdmin.dropKeyspace('my_other_keyspace2', {
     *   blocking: false,
     * });
     *
     * // Will still include 'my_other_keyspace2' until the operation completes
     * // ['default_keyspace', 'my_other_keyspace2']
     * console.log(await dbAdmin.listKeyspaces());
     * ```
     *
     * @remarks
     * Note that if you choose not to block, the keyspace will still be able to be used until the operation
     * completes, which is up to the caller to determine.
     *
     * @param keyspace - The name of the keyspace to drop.
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     */
    abstract dropKeyspace(keyspace: string, options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<void>;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - The `namespace` terminology has been removed, and replaced with `keyspace` throughout the client.
     */
    dropNamespace: 'ERROR: The `namespace` terminology has been removed, and replaced with `keyspace` throughout the client';
    /**
     * Returns detailed information about the availability and usage of the vectorize embedding providers available on the
     * current database (may vary based on cloud provider & region).
     *
     * @example
     * ```typescript
     * const { embeddingProviders } = await dbAdmin.findEmbeddingProviders();
     *
     * // ['text-embedding-3-small', 'text-embedding-3-large', 'text-embedding-ada-002']
     * console.log(embeddingProviders['openai'].models.map(m => m.name));
     * ```
     *
     * @param options - The options for the timeout of the operation.
     *
     * @returns The available embedding providers.
     */
    findEmbeddingProviders(options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<FindEmbeddingProvidersResult>;
    /**
     * Returns detailed information about the availability and usage of the reranking providers available on the
     * current database (may vary based on cloud provider & region).
     *
     * @example
     * ```typescript
     * const { rerankingProviders } = await dbAdmin.findRerankingProviders();
     *
     * // ['nvidia/llama-3.2-nv-rerankqa-1b-v2']
     * console.log(rerankingProviders['nvidia'].models.map(m => m.name));
     * ```
     *
     * @param options - The options for the timeout of the operation.
     *
     * @returns The available reranking providers.
     */
    findRerankingProviders(options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<FindRerankingProvidersResult>;
    /* Excluded from this release type: _getDataAPIHttpClient */
}

/**
 * The options available spawning a new {@link Db} instance.
 *
 * If any of these options are not provided, the client will use the default options provided by the {@link DataAPIClient}.
 *
 * @public
 */
export declare interface DbOptions {
    /**
     * The configuration for logging events emitted by the {@link DataAPIClient}.
     *
     * This can be set at any level of the major class hierarchy, and will be inherited by all child classes.
     *
     * See {@link LoggingConfig} for *much* more information on configuration, outputs, and inheritance.
     */
    logging?: LoggingConfig;
    /**
     * The keyspace to use for the database.
     *
     * There are a few rules for what the default keyspace will be:
     * 1. If a keyspace was provided when creating the {@link DataAPIClient}, it will default to that value.
     * 2. If using an `astra` database, it'll default to "default_keyspace".
     * 3. Otherwise, no default will be set, and it'll be on the user to provide one when necessary.
     *
     * The client itself will not throw an error if an invalid keyspace (or even no keyspace at all) is provided—it'll
     * let the Data API propagate the error itself.
     *
     * Every db method will use this keyspace as the default keyspace, but they all allow you to override it
     * in their options.
     *
     * @example
     * ```typescript
     * const client = new DataAPIClient('AstraCS:...');
     *
     * // Using 'default_keyspace' as the keyspace
     * const db1 = client.db('https://<db_id>-<region>.apps.astra.datastax.com');
     *
     * // Using 'my_keyspace' as the keyspace
     * const db2 = client.db('https://<db_id>-<region>.apps.astra.datastax.com', {
     *   keyspace: 'my_keyspace',
     * });
     *
     * // Finds 'my_collection' in 'default_keyspace'
     * const coll1 = db1.collections('my_collection');
     *
     * // Finds 'my_collection' in 'my_keyspace'
     * const coll2 = db1.collections('my_collection');
     *
     * // Finds 'my_collection' in 'other_keyspace'
     * const coll3 = db1.collections('my_collection', { keyspace: 'other_keyspace' });
     * ```
     *
     * @defaultValue 'default_keyspace'
     */
    keyspace?: string | null;
    /**
     * The access token for the Data API, typically of the format `'AstraCS:...'`.
     *
     * If never provided, this will default to the token provided when creating the {@link DataAPIClient}.
     *
     * @example
     * ```typescript
     * const client = new DataAPIClient('strong-token');
     *
     * // Using 'strong-token' as the token
     * const db1 = client.db('https://<db_id>-<region>.apps.astra.datastax.com');
     *
     * // Using 'weaker-token' instead of 'strong-token'
     * const db2 = client.db('https://<db_id>-<region>.apps.astra.datastax.com', {
     *   token: 'weaker-token',
     * });
     * ```
     */
    token?: string | TokenProvider | null;
    /**
     * The path to the Data API, which is going to be `api/json/v1` for all Astra instances. However, it may vary
     * if you're using a different Data API-compatible endpoint.
     *
     * Defaults to `'api/json/v1'` if never provided. However, if it was provided when creating the {@link DataAPIClient},
     * it will default to that value instead.
     *
     * @defaultValue 'api/json/v1'
     */
    dataApiPath?: string;
    /**
     * Advanced & currently somewhat unstable features related to customizing the client's ser/des behavior at a lower level.
     *
     * Use with caution. See official DataStax documentation for more info.
     *
     * @beta
     */
    serdes?: DbSerDesConfig;
    /**
     * ##### Overview
     *
     * The default timeout options for anything spawned by this {@link Db} instance.
     *
     * See {@link TimeoutDescriptor} for much more information about timeouts.
     *
     * @example
     * ```ts
     * // The request timeout for all operations is set to 1000ms.
     * const client = new DataAPIClient('...', {
     *   timeoutDefaults: { requestTimeoutMs: 1000 },
     * });
     *
     * // The request timeout for all operations borne from this Db is set to 2000ms.
     * const db = client.db('...', {
     *   timeoutDefaults: { requestTimeoutMs: 2000 },
     * });
     * ```
     *
     * ##### Inheritance
     *
     * The timeout options are inherited by all child classes, and can be overridden at any level, including the individual method level.
     *
     * Individual-method-level overrides can vary in behavior depending on the method; again, see {@link TimeoutDescriptor}.
     *
     * ##### Defaults
     *
     * The default timeout options are as follows:
     * - `requestTimeoutMs`: 15000
     * - `generalMethodTimeoutMs`: 30000
     * - `collectionAdminTimeoutMs`: 60000
     * - `tableAdminTimeoutMs`: 30000
     * - `databaseAdminTimeoutMs`: 600000
     * - `keyspaceAdminTimeoutMs`: 30000
     *
     * @see TimeoutDescriptor
     */
    timeoutDefaults?: Partial<TimeoutDescriptor>;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - `monitorCommands` has been overhauled, and replaced with the `logging` option. Please see its documentation for more information.
     */
    monitorCommands?: 'ERROR: `monitorCommands` has been overhauled, and replaced with the `logging` option. Please see its documentation for more information';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - The `namespace` terminology has been removed, and replaced with `keyspace` throughout the client.
     */
    namespace?: 'ERROR: The `namespace` terminology has been removed, and replaced with `keyspace` throughout the client';
}

/* Excluded from this release type: DbOptsHandler */

/**
 * ##### Overview
 *
 * The config for table/collection serialization/deserialization options.
 *
 * See {@link TableSerDesConfig} and {@link CollectionSerDesConfig} for more much information on the available options.
 *
 * Such options include:
 *  - Enabling the `mutateInPlace` optimization for serializing rows/documents
 *  - Enabling big number support for collections
 *  - Enabling "sparse data" for tables
 *  - Implementing custom serialization/deserialization logic through codecs
 *    - (e.g. custom data types, validation, etc.)
 *
 * ##### Disclaimer
 *
 * Some of these options are advanced features, and should be used with caution. It's possible to break the client's behavior by using these features incorrectly.
 *
 * Unstable features are marked in the documentation as `@alpha` or `@beta`, and may change in the future.
 *
 * @see CollectionSerDesConfig
 * @see TableSerDesConfig
 *
 * @public
 */
export declare interface DbSerDesConfig {
    /**
     * Advanced & currently somewhat unstable features related to customizing spawned tables' ser/des behavior at a lower level.
     *
     * Use with caution. See official DataStax documentation for more info.
     *
     * @beta
     */
    table?: Omit<TableSerDesConfig, 'mutateInPlace'>;
    /**
     * Advanced & currently somewhat unstable features related to customizing spawned collections' ser/des behavior at a lower level.
     *
     * Use with caution. See official DataStax documentation for more info.
     *
     * @beta
     */
    collection?: Omit<CollectionSerDesConfig, 'mutateInPlace'>;
    /**
     * ##### Overview
     *
     * Enables an optimization which allows inserted rows/documents to be mutated in-place when serializing, instead of cloning them before serialization.
     *
     * Stable. Will mutate filters & update filters as well.
     *
     * See {@link BaseSerDesConfig.mutateInPlace} for more information.
     *
     * @defaultValue false
     */
    mutateInPlace?: boolean;
}

/* Excluded from this release type: decoder */

/* Excluded from this release type: decoderFromObj */

/* Excluded from this release type: decoderFromStr */

/**
 * The default keyspace used when no keyspace is explicitly provided on DB creation.
 *
 * @public
 */
export declare const DEFAULT_KEYSPACE = "default_keyspace";

/**
 * @public
 */
export declare interface Deserializers<DesCtx> {
    forName: Record<string, SerDesFn<DesCtx>[]>;
    forType: Record<string, SerDesFn<DesCtx>[]>;
    forPath: Record<number, {
        path: readonly PathSegment[];
        fns: SerDesFn<DesCtx>[];
    }[]>;
    forGuard: {
        guard: SerDesGuard<DesCtx>;
        fn: SerDesFn<DesCtx>;
    }[];
}

/**
 * An abstract class representing *some* exception that occurred related to the DevOps API. This is the base class for all
 * DevOps API errors, and will never be thrown directly.
 *
 * Useful for `instanceof` checks.
 *
 * @public
 */
export declare abstract class DevOpsAPIError extends Error {
}

/**
 * A representation of what went wrong when interacting with the DevOps API.
 *
 * @field id - The API-specific error code.
 * @field message - A user-friendly error message, if one exists (it most often does).
 *
 * @public
 */
export declare interface DevOpsAPIErrorDescriptor {
    /**
     * The API-specific error code.
     */
    id: number;
    /**
     * A user-friendly error message, if one exists (it most often does).
     */
    message?: string;
}

/* Excluded from this release type: DevOpsAPIRequestInfo */

/**
 * An error representing a response from the DevOps API that was not successful (non-2XX status code).
 *
 * @field errors - The error descriptors returned by the API to describe what went wrong.
 * @field rootError - The raw axios error that was thrown.
 * @field status - The HTTP status code of the response, if available.
 *
 * @public
 */
export declare class DevOpsAPIResponseError extends DevOpsAPIError {
    /**
     * The error descriptors returned by the API to describe what went wrong.
     */
    readonly errors: DevOpsAPIErrorDescriptor[];
    /**
     * The HTTP status code of the response, if available.
     */
    readonly status: number;
    /**
     * The "raw", errored response from the API.
     */
    readonly raw: FetcherResponseInfo;
    /* Excluded from this release type: __constructor */
}

/**
 * An error thrown when an admin operation timed out.
 *
 * Depending on the method, this may be a request timeout occurring during a specific HTTP request, or can happen over
 * the course of a method involving several requests in a row, such as a blocking `createDatabase`.
 *
 * @field url - The URL that the request was made to.
 * @field timeout - The timeout that was set for the operation, in milliseconds.
 *
 * @public
 */
export declare class DevOpsAPITimeoutError extends DevOpsAPIError {
    /**
     * The URL that the request was made to.
     */
    readonly url: string;
    /**
     The timeout that was set for the operation, in milliseconds.
     */
    readonly timeout: Partial<TimeoutDescriptor>;
    /**
     * Represents which timeouts timed out (e.g. `'requestTimeoutMs'`, `'tableAdminTimeoutMs'`, the provided timeout, etc.)
     */
    readonly timedOutCategories: TimedOutCategories;
    /* Excluded from this release type: __constructor */
    /* Excluded from this release type: mk */
}

/**
 * Represents the options for dropping an astra keyspace (i.e. blocking options + timeout options).
 *
 * @public
 */
export declare type DropAstraKeyspaceOptions = AstraAdminBlockingOptions & WithTimeout<'keyspaceAdminTimeoutMs'>;

/**
 * Options for dropping a collections.
 *
 * @field keyspace - Overrides the keyspace for the collections.
 * @field timeout - The timeout override for this method
 *
 * @see Db.dropCollection
 *
 * @public
 */
export declare interface DropCollectionOptions extends WithTimeout<'collectionAdminTimeoutMs'>, WithKeyspace {
}

/**
 * An operation to drop columns from the table.
 *
 * @public
 */
export declare interface DropColumnOperation<Schema extends SomeRow> {
    /**
     * The columns to drop from the table.
     */
    columns: (keyof Schema & string)[];
}

/**
 * @public
 */
export declare type DropRerankingOperation = Record<never, never>;

/**
 * The options for dropping a table (via {@link Db.dropTable}).
 *
 * @public
 */
export declare interface DropTableOptions extends WithTimeout<'tableAdminTimeoutMs'>, WithKeyspace {
    /**
     * If `true`, no error will be thrown if the table does not exist.
     *
     * Defaults to `false`.
     */
    ifExists?: boolean;
}

/**
 * An operation to disable vectorize (auto-embedding-generation) on existing vector columns on the table.
 *
 * @public
 */
export declare interface DropVectorizeOperation<Schema extends SomeRow> {
    /**
     * The columns to disable vectorize on.
     */
    columns: (keyof Schema & string)[];
}

/**
 * ##### Overview
 *
 * A shorthand function-object for {@link DataAPIDuration}. May be used anywhere when creating new `DataAPIDuration`s.
 *
 * See {@link DataAPIDuration} and its methods for information about input parameters, formats, functions, etc.
 *
 * @example
 * ```ts
 * // equiv. to `new DataAPIDuration('-2w')`
 * duration('-2w')
 *
 * // equiv. to `new DataAPIDuration(2, 1, 0)`
 * duration(12, 1, 0)
 *
 * // equiv. to `DataAPIDuration.builder().build()`
 * duration.builder().build()
 * ```
 *
 * @see DataAPIDuration
 *
 * @public
 */
export declare const duration: ((...params: [string] | [DataAPIDuration] | [number, number, number | bigint]) => DataAPIDuration) & {
    builder: typeof DataAPIDuration.builder;
};

/**
 * ##### Overview
 *
 * The most basic embedding header provider, used for the vast majority of providers.
 *
 * Generally, anywhere this can be used in the public `astra-db-ts` interfaces, you may also pass in a plain
 * string or null/undefined, which is transformed into an {@link EmbeddingAPIKeyHeaderProvider} under the hood.
 *
 * @example
 * ```typescript
 * const provider = new EmbeddingAPIKeyHeaderProvider('api-key');
 * const collections = await db.collections('my_coll', { embeddingApiKey: provider });
 *
 * // or just
 * const collections = await db.collections('my_coll', { embeddingApiKey: 'api-key' });
 * ```
 *
 * @see EmbeddingHeadersProvider
 *
 * @public
 */
export declare class EmbeddingAPIKeyHeaderProvider extends StaticHeadersProvider<'embedding'> {
    /**
     * Constructs an instead of the {@link EmbeddingAPIKeyHeaderProvider}.
     *
     * @param apiKey - The api-key/token to regurgitate in `getToken`
     */
    constructor(apiKey: string | nullish);
    /* Excluded from this release type: parse */
}

export declare type EmbeddingHeadersProvider = HeadersProvider<'embedding'>;

/**
 * Information about a specific auth method, such as `HEADER`, `SHARED_SECRET`, or `NONE` for a specific provider. See
 * {@link EmbeddingProviderInfo.supportedAuthentication} for more information.
 *
 * See {@link EmbeddingHeadersProvider} for more info about the `HEADER` auth through the client.
 *
 * @example
 * ```typescript
 * // openai.supportedAuthentication.HEADER:
 * {
 *   enabled: true,
 *   tokens: [{
 *     accepted: 'x-embedding-api-key',
 *     forwarded: 'Authorization',
 *   }],
 * }
 * ```
 *
 * @field enabled - Whether this method of auth is supported for the provider.
 * @field tokens - Additional info on how exactly this method of auth is supposed to be used.
 *
 * @see EmbeddingProviderInfo
 *
 * @public
 */
export declare interface EmbeddingProviderAuthInfo {
    /**
     * Whether this method of auth is supported for the provider.
     */
    enabled: boolean;
    /**
     * Additional info on how exactly this method of auth is supposed to be used.
     *
     * See {@link EmbeddingHeadersProvider} for more info about the `HEADER` auth through the client.
     *
     * Will be an empty array if `enabled` is `false`.
     */
    tokens: EmbeddingProviderTokenInfo[];
}

/**
 * Info about a specific embedding provider
 *
 * @field displayName - The prettified name of the provider (as shown in the portal)
 * @field url - The embeddings endpoint used for the provider
 * @field supportedAuthentication - Enabled methods of auth for the provider
 * @field parameters - Any additional parameters the provider may take in
 * @field models - The specific models that the provider supports
 *
 * @see FindEmbeddingProvidersResult
 *
 * @public
 */
export declare interface EmbeddingProviderInfo {
    /**
     * The prettified name of the provider (as shown in the Astra portal).
     *
     * @example
     * ```typescript
     * // openai.displayName:
     * 'OpenAI'
     * ```
     */
    displayName: string;
    /**
     * The embeddings endpoint used for the provider.
     *
     * May use a Python f-string-style string interpolation pattern for certain providers which take in additional
     * parameters (such as `huggingfaceDedicated` or `azureOpenAI`).
     *
     * @example
     * ```typescript
     * // openai.url:
     * 'https://api.openai.com/v1/'
     *
     * // huggingfaceDedicated.url:
     * 'https://{endpointName}.{regionName}.{cloudName}.endpoints.huggingface.cloud/embeddings'
     * ```
     */
    url: string;
    /**
     * Supported methods of authentication for the provider.
     *
     * Possible methods include `HEADER`, `SHARED_SECRET`, and `NONE`.
     *
     * - `HEADER`: Authentication using direct API keys passed through headers on every Data API call.
     * See {@link EmbeddingHeadersProvider} for more info.
     * ```typescript
     * const collections = await db.createCollection('my_coll', {
     *   vector: {
     *     service: {
     *       provider: 'openai',
     *       modelName: 'text-embedding-3-small',
     *       authentication: {
     *         // Name of the key in Astra portal's OpenAI integration (KMS).
     *         providerKey: '*KEY_NAME*',
     *       },
     *     },
     *   },
     * });
     * ```
     *
     * - `SHARED_SECRET`: Authentication tied to a collections at collections creation time using the Astra KMS.
     * ```typescript
     * const collections = await db.collections('my_coll', {
     *   // Not tied to the collections; can be different every time.
     *   embeddingApiKey: 'sk-...',
     * });
     * ```
     *
     * - `NONE`: For when a client doesn't need authentication to use (e.g. nvidia).
     * ```typescript
     * const collections = await db.createCollection('my_coll', {
     *   vector: {
     *     service: {
     *       provider: 'nvidia',
     *       modelName: 'NV-Embed-QA',
     *     },
     *   },
     * });
     * ```
     *
     * @example
     * ```typescript
     * // openai.supportedAuthentication.HEADER:
     * {
     *   enabled: true,
     *   tokens: [{
     *     accepted: 'x-embedding-api-key',
     *     forwarded: 'Authorization',
     *   }],
     * }
     * ```
     */
    supportedAuthentication: Record<string, EmbeddingProviderAuthInfo>;
    /**
     * Any additional, arbitrary parameters the provider may take in. May or may not be required.
     *
     * Passed into the `parameters` block in {@link VectorizeServiceOptions} (except for `vectorDimension`).
     *
     * @example
     * ```typescript
     * // openai.parameters[1]
     * {
     *   name: 'projectId',
     *   type: 'STRING',
     *   required: false,
     *   defaultValue: '',
     *   validation: {},
     *   help: 'Optional, OpenAI Project ID. If provided passed as `OpenAI-Project` header.',
     * }
     * ```
     */
    parameters: EmbeddingProviderProviderParameterInfo[];
    /**
     * The specific models that the provider supports.
     *
     * May include an `endpoint-defined-model` for some providers, such as `huggingfaceDedicated`, where the model
     * may be truly arbitrary.
     *
     * @example
     * ```typescript
     * // nvidia.models[0]
     * {
     *   name: 'NV-Embed-QA',
     *   vectorDimension: 1024,
     *   parameters: [],
     * }
     *
     * // huggingfaceDedicated.models[0]
     * {
     *   name: 'endpoint-defined-model',
     *   vectorDimension: null,
     *   parameters: [{
     *     name: 'vectorDimension',
     *     type: 'number',
     *     required: true,
     *     defaultValue: '',
     *     validation: {
     *       numericRange: [2, 3072],
     *     },
     *     help: 'Vector dimension to use in the database, should be the same as ...',
     *   }],
     * }
     * ```
     */
    models: EmbeddingProviderModelInfo[];
}

/**
 * The specific models that the provider supports.
 *
 * May include an `endpoint-defined-model` for some providers, such as `huggingfaceDedicated`, where the model
 * may be truly arbitrary.
 *
 * @example
 * ```typescript
 * // nvidia.models[0]
 * {
 *   name: 'NV-Embed-QA',
 *   vectorDimension: 1024,
 *   parameters: [],
 * }
 * ```
 *
 * @field name - The name of the model to use
 * @field vectorDimension - The preset, exact vector dimension to be used (if applicable)
 * @field parameters - Any additional parameters the model may take in
 *
 * @see EmbeddingProviderInfo
 *
 * @public
 */
export declare interface EmbeddingProviderModelInfo {
    /**
     * The name of the model to use.
     *
     * May be `endpoint-defined-model` for some providers, such as `huggingfaceDedicated`, where the model
     * may be truly arbitrary.
     *
     * @example
     * ```typescript
     * // openai.models[0].name
     * 'text-embedding-3-small'
     *
     * // huggingfaceDedicated.models[0].name
     * 'endpoint-defined-model'
     * ```
     */
    name: string;
    /**
     * The preset, exact vector dimension to be used (if applicable).
     *
     * If not present, a `vectorDimension` parameter will be present in the `model.parameters` block.
     *
     * @example
     * ```typescript
     * // openai.models[3].vectorDimension (text-embedding-ada-002)
     * 1536
     *
     * // huggingfaceDedicated.models[0].vectorDimension (endpoint-defined-model)
     * null
     * ```
     */
    vectorDimension: number | null;
    /**
     * Any additional, arbitrary parameters the modem may take in. May or may not be required.
     *
     * Passed into the `parameters` block in {@link VectorizeServiceOptions} (except for `vectorDimension`).
     *
     * @example
     * ```typescript
     * // openai.models[0].parameters[0] (text-embedding-3-small)
     * {
     *   name: 'vectorDimension',
     *   type: 'number',
     *   required: true,
     *   defaultValue: '1536',
     *   validation: { numericRange: [2, 1536] },
     *   help: 'Vector dimension to use in the database and when calling OpenAI.',
     * }
     * ```
     */
    parameters: EmbeddingProviderModelParameterInfo[];
}

/**
 * Info about any additional, arbitrary parameter the model may take in. May or may not be required.
 *
 * Passed into the `parameters` block in {@link VectorizeServiceOptions} (except for `vectorDimension`, which should be
 * set in the upper-level `dimension: number` field).
 *
 * @example
 * ```typescript
 * // openai.parameters[1]
 * {
 *   name: 'vectorDimension',
 *   type: 'number',
 *   required: true,
 *   defaultValue: '1536',
 *   validation: { numericRange: [2, 1536] },
 *   help: 'Vector dimension to use in the database and when calling OpenAI.',
 * }
 * ```
 *
 * @field name - The name of the parameter to be passed in.
 * @field type - The datatype of the parameter.
 * @field required - Whether the parameter is required to be passed in.
 * @field defaultValue - The default value of the provider, or an empty string if there is none.
 * @field validation - Validations that may be done on the inputted value.
 * @field help - Any additional help text/information about the parameter.
 *
 * @see EmbeddingProviderInfo
 * @see EmbeddingProviderModelInfo
 *
 * @public
 */
export declare interface EmbeddingProviderModelParameterInfo {
    /**
     * The name of the parameter to be passed in.
     *
     * The one exception is the `vectorDimension` parameter, which should be passed into the `dimension` field of the
     * `vector` block in {@link CollectionVectorOptions}/{@link TableVectorColumnDefinition}.
     *
     * @example
     * ```typescript
     * // huggingface.parameters[0].name
     * endpointName
     * ```
     */
    name: string;
    /**
     * The datatype of the parameter.
     *
     * Commonly `number` or `STRING`.
     *
     * @example
     * ```typescript
     * // huggingface.parameters[0].type
     * STRING
     * ```
     */
    type: string;
    /**
     * Whether the parameter is required to be passed in.
     *
     * @example
     * ```typescript
     * // huggingface.parameters[0].required
     * true
     * ```
     */
    required: boolean;
    /**
     * The default value of the provider, or an empty string if there is none.
     *
     * Will always be in string form (even if the `type` is `'number'`).
     *
     * @example
     * ```typescript
     * // huggingface.parameters[0].defaultValue
     * ''
     * ```
     */
    defaultValue: string;
    /**
     * Validations that may be done on the inputted value.
     *
     * Commonly either an empty record, or `{ numericRange: [<min>, <max>] }`.
     *
     * @example
     * ```typescript
     * // huggingface.parameters[0].validation
     * {}
     * ```
     */
    validation: Record<string, unknown>[];
    /**
     * Any additional help text/information about the parameter.
     *
     * @example
     * ```typescript
     * // huggingface.parameters[0].help
     * 'The name of your Hugging Face dedicated endpoint, the first part of the Endpoint URL.'
     * ```
     */
    help: string;
}

/**
 * Info about any additional, arbitrary parameter the provider may take in. May or may not be required.
 *
 * Passed into the `parameters` block in {@link VectorizeServiceOptions} (except for `vectorDimension`, which should be
 * set in the upper-level `dimension: number` field).
 *
 * @example
 * ```typescript
 * // openai.parameters[1]
 * {
 *   name: 'projectId',
 *   type: 'STRING',
 *   required: false,
 *   defaultValue: '',
 *   validation: {},
 *   help: 'Optional, OpenAI Project ID. If provided passed as `OpenAI-Project` header.',
 *   displayName: 'Organization ID',
 *   hint: 'Add an (optional) organization ID',
 * }
 * ```
 *
 * @field name - The name of the parameter to be passed in.
 * @field type - The datatype of the parameter.
 * @field required - Whether the parameter is required to be passed in.
 * @field defaultValue - The default value of the provider, or an empty string if there is none.
 * @field validation - Validations that may be done on the inputted value.
 * @field help - Any additional help text/information about the parameter.
 * @field displayName - Display name for the parameter.
 * @field hint - Hint for parameter usage.
 *
 * @see EmbeddingProviderInfo
 * @see EmbeddingProviderModelInfo
 *
 * @public
 */
export declare interface EmbeddingProviderProviderParameterInfo extends EmbeddingProviderModelParameterInfo {
    /**
     * Display name for the parameter.
     *
     * @example
     * ```typescript
     * // openai.parameters[0].displayName
     * 'Organization ID'
     * ```
     */
    displayName: string;
    /**
     * Hint for parameter usage.
     *
     * @example
     * ```typescript
     * // openai.parameters[0].hint
     * 'Add an (optional) organization ID'
     * ```
     */
    hint: string;
}

/**
 * Info on how exactly a method of auth may be used.
 *
 * @example
 * ```typescript
 * // openai.supportedAuthentication.HEADER.tokens[0]:
 * {
 *   accepted: 'x-embedding-api-key',
 *   forwarded: 'Authorization',
 * }
 * ```
 *
 * @field accepted - The accepted token
 * @field forwarded - How the token is forwarded to the embedding provider
 *
 * @see EmbeddingProviderAuthInfo
 *
 * @public
 */
export declare interface EmbeddingProviderTokenInfo {
    /**
     * The accepted token.
     *
     * May most often be `providerKey` for `SHARED_SECRET`, or `x-embedding-api-key` for `HEADER`.
     *
     * See {@link EmbeddingHeadersProvider} for more info about the `HEADER` auth through the client.
     */
    accepted: string;
    /**
     * How the token is forwarded to the embedding provider.
     */
    forwarded: string;
}

/* Excluded from this release type: EmissionStrategy */

/**
 * Utility type to represent an empty object without eslint complaining.
 *
 * @public
 */
export declare type EmptyObj = {};

/* Excluded from this release type: EnvironmentCfgHandler */

/**
 * ##### Overview (template-string overload)
 *
 * Escapes field names which may contain `.`s and `&`s for use in Data API queries.
 *
 * This overload allows you to use a tagged template string to create an escaped field path.
 *
 * > **🚨Important:** This should NOT be used for insertion operations. It is only for use in areas where a field path is required; not just a field name (e.g. filters, projections, updates, etc.)
 *
 * @example
 * ```ts
 * import { escapeFieldNames } from '@datastax/astra-db-ts';
 *
 * // 'websites.www&.datastax&.com.visits'
 * const domain = 'www.datastax.com';
 * escapeFieldNames`websites.${domain}.visits`
 *
 * // 'shows.tom&&jerry.episodes.3.views
 * const episode = 3;
 * escapeFieldNames`shows.${'tom&jerry'}.episodes.${episode}.views`
 * ```
 *
 * @see unescapeFieldPath
 *
 * @public
 */
export declare function escapeFieldNames(segments: TemplateStringsArray, ...args: PathSegment[]): string;

/**
 * ##### Overview (varargs overload)
 *
 * Escapes field names which may contain `.`s and `&`s for use in Data API queries.
 *
 * This overload allows you to pass a variable number of arguments to create an escaped field path.
 *
 * > **🚨Important:** This should NOT be used for insertion operations. It is only for use in areas where a field path is required; not just a field name (e.g. filters, projections, updates, etc.)
 *
 * @example
 * ```ts
 * import { escapeFieldNames } from '@datastax/astra-db-ts';
 *
 * // 'websites.www&.datastax&.com.visits'
 * const domain = 'www.datastax.com';
 * escapeFieldNames('websites', domain, 'visits')
 *
 * // 'shows.tom&&jerry.episodes.3.views
 * const episode = 3;
 * escapeFieldNames('shows', 'tom&jerry', 'episodes', episode, 'views')
 * ```
 *
 * @see unescapeFieldPath
 *
 * @public
 */
export declare function escapeFieldNames(...segments: PathSegment[]): string;

/**
 * ##### Overview (iterable overload)
 *
 * Escapes field names which may contain `.`s and `&`s for use in Data API queries.
 *
 * This over load allows you to pass an iterable (like an array) of segments to create an escaped field path.
 *
 * > **🚨Important:** This should NOT be used for insertion operations. It is only for use in areas where a field path is required; not just a field name (e.g. filters, projections, updates, etc.)
 *
 * @example
 * ```ts
 * import { escapeFieldNames } from '@datastax/astra-db-ts';
 *
 * // 'websites.www&.datastax&.com.visits'
 * const domain = 'www.datastax.com';
 * escapeFieldNames(['websites', domain, 'visits'])
 *
 * // 'shows.tom&&jerry.episodes.3.views
 * const episode = 3;
 * escapeFieldNames(['shows', 'tom&jerry', 'episodes', episode, 'views'])
 * ```
 *
 * @see unescapeFieldPath
 *
 * @public
 */
export declare function escapeFieldNames(segments: Iterable<PathSegment>): string;

/**
 * ##### Overview
 *
 * A function that formats an event into a string.
 *
 * Used with {@link BaseClientEvent.format}, which dictates how the event should be logged to stdout/stderr.
 *
 * There are two ways to use this method:
 * - Pass it to {@link BaseClientEvent.format} if you're manually formatting an event.
 * - Set it as the default formatter using {@link BaseClientEvent.setDefaultFormatter} if you want all events to use the same formatter.
 *   - This is useful if you want to use the default stdout/stderr logging, but still want to customize the format.
 *
 * ##### Default format
 *
 * The default format is `[timestamp] [requestId[0..8]] [eventName]: message`.
 * - The `timestamp` is of the format `YYYY-MM-DD HH:MM:SS TZ`.
 * - The `requestId` is the first 8 characters of the requestId.
 * - The `eventName` is the name of the event.
 * - The `message` is the message generated by the event.
 *
 * For example:
 * ```
 * 2025-02-11 12:24:59 IST [e31bc40e] [CommandFailed]: (default_keyspace.basic_logging_example_table) findOne (took 249ms) - 'Invalid filter expression: filter clause path ('$invalid') contains character(s) not allowed'
 * ```
 *
 * ##### Custom formatter example
 *
 * @example
 * ```ts
 * // Define a custom formatter
 * const customFormatter: EventFormatter = (event, message) => {
 *  return `[${event.requestId.slice(0, 8)}] (${event.name}) - ${message}`;
 * }
 *
 * // Set the custom formatter as the default
 * BaseClientEvent.setDefaultFormatter(customFormatter);
 *
 * // Now all events will use the custom formatter
 * const coll = db.collection('*COLLECTION_NAME*', {
 *   logging: [{ events: 'all', emits: 'stdout' }],
 * });
 *
 * // Logs:
 * // - [e31bc40e] (CommandStarted) - (default_keyspace.basic_logging_example_table) findOne
 * // - [e31bc40e] (CommandFailed) - (default_keyspace.basic_logging_example_table) findOne (took 249ms) - 'Invalid filter expression: filter clause path ('$invalid') contains character(s) not allowed'
 * coll.findOne({ $invalid: 1 });
 * ```
 *
 * @see LoggingConfig
 * @see BaseClientEvent.setDefaultFormatter
 *
 * @public
 */
export declare type EventFormatter = (event: DataAPIClientEvent, fullMessage: string) => string;

/* Excluded from this release type: ExecCmdOpts */

declare type Expand<T> = T extends infer O ? {
    [K in keyof O]: O[K];
} : never;

/**
 * ##### Overview
 *
 * The most explicit way to configure logging, with the ability to set both events and specific outputs.
 *
 * Setting the `emits` field to `[]` will disable logging for the specified events.
 *
 * See {@link DataAPIClientEventMap} & {@link LoggingConfig} for much more info.
 *
 * @see LoggingConfig
 * @see LoggingEvent
 * @see LoggingOutput
 *
 * @public
 */
export declare interface ExplicitLoggingConfig {
    readonly events: LoggingEvent | (Exclude<LoggingEvent, 'all'>)[];
    readonly emits: OneOrMany<LoggingOutput>;
}

/* Excluded from this release type: FetchCtx */

/**
 * ##### Overview
 *
 * A simple adapter interface that allows you to define a custom HTTP request strategy that `astra-db-ts` may use to make requests.
 *
 * See [FetchH2](https://github.com/datastax/astra-db-ts/blob/59bc694ba162337ca68c5d52ec559f4e9c216fb0/src/lib/api/fetch/fetch-h2.ts) and
 * [FetchNative](https://github.com/datastax/astra-db-ts/blob/59bc694ba162337ca68c5d52ec559f4e9c216fb0/src/lib/api/fetch/fetch-native.ts)
 * on the `astra-db-ts` GitHub repo for example implementations.
 *
 * ##### Disclaimer
 *
 * Ensure that you take into account all request information when making the request, or you may run into errors or unexpected behavior from your implementation.
 *
 * Thorough testing is heavily recommended to ensure that your implementation works as expected.
 *
 * If desired, the `astra-db-ts` repo may be forked and have its test suite be run against your custom implementation to ensure complete compatibility.
 *
 * ##### Use cases
 *
 * You may want to use a custom `Fetcher` implementation if:
 * - You want to use a different fetch library (e.g. Axios, Superagent, etc.)
 * - You want to extend an existing fetch implementation with your own custom logic
 * - You want to add extra logging information to the response
 *
 * ##### Implementation
 *
 * It is heavily recommended that you take a look at the aforementioned implementations to get a better idea of how to implement your own.
 *
 * The basic idea is that you create a class or object implementing the `Fetcher` interface, and pass it to `httpOptions` in the `DataAPIClient` constructor.
 *
 * See the {@link Fetcher.fetch} and {@link Fetcher.close} methods for information on how to implement those methods, along with a checklist of things to consider.
 *
 * @example
 * ```ts
 * class CustomFetcher implements Fetcher {
 *   async fetch(info: FetcherRequestInfo): Promise<FetcherResponseInfo> {
 *     // Custom fetch implementation
 *   }
 *
 *   async close(): Promise<void> {
 *     // Custom cleanup logic (optional)
 *   }
 * }
 *
 * const client = new DataAPIClient({
 *   httpOptions: { client: 'custom', fetcher: new CustomFetcher() },
 * });
 * ```
 *
 * @see FetcherRequestInfo
 * @see FetcherResponseInfo
 * @see CustomHttpClientOptions
 *
 * @public
 */
export declare interface Fetcher {
    /**
     * ##### Overview
     *
     * Makes the actual API request for the given request information. Please take all request information into account
     * when making the request, or you may run into errors or unexpected behavior from your implementation.
     *
     * Be sure to check out {@link FetcherRequestInfo} and {@link FetcherResponseInfo} for more information on the input and output objects.
     *
     * ##### What you don't need to worry about
     *
     * - The appropriate `content-type`, `user-agent`, `Authorization`, etc., headers are already set
     * - The body (if present) has already been stringify-ed, and any query parameters, already appended to the URL
     *
     * ##### What you do need to worry about
     *
     * - Make sure the requested HTTP method is used
     *   - Only `GET`, `POST`, `DELETE`, but more may be required in the future
     * - The timeout _must_ be respected using an `AbortSignal` or another valid timeout mechanism.
     *   - e.g. `axios`'s `timeout` option
     * - If a timeout occurs, catch the error and throw `info.mkTimeoutError()` instead.
     *   - This will make a generic timeout error that's uniform between all fetchers
     *   - All other errors should be rethrown as-is
     * - The response headers should be normalized into a plain JS object
     *   - E.g.`Object.fromEntries(resp.headers.entries())`
     * - The response body should be returned as a plain string
     *   - E.g. `await resp.text()`
     * - If `info.forceHttp1` is `true`, ensure the request _only uses `HTTP/1[.1]`_, even if `HTTP/2` is supported.
     *   - This is because the DevOps API does not support `HTTP/2`
     * - Any additional information you want to add to logging output may be included in `extraLogInfo`
     *   - This will be printed if using the `stdout/stderr` {@link LoggingOutput}
     *   - This will be available in {@link BaseClientEvent.extraLogInfo} if using the `event` output
     *
     * @param info - The request information (url, body, method, headers, etc.)
     */
    fetch(info: FetcherRequestInfo): Promise<FetcherResponseInfo>;
    /**
     * ##### Overview
     *
     * This is an optional method which may destroy any resources, if necessary (open connections, etc.).
     *
     * Called on {@link DataAPIClient.close}.
     */
    close?(): Promise<void>;
}

/**
 * ##### Overview
 *
 * Represents the request information required to make an API request using a {@link Fetcher}.
 *
 * Implementers should ensure that **all request properties** are correctly handled when making a request.
 * Failing to do so may result in errors or unexpected behavior.
 *
 * ##### Key points of note
 *
 * - The URL is already formatted, including query parameters.
 * - The body (if present) is already `JSON.stringify`-ed.
 * - The appropriate headers (e.g., `content-type`, `user-agent`) are set but may be overridden.
 * - The correct HTTP method must be used.
 * - The timeout must be respected.
 * - The request may need to force HTTP/1.1 instead of HTTP/2.
 *
 * @see Fetcher
 * @see FetcherResponseInfo
 *
 * @public
 */
export declare interface FetcherRequestInfo {
    /**
     * ##### Overview
     *
     * The full URL to which the request should be made.
     *
     * This URL is preformatted, and already includes any necessary query parameters.
     */
    url: string;
    /**
     * ##### Overview
     *
     * The `JSON.stringify`-ed body of the request, if applicable.
     *
     * The `content-type` header is already present in {@link FetcherResponseInfo.headers}, so it's not necessary to set it yourself.
     */
    body: string | undefined;
    /**
     * ##### Overview
     *
     * The HTTP method to use for the request.
     *
     * Currently used methods:
     * - `GET`
     * - `POST`
     * - `DELETE`
     *
     * Future updates may require additional methods.
     */
    method: 'DELETE' | 'GET' | 'POST';
    /**
     * ##### Overview
     *
     * The base headers to include in the request.
     *
     * - These headers are preconfigured but may be modified or overridden as necessary.
     * - Ensure that required headers are correctly forwarded.
     *
     * ##### Included headers
     *
     * Already included headers include:
     * - Basic headers such as:
     *   - `content-type`
     *   - `user-agent`
     * - Authorization headers, such as `Authorization` or `Token`, from `token` options
     *   - e.g. {@link DataAPIClient}, {@link DbOptions.token}, or {@link AdminOptions.adminToken}
     * - Any headers from `embeddingApiKey` options
     *   - e.g. {@link CollectionOptions.embeddingApiKey} or {@link TableOptions.embeddingApiKey}
     * - Any headers from any `additionalHeaders` options
     *   - e.g. {@link DbOptions.additionalHeaders} or {@link AdminOptions.additionalHeaders}
     */
    headers: Record<string, string>;
    /**
     * ##### Overview
     *
     * Whether to force `HTTP/1[.1]` for the request.
     *
     * ##### Why this is important
     *
     * The DevOps API does not support `HTTP/2`, so such requests must only use `HTTP/1` or `HTTP/1.1`.
     */
    forceHttp1: boolean;
    /**
     * ##### Overview
     *
     * Creates a standardized timeout error for the request.
     *
     * - If the request times out, you should catch the timeout error first and throw the result of this method.
     * - This ensures a consistent error format across different fetch implementations.
     *
     * ##### Example
     *
     * As an example, this is how the {@link FetchNative} implementation handles timeouts:
     *
     * @example
     * ```ts
     * public async fetch(info: FetcherRequestInfo): Promise<FetcherResponseInfo> {
     *   try {
     *     const resp = await fetch(info.url, {
     *       signal: AbortSignal.timeout(info.timeout),
     *       ...,
     *     });
     *   } catch (e) {
     *     if (e instanceof Error && e.name === 'TimeoutError') {
     *       throw info.mkTimeoutError();
     *     }
     *     throw e;
     *   }
     * }
     * ```
     *
     * Of course, some http clients may offer a more straightforward way to handle timeouts, such as `axios`'s `timeout` option, and may have different ways to express timeouts occurring.
     *
     * Whatever the case, they should be appropriately set & handled to ensure the timeout is respected.
     */
    mkTimeoutError: () => Error;
    /**
     * ##### Overview
     *
     * The timeout duration for the request, in **milliseconds**.
     *
     * ##### Important
     *
     * - You **must** respect this timeout using `AbortSignal` or another valid timeout mechanism.
     * - If the request exceeds this timeout, throw the error generated by `mkTimeoutError()`.
     *
     * See {@link FetcherRequestInfo.mkTimeoutError} for more information on how to handle timeouts.
     */
    timeout: number;
}

/**
 * ##### Overview
 *
 * Represents the response information returned from a request made by a {@link Fetcher}.
 *
 * ##### Key points of note
 *
 * - The request should NOT throw an error on non-2xx status codes.
 * - The body is returned as a string.
 * - The headers are normalized into a plain JavaScript object.
 * - Includes metadata such as HTTP status code, status text, and URL.
 * - The HTTP version used is explicitly specified.
 * - Additional debugging information may be included via `extraLogInfo`.
 *
 * @see Fetcher
 * @see FetcherRequestInfo
 *
 * @public
 */
export declare interface FetcherResponseInfo {
    /**
     * ##### Overview
     *
     * The body of the request, as a string, if present.
     *
     * May be left as _any falsy value_ if no body was present (e.g. `null`, `undefined`, `''`, etc.).
     *
     * ##### Important
     *
     * Do not attempt to parse the body or convert it to a different format. Simply return it as a string.
     *
     * For example, use `await resp.text()`, not `await resp.json()`.
     * - `resp.text()` generally returns an empty string if the body is empty, so it's perfectly safe to use.
     * - However, double check that this is true of your fetch implementation before using it.
     */
    body?: string;
    /**
     * ##### Overview
     *
     * The response headers, formatted as a plain old JavaScript object.
     *
     * ##### Important
     *
     * Ensure that the headers are correctly normalized into a plain object. They should not be returned as a `Headers` object or similar.
     *
     * You may need to do something like the following:
     *
     * @example
     * ```ts
     * const headers = Object.fromEntries(resp.headers.entries());
     *
     * // or
     *
     * const headers = {} as Record<string, string>;
     *
     * resp.headers.forEach((value, key) => {
     *   headers[key] = value;
     * });
     * ```
     */
    headers: Record<string, string>;
    /**
     * ##### Overview
     *
     * The exact HTTP status code of the response.
     * - e.g. `200`, `404`, `500`
     *
     * ##### Important
     *
     * Do not throw an error on non-2xx status codes. The response should be returned as-is.
     *
     * Catch any HTTP error thrown if necessary, and return it as a response.
     *
     * Otherwise, see if your fetch implementation has a way to disable error-ing on non-2xx status codes.
     *
     * For example, with `axios`, you can set `validateStatus: () => true` to disable this behavior.
     */
    status: number;
    /**
     * ##### Overview
     *
     * The **HTTP version** used for the request.
     *
     * **Possible values:**
     * - `1` → HTTP/1.1
     * - `2` → HTTP/2
     *
     * Ensure that this matches the `forceHttp1` flag in `FetcherRequestInfo` if applicable.
     *
     * This is just used for debugging purposes.
     */
    httpVersion: 1 | 2;
    /**
     * ##### Overview
     *
     * The URL to which the request was made.
     *
     * This may be different from the original URL if the request was redirected.
     *
     * This is just used for debugging purposes.
     */
    url: string;
    /**
     * ##### Overview
     *
     * The **status text** of the response.
     *
     * - Example values: `"OK"`, `"Not Found"`, `"Internal Server Error"`
     * - Typically corresponds to the `status` code.
     *
     * This is just used for debugging purposes.
     */
    statusText: string;
    /**
     * ##### Overview
     *
     * An optional object that may contain any extra debugging information you want to include.
     * - This will be printed if using the `stdout/stderr` {@link LoggingOutput}.
     * - This will be available in {@link BaseClientEvent.extraLogInfo} if using the `event` output.
     *
     * Note that the final `extraLogInfo` object may contain other fields as well, depending on what method was used.
     * - For example, `collection.insertMany` may set a `records` and `ordered` field in `extraLogInfo`.
     */
    extraLogInfo?: Record<string, unknown>;
}

/**
 * Fetcher implementation which uses `fetch-h2` to perform HTTP/1.1 or HTTP/2 calls. Generally more performant than
 * the native fetch API, but less portable.
 *
 * @public
 */
export declare class FetchH2 implements Fetcher {
    /* Excluded from this release type: _http1 */
    /* Excluded from this release type: _preferred */
    /* Excluded from this release type: _timeoutErrorCls */
    constructor(options: FetchH2HttpClientOptions);
    /**
     * Performances the necessary HTTP request using the desired HTTP version.
     */
    fetch(init: FetcherRequestInfo): Promise<FetcherResponseInfo>;
    /**
     * Explicitly releases any underlying network resources held by the `fetch-h2` context.
     */
    close(): Promise<void>;
}

/**
 * ##### Overview
 *
 * The options available for the {@link DataAPIClient} related to making HTTP/1.1 requests with `fetch-h2`.
 *
 * To set related options for `fetch`, you may use in a custom Undici `Dispatcher` (or your environment's equivalent) by extending `FetchNative` and setting `init.dispatcher`. See {@link FetchHttpClientOptions} for more information.
 *
 * @see FetchH2HttpClientOptions
 *
 * @public
 */
export declare interface FetchH2Http1Options {
    /**
     * Whether to keep the connection alive for future requests. This is generally recommended for better performance.
     *
     * Defaults to true.
     *
     * @defaultValue true
     */
    keepAlive?: boolean;
    /**
     * The delay (in milliseconds) before keep-alive probing.
     *
     * Defaults to 1000ms.
     *
     * @defaultValue 1000
     */
    keepAliveMS?: number;
    /**
     * Maximum number of sockets to allow per origin.
     *
     * Defaults to 256.
     *
     * @defaultValue 256
     */
    maxSockets?: number;
    /**
     * Maximum number of lingering sockets, waiting to be re-used for new requests.
     *
     * Defaults to Infinity.
     *
     * @defaultValue Infinity
     */
    maxFreeSockets?: number;
}

/**
 * ##### Overview
 *
 * The options available for the {@link DataAPIClient} related to making HTTP requests using the `fetch-h2` http client.
 *
 * This, however, requires the `fetch-h2` module to be installed & provided by the user, for compatibility reasons, as it is not available in all environments.
 *
 * ##### Setup
 *
 * Luckily, it is only a couple of easy steps to get it working:
 *
 * First, install the `fetch-h2` module:
 *
 * ```bash
 * npm i fetch-h2 # or your favorite package manager's equiv.
 * ```
 *
 * Then, you can provide it to the client like so:
 *
 * ```typescript
 * import * as fetchH2 from 'fetch-h2';
 * // or `const fetchH2 = require('fetch-h2');`
 *
 * const client = new DataAPIClient({
 *   httpOptions: {
 *     client: 'fetch-h2',
 *     fetchH2: fetchH2,
 *   },
 * });
 * ```
 *
 * See the astra-db-ts v2.0+ README for more information on how to use `fetch-h2`, and the compatibility reasons for not including it by default.
 *
 * ##### Examples
 *
 * *For a complete example & more information, see the `examples/using-http2` directory in the [astra-db-ts repository](https://github.com/datastax/astra-db-ts)*
 *
 * @see HttpOptions
 *
 * @public
 */
export declare interface FetchH2HttpClientOptions {
    /**
     * Tells the Data API client to use the `fetch-h2` module for making HTTP requests.
     *
     * See {@link HttpOptions} for the other options available.
     */
    client: 'fetch-h2';
    /**
     * The fetch-h2 module to use for making HTTP requests.
     *
     * Must be provided, or an error will be thrown.
     */
    fetchH2: FetchH2Like;
    /**
     * Whether to prefer HTTP/2 for requests to the Data API; if set to `false`, HTTP/1.1 will be used instead.
     *
     * Note that this is only available for using the Data API; the DevOps API does not support HTTP/2.
     *
     * Both versions are generally interchangeable, but HTTP/2 is recommended for better performance.
     *
     * Defaults to `true` if never provided.
     *
     * @defaultValue true
     */
    preferHttp2?: boolean;
    /**
     * Options specific to HTTP/1.1 requests.
     */
    http1?: FetchH2Http1Options;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - The `maxTimeMS` option is no longer available here; the timeouts system has been overhauled, and defaults should now be set using the `timeoutDefaults` option.
     */
    maxTimeMS?: 'ERROR: The `maxTimeMS` option is no longer available here; the timeouts system has been overhauled, and defaults should now be set using the `timeoutDefaults` option';
}

/**
 * @public
 */
export declare interface FetchH2Like {
    TimeoutError: SomeConstructor;
    context: (...args: any[]) => any;
}

/**
 * ##### Overview
 *
 * The default http client used by the Data API client, which is the native `fetch` API.
 *
 * Passing in `httpOptions: { client: 'fetch' }` is equivalent to not setting the `httpOptions` at all.
 *
 * ##### Polyfilling `fetch`
 *
 * See https://github.com/BuilderIO/this-package-uses-fetch for info about polyfilling fetch for your environment.
 *
 * ##### Customizing `fetch`
 *
 * You may extend the `FetchNative` class to customize the `fetch`'s `RequestInit`, for example to use a custom Undici `Dispatcher` to further customize the HTTP options.
 *
 * See the below-mentioned `examples/customize-http` directory for examples & more information about extending `FetchNative`.
 *
 * ##### Examples
 *
 * *For advanced examples & more information, see the `examples/customize-http` directory in the [astra-db-ts repository](https://github.com/datastax/astra-db-ts)*
 *
 * @see HttpOptions
 *
 * @public
 */
export declare interface FetchHttpClientOptions {
    /**
     * Tells the Data API client to use the native `fetch` API for making HTTP requests.
     *
     * See {@link HttpOptions} for the other options available.
     */
    client: 'fetch';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - The `maxTimeMS` option is no longer available here; the timeouts system has been overhauled, and defaults should now be set using the `timeoutDefaults` option.
     */
    maxTimeMS?: 'ERROR: The `maxTimeMS` option is no longer available here; the timeouts system has been overhauled, and defaults should now be set using the `timeoutDefaults` option';
}

/**
 * Fetcher implementation which uses the native fetch API to perform HTTP calls. Much more portable
 * than {@link FetchH2}, though may be less performant.
 *
 * @public
 */
export declare class FetchNative implements Fetcher {
    /**
     Performances the necessary HTTP request.
     */
    fetch(init: FetcherRequestInfo & RequestInit): Promise<FetcherResponseInfo>;
    /**
     * No-op since the native fetch API has no resources to clean up
     */
    close(): Promise<void>;
}

/**
 * Represents a generic filter type.
 *
 * See {@link CollectionFilter} & {@link TableFilter} for the more specific filter types.
 *
 * @public
 */
export declare type Filter = Record<string, any>;

/**
 * ##### Overview (preview)
 *
 * A lazy iterator over the results of some generic `findAndRerank` operation on the Data API.
 *
 * > **⚠️Warning**: Shouldn't be directly instantiated, but rather spawned via {@link Collection.findAndRerank}.
 *
 * ---
 *
 * ##### Typing
 *
 * > **🚨Important:** For most intents and purposes, you may treat the cursor as if it is typed simply as `Cursor<T>`.
 * >
 * > If you're using a projection, it is heavily recommended to provide an explicit type representing the type of the document after projection.
 *
 * In full, the cursor is typed as `FindAndRerankCursor<T, TRaw>`, where
 * - `T` is the type of the mapped records, and
 * - `TRaw` is the type of the raw records before any mapping.
 *
 * If no mapping function is provided, `T` and `TRaw` will be the same type. Mapping is done using the {@link FindAndRerankCursor.map} method.
 *
 * ---
 *
 * ##### Options
 *
 * Options may be set either through the `findAndRerank({}, options)` method, or through the various fluent **builder
 * methods**, which, *unlike Mongo*, **do not mutate the existing cursor**, but rather return a new, uninitialized cursor
 * with the new option(s) set.
 *
 * @example
 * ```typescript
 * const collection = db.collection('hybrid_coll');
 *
 * const cursor: Cursor<Person> = collection.findAndRerank({}, {
 *   sort: { $hybrid: 'what is a car?' },
 *   includeScores: true,
 * });
 *
 * for await (const res of cursor) {
 *   console.log(res.document);
 *   console.log(res.scores);
 * }
 * ```
 *
 * @see CollectionFindAndRerankCursor
 *
 * @public
 */
export declare abstract class FindAndRerankCursor<T, TRaw extends SomeDoc = SomeDoc> extends AbstractCursor<T, RerankedResult<TRaw>> {
    /* Excluded from this release type: _httpClient */
    /* Excluded from this release type: _serdes */
    /* Excluded from this release type: _parent */
    /* Excluded from this release type: _options */
    /* Excluded from this release type: _filter */
    /* Excluded from this release type: _sortVector */
    /* Excluded from this release type: __constructor */
    /* Excluded from this release type: [$CustomInspect] */
    /**
     * ##### Overview
     *
     * Returns the {@link Table}/{@link Collection} which spawned this cursor.
     *
     * @example
     * ```ts
     * const coll = db.collection(...);
     * const cursor = coll.findAndRerank(...);
     * cursor.dataSource === coll; // true
     * ```
     *
     * ---
     *
     * ##### Typing
     *
     * {@link CollectionFindAndRerankCursor} overrides this method to return the `dataSource` typed exactly as {@link Table} or {@link Collection} respectively, instead of remaining a union of both.
     */
    abstract get dataSource(): Table<SomeRow> | Collection;
    /**
     * ##### Overview
     *
     * Sets the filter for the cursor, overwriting any previous filter.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new filter set.*
     *
     * @example
     * ```ts
     * await table.insertOne({ name: 'John', ... });
     *
     * const cursor = table.findAndRerank({})
     *   .sort({ $hybrid: 'big burly man' })
     *   .filter({ name: 'John' });
     *
     * // The cursor will only return records with the name 'John'
     * const john = await cursor.next();
     * john.name === 'John'; // true
     * ```
     *
     * @param filter - A filter to select which records to return.
     *
     * @returns A new cursor with the new filter set.
     */
    filter(filter: Filter): this;
    /**
     * ##### Overview
     *
     * Sets the sort criteria for prioritizing records.
     *
     * This option **must** be set, and **must** contain a `$hybrid` key.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new sort set.*
     *
     * ---
     *
     * ##### The `$hybrid` key
     *
     * The `$hybrid` key is a special key that specifies the query(s) to use for the underlying vector and lexical searches.
     *
     * If your collection doesn’t have vectorize enabled, you must pass separate query items for `$vector` and `$lexical`:
     * - `{ $hybrid: { $vector: vector([...]), $lexical: 'A house on a hill' } }`
     *
     * If your collection has vectorize enabled, you can query through the $vectorize field instead of the $vector field. You can also use a single search string for both the $vectorize and $lexical queries.
     * - `{ $hybrid: { $vectorize: 'A tree in the woods', $lexical: 'A house on a hill' } }`
     * - `{ $hybrid: 'A tree in the woods' }`
     *
     * ---
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John', age: 30, $vectorize: 'an elder man', $lexical: 'an elder man' },
     *   { name: 'Jane', age: 25, $vectorize: 'a young girl', $lexical: 'a young girl' },
     * ]);
     *
     * const cursor = collection.find({})
     *   .sort({ $hybrid: 'old man' });
     *
     * // The cursor will return records sorted by the hybrid query
     * const oldest = await cursor.next();
     * oldest.nane === 'John'; // true
     * ```
     *
     * @param sort - The hybrid sort criteria to use for prioritizing records.
     *
     * @returns A new cursor with the new sort set.
     */
    sort(sort: HybridSort): this;
    /**
     * ##### Overview
     *
     * Sets the maximum number of records to return.
     *
     * If `limit == 0`, there will be **no limit** on the number of records returned (beyond any that the Data API may itself enforce).
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new limit set.*
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John', age: 30, $vectorize: 'an elder man', $lexical: 'an elder man' },
     *   { name: 'Jane', age: 25, $vectorize: 'a young girl', $lexical: 'a young girl' },
     * ]);
     *
     * const cursor = collection.find({})
     *   .sort({ $hybrid: 'old man' })
     *   .limit(1);
     *
     * // The cursor will return only one record
     * const all = await cursor.toArray();
     * all.length === 1; // true
     * ```
     *
     * @param limit - The limit for this cursor.
     *
     * @returns A new cursor with the new limit set.
     */
    limit(limit: number): this;
    /**
     * ##### Overview
     *
     * Sets the maximum number of records to consider from the underlying vector and lexical searches.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new limit set.*
     *
     * ---
     *
     * ##### Different formats
     *
     * Either a single number, or an object may be provided as a limit definition.
     *
     * If a single number is specified, it applies to both the vector and lexical searches.
     *
     * To set different limits for the vector and lexical searches, an object containing limits for each vector and lexical column must be provided.
     * - For collections, it looks like this: `{ $vector: number, $lexical: number }`
     *
     * ---
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John', age: 30, $vectorize: 'an elder man', $lexical: 'an elder man' },
     *   { name: 'Jane', age: 25, $vectorize: 'a young girl', $lexical: 'a young girl' },
     * ]);
     *
     * const cursor = collection.find({})
     *   .sort({ $hybrid: 'old man' })
     *   .hybridLimits(1);
     *
     * // The cursor will return only one record
     * const all = await cursor.toArray();
     * all.length === 1; // true
     * ```
     *
     * @param hybridLimits - The hybrid limits for this cursor.
     *
     * @returns A new cursor with the new hybrid limits set.
     */
    hybridLimits(hybridLimits: number | Record<string, number>): this;
    /**
     * ##### Overview
     *
     * Specifies the document field to use for the reranking step. Often used with {@link FindAndRerankCursor.rerankQuery}.
     *
     * Optional if you query through the `$vectorize` field instead of the `$vector` field; otherwise required.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new setting.*
     *
     * ---
     *
     * ##### Under the hood
     *
     * Once the underlying vector and lexical searches complete, the reranker compares the `rerankQuery` text with each document’s `rerankOn` field.
     *
     * The reserved `$lexical` field is often used for this parameter, but you can specify any field that stores a string.
     *
     * Any document lacking the field is excluded.
     *
     * ---
     *
     * @example
     * ```ts
     * const cursor = await coll.findAndRerank({})
     *   .sort({ $hybrid: { $vector: vector([...]), $lexical: 'what is a dog?' } })
     *   .rerankOn('$lexical')
     *   .rerankQuery('I like dogs');
     *
     * for await (const res of cursor) {
     *   console.log(res.document);
     * }
     * ```
     *
     * @param rerankOn - The document field to use for the reranking step.
     *
     * @returns A new cursor with the new rerankOn set.
     */
    rerankOn(rerankOn: string): this;
    /**
     * ##### Overview
     *
     * Specifies the query text to use for the reranking step. Often used with {@link FindAndRerankCursor.rerankOn}.
     *
     * Optional if you query through the `$vectorize` field instead of the `$vector` field; otherwise required.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new setting.*
     *
     * ---
     *
     * ##### Under the hood
     *
     * Once the underlying vector and lexical searches complete, the reranker compares the `rerankQuery` text with each document’s `rerankOn` field.
     *
     * ---
     *
     * @example
     * ```ts
     * const cursor = await coll.findAndRerank({})
     *   .sort({ $hybrid: { $vector: vector([...]), $lexical: 'what is a dog?' } })
     *   .rerankOn('$lexical')
     *   .rerankQuery('I like dogs');
     *
     * for await (const res of cursor) {
     *   console.log(res.document);
     * }
     * ```
     *
     * @param rerankQuery - The query text to use for the reranking step.
     *
     * @returns A new cursor with the new rerankQuery set.
     */
    rerankQuery(rerankQuery: string): this;
    /**
     * ##### Overview
     *
     * Determines whether the {@link RerankedResult.scores} is returned for each document.
     *
     * If this is not set, then the `scores` will be an empty object for each document.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new setting.*
     *
     * @example
     * ```ts
     * const cursor = table.findAndRerank({ name: 'John' })
     *   .sort({ $hybrid: 'old man' })
     *   .includeScores();
     *
     * for await (const res of cursor) {
     *   console.log(res.document);
     *   console.log(res.scores);
     * }
     * ```
     *
     * @param includeScores - Whether the scores should be included in the result.
     *
     * @returns A new cursor with the new scores inclusion setting.
     */
    includeScores(includeScores?: boolean): this;
    /**
     * ##### Overview
     *
     * Sets whether the sort vector should be fetched on the very first API call. Note that this is a requirement
     * to use {@link FindAndRerankCursor.getSortVector}—it'll unconditionally return `null` if this is not set to `true`.
     * - This is only applicable when using vector search, and will be ignored if the cursor is not using vector search.
     * - See {@link FindAndRerankCursor.getSortVector} to see exactly what is returned when this is set to `true`.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new setting.*
     *
     * @example
     * ```ts
     * const cursor = table.findAndRerank({)
     *   .sort({ $hybrid: 'old man' })
     *   .includeSortVector();
     *
     * // The cursor will return the sort vector used
     * // Here, it'll be the embedding for the vector created from the term 'old man'
     * const sortVector = await cursor.getSortVector();
     * sortVector; // DataAPIVector([...])
     * ```
     *
     * @param includeSortVector - Whether the sort vector should be fetched on the first API call
     *
     * @returns A new cursor with the new sort vector inclusion setting.
     */
    includeSortVector(includeSortVector?: boolean): this;
    /**
     * Sets the projection for the cursor, overwriting any previous projection.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply
     * returns a new, uninitialized cursor with the given new projection set.*
     *
     * **To properly type this method, you should provide a type argument to specify the shape of the projected
     * records.**
     *
     * **Note that you may NOT provide a projection after a mapping is already provided, to prevent potential
     * de-sync errors.** If you really want to do so, you may use {@link FindAndRerankCursor.clone} to create a new cursor
     * with the same configuration, but without the mapping, and then set the projection.
     *
     * @example
     * ```typescript
     * const cursor = table.findAndRerank({ name: 'John' }).sort(...);
     *
     * // T is `any` because the type is not specified
     * const rawProjected = cursor.project({ id: 0, name: 1 });
     *
     * // T is { name: string }
     * const projected = cursor.project<{ name: string }>({ id: 0, name: 1 });
     *
     * // You can also chain instead of using intermediate variables
     * const fluentlyProjected = table
     *   .findAndRerank({ name: 'John' })
     *   .sort(...)
     *   .project<{ name: string }>({ id: 0, name: 1 });
     *
     * // It's important to keep mapping in mind
     * const mapProjected = table
     *   .findAndRerank({ name: 'John' })
     *   .sort(...)
     *   .map(doc => doc.name);
     *   .project<string>({ id: 0, name: 1 });
     * ```
     *
     * @param projection - Specifies which fields should be included/excluded in the returned records.
     *
     * @returns A new cursor with the new projection set.
     */
    project<RRaw extends SomeDoc = Partial<TRaw>>(projection: Projection): FindAndRerankCursor<RerankedResult<RRaw>, RRaw>;
    /**
     * ##### Overview
     *
     * Map all records using the provided mapping function. Previous mapping functions will be composed with the new
     * mapping function (new ∘ old).
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new projection set.*
     *
     * **You may NOT set a projection after a mapping is already provided, to prevent potential de-sync errors.**
     *
     * @example
     * ```ts
     * const cursor = table.findAndRerank({});
     *   .sort({ $hybrid: 'old man' })
     *   .map(res => res.document);
     *   .map(doc => doc.name.toLowerCase());
     *
     * // T is `string` because the mapping function returns a string
     * const name = await cursor.next();
     * name === 'john'; // true
     * ```
     *
     * @param map - The mapping function to apply to all records.
     *
     * @returns A new cursor with the new mapping set.
     */
    map<R>(map: (doc: T) => R): FindAndRerankCursor<R, TRaw>;
    /**
     * ##### Overview
     *
     * Retrieves the vector used to perform the vector search, if applicable.
     *
     * - If `includeSortVector` is not `true`, this will unconditionally return `null`. No find request will be made.
     *
     * - If `sort: { $hybrid: { $vector } }` was used, `getSortVector()` will simply regurgitate that same `$vector`.
     *
     * - If `sort: { $hybrid: { $vectorize } }` was used, `getSortVector()` will return the `$vector` that was created from the text.
     *
     * - If vector search is not used, `getSortVector()` will simply return `null`. A find request will still be made.
     *
     * If `includeSortVector` is `true`, and this function is called before any other cursor operation (such as
     * `.next()` or `.toArray()`), it'll make an API request to fetch the sort vector, filling the cursor's buffer
     * in the process.
     *
     * If the cursor has already been executed before this function has been called, no additional API request
     * will be made to fetch the sort vector, as it has already been cached.
     *
     * But to reiterate, if `includeSortVector` is `false`, and this function is called, no API request is made, and
     * the cursor's buffer is not populated; it simply returns `null`.
     *
     * @returns The sort vector, or `null` if none was used (or if `includeSortVector !== true`).
     */
    getSortVector(): Promise<DataAPIVector | null>;
    /**
     * ##### Overview
     *
     * Creates, a new, uninitialized copy of this cursor with the exact same options and mapping.
     *
     * See {@link FindAndRerankCursor.rewind} for resetting the same instance of the cursor.
     */
    clone(): this;
    /* Excluded from this release type: _nextPage */
    /* Excluded from this release type: _tm */
}

/**
 * ##### Overview
 *
 * A lazy iterator over the results of some generic `find` operation on the Data API.
 *
 * > **⚠️Warning**: Shouldn't be directly instantiated, but rather spawned via {@link Table.find}/{@link Collection.find}.
 *
 * ---
 *
 * ##### Typing
 *
 * > **🚨Important:** For most intents and purposes, you may treat the cursor as if it is typed simply as `Cursor<T>`.
 * >
 * > If you're using a projection, it is heavily recommended to provide an explicit type representing the type of the document after projection.
 *
 * In full, the cursor is typed as `FindCursor<T, TRaw>`, where
 * - `T` is the type of the mapped records, and
 * - `TRaw` is the type of the raw records before any mapping.
 *
 * If no mapping function is provided, `T` and `TRaw` will be the same type. Mapping is done using the {@link FindCursor.map} method.
 *
 * ---
 *
 * ##### Options
 *
 * Options may be set either through the `find({}, options)` method, or through the various fluent **builder
 * methods**, which, *unlike Mongo*, **do not mutate the existing cursor**, but rather return a new, uninitialized cursor
 * with the new option(s) set.
 *
 * @example
 * ```typescript
 * interface Person {
 *   firstName: string,
 *   lastName: string,
 *   age: number,
 * }
 *
 * const collection = db.collection<Person>('people');
 * const cursor1: Cursor<Person> = collection.find({ firstName: 'John' });
 *
 * // Lazily iterate all documents matching the filter
 * for await (const doc of cursor1) {
 *   console.log(doc);
 * }
 *
 * // Rewind the cursor to be able to iterate again
 * cursor1.rewind();
 *
 * // Get all documents matching the filter as an array
 * const docs = await cursor1.toArray();
 *
 * // Immutably set options & map as needed (changing options returns a new, uninitialized cursor)
 * const cursor2: Cursor<string> = cursor
 *   .project<Omit<Person, 'age'>>({ age: 0 })
 *   .map(doc => doc.firstName + ' ' + doc.lastName);
 *
 * // Get next document from cursor
 * const doc = await cursor2.next();
 * ```
 *
 * @see CollectionFindCursor
 * @see TableFindCursor
 *
 * @public
 */
export declare abstract class FindCursor<T, TRaw extends SomeDoc = SomeDoc> extends AbstractCursor<T, TRaw> {
    /* Excluded from this release type: _httpClient */
    /* Excluded from this release type: _serdes */
    /* Excluded from this release type: _parent */
    /* Excluded from this release type: _options */
    /* Excluded from this release type: _filter */
    /* Excluded from this release type: _sortVector */
    /* Excluded from this release type: __constructor */
    /* Excluded from this release type: [$CustomInspect] */
    /**
     * ##### Overview
     *
     * Returns the {@link Table}/{@link Collection} which spawned this cursor.
     *
     * @example
     * ```ts
     * const coll = db.collection(...);
     * const cursor = coll.find({});
     * cursor.dataSource === coll; // true
     * ```
     *
     * ---
     *
     * ##### Typing
     *
     * {@link TableFindCursor} & {@link CollectionFindCursor} override this method to return the `dataSource` typed exactly as {@link Table} or {@link Collection} respectively, instead of remaining a union of both.
     */
    abstract get dataSource(): Table<SomeRow> | Collection;
    /**
     * ##### Overview
     *
     * Sets the filter for the cursor, overwriting any previous filter.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new filter set.*
     *
     * @example
     * ```ts
     * await table.insertOne({ name: 'John', ... });
     *
     * const cursor = table.find({})
     *   .filter({ name: 'John' });
     *
     * // The cursor will only return records with the name 'John'
     * const john = await cursor.next();
     * john.name === 'John'; // true
     * ```
     *
     * @param filter - A filter to select which records to return.
     *
     * @returns A new cursor with the new filter set.
     */
    filter(filter: Filter): this;
    /**
     * ##### Overview
     *
     * Sets the sort criteria for prioritizing records.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new sort set.*
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John', age: 30 },
     *   { name: 'Jane', age: 25 },
     * ]);
     *
     * const cursor = collection.find({})
     *  .sort({ age: -1 });
     *
     * // The cursor will return records sorted by age in descending order
     * const oldest = await cursor.next();
     * oldest.age === 30; // true
     * ```
     *
     * @param sort - The sort order to prioritize which records are returned.
     *
     * @returns A new cursor with the new sort set.
     */
    sort(sort: Sort): this;
    /**
     * ##### Overview
     *
     * Sets the maximum number of records to return.
     *
     * If `limit == 0`, there will be **no limit** on the number of records returned (beyond any that the Data API may itself enforce).
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new limit set.*
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John', age: 30 },
     *   { name: 'Jane', age: 25 },
     * ]);
     *
     * const cursor = collection.find({})
     *   .limit(1);
     *
     * // The cursor will return only one record
     * const all = await cursor.toArray();
     * all.length === 1; // true
     * ```
     *
     * @param limit - The limit for this cursor.
     *
     * @returns A new cursor with the new limit set.
     */
    limit(limit: number): this;
    /**
     * ##### Overview
     *
     * Sets the number of records to skip before returning. **Must be used with {@link FindCursor.sort}.**
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new skip set.*
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John', age: 30 },
     *   { name: 'Jane', age: 25 },
     * ]);
     *
     * const cursor = collection.find({})
     *   .sort({ age: -1 })
     *   .skip(1);
     *
     * // The cursor will skip the first record and return the second
     * const secondOldest = await cursor.next();
     * secondOldest.age === 25; // true
     * ```
     *
     * @param skip - The skip for the cursor query.
     *
     * @returns A new cursor with the new skip set.
     */
    skip(skip: number): this;
    /**
     * ##### Overview
     *
     * Sets whether the sort vector should be fetched on the very first API call. Note that this is a requirement
     * to use {@link FindCursor.getSortVector}—it'll unconditionally return `null` if this is not set to `true`.
     * - This is only applicable when using vector search, and will be ignored if the cursor is not using vector search.
     * - See {@link FindCursor.getSortVector} to see exactly what is returned when this is set to `true`.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new setting.*
     *
     * @example
     * ```ts
     * const cursor = table.find({ name: 'John' })
     *   .sort({ $vectorize: 'name' })
     *   .includeSortVector();
     *
     * // The cursor will return the sort vector used
     * // Here, it'll be the embedding for the vector created from the name 'John'
     * const sortVector = await cursor.getSortVector();
     * sortVector; // DataAPIVector([...])
     * ```
     *
     * @param includeSortVector - Whether the sort vector should be fetched on the first API call
     *
     * @returns A new cursor with the new sort vector inclusion setting.
     */
    includeSortVector(includeSortVector?: boolean): this;
    /**
     * ##### Overview
     *
     * Sets the projection for the cursor, overwriting any previous projection.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new projection set.*
     *
     * **To properly type this method, you should provide a type argument to specify the shape of the projected
     * records.**
     *
     * **Note that you may *NOT* provide a projection after a mapping is already provided, to prevent potential
     * de-sync errors.**
     *
     * @example
     * ```typescript
     * const cursor = table.find({ name: 'John' });
     *
     * // T is `Partial<Schema>` because the type is not specified
     * const rawProjected = cursor.project({ id: 0, name: 1 });
     *
     * // T is { name: string }
     * const projected = cursor.project<{ name: string }>({ id: 0, name: 1 });
     *
     * // You can also chain instead of using intermediate variables
     * const fluentlyProjected = table
     *   .find({ name: 'John' })
     *   .project<{ name: string }>({ id: 0, name: 1 });
     * ```
     *
     * @param projection - Specifies which fields should be included/excluded in the returned records.
     *
     * @returns A new cursor with the new projection set.
     */
    project<RRaw extends SomeDoc = Partial<TRaw>>(projection: Projection): FindCursor<RRaw, RRaw>;
    /**
     * ##### Overview
     *
     * Sets whether similarity scores should be included in the cursor's results.
     *
     * - This is only applicable when using vector search, and will be ignored if the cursor is not using vector search.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new similarity setting.*
     *
     * @example
     * ```ts
     * const cursor = table.find({ name: 'John' })
     *   .sort({ $vector: new DataAPIVector([...]) })
     *   .includeSimilarity();
     *
     * // The cursor will return the similarity scores for each record
     * const closest = await cursor.next();
     * closest.$similarity; // number
     * ```
     *
     * @param includeSimilarity - Whether similarity scores should be included.
     *
     * @returns A new cursor with the new similarity setting.
     */
    includeSimilarity(includeSimilarity?: boolean): FindCursor<WithSim<TRaw>, WithSim<TRaw>>;
    /**
     * ##### Overview
     *
     * Map all records using the provided mapping function. Previous mapping functions will be composed with the new
     * mapping function (new ∘ old).
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new projection set.*
     *
     * **You may NOT set a projection after a mapping is already provided, to prevent potential de-sync errors.**
     *
     * @example
     * ```ts
     * const cursor = table.find({ name: 'John' });
     *   .map(doc => doc.name);
     *   .map(name => name.toLowerCase());
     *
     * // T is `string` because the mapping function returns a string
     * const name = await cursor.next();
     * name === 'john'; // true
     * ```
     *
     * @param map - The mapping function to apply to all records.
     *
     * @returns A new cursor with the new mapping set.
     */
    map<R>(map: (doc: T) => R): FindCursor<R, TRaw>;
    /**
     * ##### Overview
     *
     * Retrieves the vector used to perform the vector search, if applicable.
     *
     * - If `includeSortVector` is not `true`, this will unconditionally return `null`. No find request will be made.
     *
     * - If `sort: { $vector }` was used, `getSortVector()` will simply regurgitate that same `$vector`.
     *
     * - If `sort: { $vectorize }` was used, `getSortVector()` will return the `$vector` that was created from the text.
     *
     * - If vector search is not used, `getSortVector()` will simply return `null`. A find request will still be made.
     *
     * If `includeSortVector` is `true`, and this function is called before any other cursor operation (such as
     * `.next()` or `.toArray()`), it'll make an API request to fetch the sort vector, filling the cursor's buffer
     * in the process.
     *
     * If the cursor has already been executed before this function has been called, no additional API request
     * will be made to fetch the sort vector, as it has already been cached.
     *
     * But to reiterate, if `includeSortVector` is `false`, and this function is called, no API request is made, and
     * the cursor's buffer is not populated; it simply returns `null`.
     *
     * @returns The sort vector, or `null` if none was used (or if `includeSortVector !== true`).
     */
    getSortVector(): Promise<DataAPIVector | null>;
    /**
     * ##### Overview
     *
     * Creates, a new, uninitialized copy of this cursor with the exact same options and mapping.
     *
     * See {@link FindCursor.rewind} for resetting the same instance of the cursor.
     */
    clone(): this;
    /* Excluded from this release type: _nextPage */
    /* Excluded from this release type: _tm */
}

/**
 * The overarching result containing the `embeddingProviders` map.
 *
 * @field embeddingProviders - Map of embedding provider names to info about said provider.
 *
 * @see DbAdmin.findEmbeddingProviders
 *
 * @public
 */
export declare interface FindEmbeddingProvidersResult {
    /**
     * A map of embedding provider names (e.g. `openai`), to information about said provider (e.g. models/auth).
     *
     * @example
     * ```typescript
     * {
     *   openai: {
     *     displayName: 'OpenAI',
     *     ...,
     *   }
     * }
     * ```
     */
    embeddingProviders: Record<string, EmbeddingProviderInfo>;
}

/**
 * The overarching result containing the `rerankingProviders` map.
 *
 * **Temporarily dynamically typed. In a future release, the type will be strengthened.**
 *
 * @field rerankingProviders - Map of reranking provider names to info about said provider.
 *
 * @see DbAdmin.findRerankingProviders
 *
 * @public
 */
export declare interface FindRerankingProvidersResult {
    /**
     * A map of reranking provider names (e.g. `nvidia`), to information about said provider (e.g. models/auth).
     *
     * @example
     * ```typescript
     * {
     *   nvidia: {
     *     displayName: 'Nvidia',
     *     ...,
     *   }
     * }
     * ```
     *
     * **Temporarily typed as `any`. In a future release, the type will be strengthened.**
     */
    rerankingProviders: Record<string, any>;
}

/**
 * Represents a flattened version of the given type. Only goes one level deep.
 *
 * @public
 */
export declare type Flatten<Type> = Type extends (infer Item)[] ? Item : Type;

/**
 * Represents a document as it's returned by the database by default.
 *
 * @public
 */
export declare type FoundDoc<Doc> = {
    _id: IdOf<Doc>;
} & NoId<Omit<Doc, '$vector' | '$vectorize'>>;

/**
 * Represents a row as it's returned by the database by default.
 *
 * Ensures that all `DataAPIVector` fields are just returned as `DataAPIVector`, and not `DataAPIVector | string` in case vectorize is enabled on any of the vector columns.
 *
 * @public
 */
export declare type FoundRow<Doc> = {
    [K in keyof Doc]-?: DataAPIVector extends Doc[K] ? Exclude<Doc[K], string> : Doc[K];
};

/**
 * ##### Overview
 *
 * If your table has multiple columns in its primary key, you may use the full primary key definition syntax to express that:
 *
 * ```ts
 * primaryKey: {
 *   partitionBy: ['pt_key1', 'pt_key2'],
 *   partitionSort: { cl_key1: 1, cl_key2: -1 },
 * }
 * ```
 *
 * Note that, if you don't have any clustering keys (partition sorts), you can omit the `partitionSort` field entirely:
 *
 * ```ts
 * primaryKey: {
 *   partitionBy: ['pt_key1', 'pt_key2'],
 * }
 * ```
 *
 * A sort of `1` on the clustering column means ascending, and a sort of -1 means descending.
 *
 * ##### The shorthand syntax
 *
 * If your table definition only has a single partition key, and no clustering keys (partition sorts), you can use the shorthand syntax instead:
 *
 * ```ts
 * primaryKey: 'pt_key',
 * ```
 *
 * @public
 */
export declare interface FullCreateTablePrimaryKeyDefinition<PKCols extends string> {
    readonly partitionBy: readonly PKCols[];
    readonly partitionSort?: Partial<Record<PKCols, 1 | -1>>;
}

export declare type GenericCountOptions = WithTimeout<'generalMethodTimeoutMs'>;

export declare type GenericDeleteManyOptions = WithTimeout<'generalMethodTimeoutMs'>;

/**
 * Represents the result of some generic `deleteMany` command.
 *
 * @field deletedCount - The number of deleted documents. Can be any non-negative integer.
 *
 * @public
 */
export declare interface GenericDeleteManyResult {
    /**
     * The number of deleted documents.
     */
    deletedCount: number;
}

/**
 * Represents the options for some generic `deleteOne` command.
 *
 * @field sort - The sort order to pick which document to delete if the filter selects multiple documents.
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare interface GenericDeleteOneOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    sort?: Sort;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vector: [...] }` instead.
     */
    vector?: 'ERROR: Use `sort: { $vector: [...] }` instead';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vectorize: '...' }` instead.
     */
    vectorize?: 'ERROR: Use `sort: { $vectorize: "..." }` instead';
}

/**
 * Represents the result of some generic `deleteOne` command.
 *
 * @field deletedCount - The number of deleted documents. Can be either 0 or 1.
 *
 * @public
 */
export declare interface GenericDeleteOneResult {
    deletedCount: 0 | 1;
}

export declare type GenericDistinctOptions = WithTimeout<'generalMethodTimeoutMs'>;

export declare type GenericEstimatedCountOptions = WithTimeout<'generalMethodTimeoutMs'>;

/**
 * Options for some generic `findAndRerank` command.
 *
 * @public
 */
export declare interface GenericFindAndRerankOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * The order in which to apply the update if the filter selects multiple records.
     *
     * Defaults to `null`, where the order is not guaranteed.
     */
    sort?: HybridSort;
    /**
     * The projection to apply to the returned records, to specify only a select set of fields to return.
     *
     * If using a projection, it is heavily recommended to provide a custom type for the returned records as a generic type-param to the `find` method.
     */
    projection?: Projection;
    /**
     * The maximum number of records to return in the lifetime of the cursor.
     *
     * Defaults to `null`, which means no limit.
     */
    limit?: number;
    hybridLimits?: number | Record<string, number>;
    rerankOn?: string;
    rerankQuery?: string;
    includeScores?: boolean;
    includeSortVector?: boolean;
}

/**
 * Represents the options for the `findOneAndDelete` command.
 *
 * @field sort - The sort order to pick which document to delete if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.findOneAndDelete
 *
 * @public
 */
export declare interface GenericFindOneAndDeleteOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * The order in which to apply the update if the filter selects multiple documents.
     *
     * If multiple documents match the filter, only one will be updated.
     *
     * Defaults to `null`, where the order is not guaranteed.
     * @defaultValue null
     */
    sort?: Sort;
    /**
     * Specifies which fields should be included/excluded in the returned documents.
     *
     * If not specified, all fields are included.
     *
     * When specifying a projection, it's the user's responsibility to handle the return type carefully, as the
     * projection will, of course, affect the shape of the returned documents. It may be a good idea to cast
     * the returned documents into a type that reflects the projection to avoid runtime errors.
     *
     * @example
     * ```typescript
     * interface User {
     *   name: string;
     *   age: number;
     * }
     *
     * const collection = db.collection<User>('users');
     *
     * const doc = await collection.findOne({}, {
     *   projection: {
     *     _id: 0,
     *     name: 1,
     *   },
     *   vector: [.12, .52, .32],
     *   includeSimilarity: true,
     * }) as { name: string, $similarity: number };
     *
     * // Ok
     * console.log(doc.name);
     * console.log(doc.$similarity);
     *
     * // Causes type error
     * console.log(doc._id);
     * console.log(doc.age);
     * ```
     */
    projection?: Projection;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vector: [...] }` instead.
     */
    vector?: 'ERROR: Use `sort: { $vector: [...] }` instead';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vectorize: '...' }` instead.
     */
    vectorize?: 'ERROR: Use `sort: { $vectorize: "..." }` instead';
}

/**
 * Represents the options for the `findOneAndReplace` command.
 *
 * @field returnDocument - Specifies whether to return the original or updated document.
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field sort - The sort order to pick which document to replace if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.findOneAndReplace
 *
 * @public
 */
export declare interface GenericFindOneAndReplaceOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * Specifies whether to return the document before or after the update.
     *
     * Set to `before` to return the document before the update to see the original state of the document.
     *
     * Set to `after` to return the document after the update to see the updated state of the document immediately.
     *
     * Defaults to `'before'`.
     *
     * @defaultValue 'before'
     */
    returnDocument?: 'before' | 'after';
    /**
     * If true, perform an insert if no documents match the filter.
     *
     * If false, do not insert if no documents match the filter.
     *
     * Defaults to false.
     *
     * @defaultValue false
     */
    upsert?: boolean;
    /**
     * The order in which to apply the update if the filter selects multiple documents.
     *
     * If multiple documents match the filter, only one will be updated.
     *
     * Defaults to `null`, where the order is not guaranteed.
     *
     * @defaultValue null
     */
    sort?: Sort;
    /**
     * Specifies which fields should be included/excluded in the returned documents.
     *
     * If not specified, all fields are included.
     *
     * When specifying a projection, it's the user's responsibility to handle the return type carefully, as the
     * projection will, of course, affect the shape of the returned documents. It may be a good idea to cast
     * the returned documents into a type that reflects the projection to avoid runtime errors.
     *
     * @example
     * ```typescript
     * interface User {
     *   name: string;
     *   age: number;
     * }
     *
     * const collection = db.collection<User>('users');
     *
     * const doc = await collection.findOne({}, {
     *   projection: {
     *     _id: 0,
     *     name: 1,
     *   },
     *   vector: [.12, .52, .32],
     *   includeSimilarity: true,
     * }) as { name: string, $similarity: number };
     *
     * // Ok
     * console.log(doc.name);
     * console.log(doc.$similarity);
     *
     * // Causes type error
     * console.log(doc._id);
     * console.log(doc.age);
     * ```
     */
    projection?: Projection;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vector: [...] }` instead.
     */
    vector?: 'ERROR: Use `sort: { $vector: [...] }` instead';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vectorize: '...' }` instead.
     */
    vectorize?: 'ERROR: Use `sort: { $vectorize: "..." }` instead';
}

/**
 * Represents the options for the `findOneAndUpdate` command.
 *
 * @field returnDocument - Specifies whether to return the original or updated document.
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field sort - The sort order to pick which document to replace if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field includeResultMetadata - When true, returns alongside the document, an `ok` field with a value of 1 if the command executed successfully.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.findOneAndUpdate
 *
 * @public
 */
export declare interface GenericFindOneAndUpdateOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * Specifies whether to return the document before or after the update.
     *
     * Set to `before` to return the document before the update to see the original state of the document.
     *
     * Set to `after` to return the document after the update to see the updated state of the document immediately.
     *
     * Defaults to `'before'`.
     *
     * @defaultValue 'before'
     */
    returnDocument?: 'before' | 'after';
    /**
     * If true, perform an insert if no documents match the filter.
     *
     * If false, do not insert if no documents match the filter.
     *
     * Defaults to false.
     * @defaultValue false
     */
    upsert?: boolean;
    /**
     * The order in which to apply the update if the filter selects multiple documents.
     *
     * If multiple documents match the filter, only one will be updated.
     *
     * Defaults to `null`, where the order is not guaranteed.
     * @defaultValue null
     */
    sort?: Sort;
    /**
     * Specifies which fields should be included/excluded in the returned documents.
     *
     * If not specified, all fields are included.
     *
     * When specifying a projection, it's the user's responsibility to handle the return type carefully, as the
     * projection will, of course, affect the shape of the returned documents. It may be a good idea to cast
     * the returned documents into a type that reflects the projection to avoid runtime errors.
     *
     * @example
     * ```typescript
     * interface User {
     *   name: string;
     *   age: number;
     * }
     *
     * const collection = db.collection<User>('users');
     *
     * const doc = await collection.findOne({}, {
     *   projection: {
     *     _id: 0,
     *     name: 1,
     *   },
     *   vector: [.12, .52, .32],
     *   includeSimilarity: true,
     * }) as { name: string, $similarity: number };
     *
     * // Ok
     * console.log(doc.name);
     * console.log(doc.$similarity);
     *
     * // Causes type error
     * console.log(doc._id);
     * console.log(doc.age);
     * ```
     */
    projection?: Projection;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vector: [...] }` instead.
     */
    vector?: 'ERROR: Use `sort: { $vector: [...] }` instead';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vectorize: '...' }` instead.
     */
    vectorize?: 'ERROR: Use `sort: { $vectorize: "..." }` instead';
}

/**
 * Represents the options for some generic `findOne` command.
 *
 * @field sort - The sort order to pick which document to return if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field includeSimilarity - If true, include the similarity score in the result via the `$similarity` field.
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare interface GenericFindOneOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * The order in which to apply the update if the filter selects multiple records.
     *
     * Defaults to `null`, where the order is not guaranteed.
     */
    sort?: Sort;
    /**
     * The projection to apply to the returned records, to specify only a select set of fields to return.
     *
     * If using a projection, it is heavily recommended to provide a custom type for the returned records as a generic typeparam to the `find` method.
     */
    projection?: Projection;
    /**
     * If true, include the similarity score in the result via the `$similarity` field.
     */
    includeSimilarity?: boolean;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vector: [...] }` instead.
     */
    vector?: 'ERROR: Use `sort: { $vector: [...] }` instead';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vectorize: '...' }` instead.
     */
    vectorize?: 'ERROR: Use `sort: { $vectorize: "..." }` instead';
}

/**
 * Options for some generic `find` command.
 *
 * @field sort - The sort order to pick which document to return if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field limit - Max number of documents to return in the lifetime of the cursor.
 * @field skip - Number of documents to skip if using a sort.
 * @field includeSimilarity - If true, include the similarity score in the result via the `$similarity` field.
 *
 * @public
 */
export declare interface GenericFindOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * The order in which to apply the update if the filter selects multiple records.
     *
     * Defaults to `null`, where the order is not guaranteed.
     */
    sort?: Sort;
    /**
     * The projection to apply to the returned records, to specify only a select set of fields to return.
     *
     * If using a projection, it is heavily recommended to provide a custom type for the returned records as a generic typeparam to the `find` method.
     */
    projection?: Projection;
    /**
     * The maximum number of records to return in the lifetime of the cursor.
     *
     * Defaults to `null`, which means no limit.
     */
    limit?: number;
    /**
     * The number of records to skip before starting to return records.
     *
     * Defaults to `null`, which means no skip.
     */
    skip?: number;
    /**
     * If true, include the similarity score in the result via the `$similarity` field.
     */
    includeSimilarity?: boolean;
    /**
     * If true, the sort vector will be available through `await cursor.getSortVector()`
     */
    includeSortVector?: boolean;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vector: [...] }` instead.
     */
    vector?: 'ERROR: Use `sort: { $vector: [...] }` instead';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vectorize: '...' }` instead.
     */
    vectorize?: 'ERROR: Use `sort: { $vectorize: "..." }` instead';
}

/**
 * ##### Overview
 *
 * The options for a generic `insertMany` command performed on the Data API.
 *
 * > **🚨Important:** The options depend on the `ordered` parameter. If `ordered` is `true`, then the `concurrency` option is not allowed.
 *
 * @example
 * ```ts
 * const result = await collection.insertMany([
 *   { name: 'John', age: 30 },
 *   { name: 'Jane', age: 25 },
 * ], {
 *   ordered: true,
 *   timeout: 60000,
 * });
 * ```
 *
 * @example
 * ```ts
 * const result = await table.insertMany([
 *   { id: uuid.v4(), name: 'John' },
 *   { id: uuid.v7(), name: 'Jane' },
 * ], {
 *   concurrency: 16, // ordered implicitly `false` if unset
 * });
 * ```
 *
 * @public
 */
export declare type GenericInsertManyOptions = GenericInsertManyUnorderedOptions | GenericInsertManyOrderedOptions;

/**
 * ##### Overview
 *
 * The options for a generic `insertMany` command performed on the Data API when `ordered` is `true`.
 *
 * > **🚨Important:** The options depend on the `ordered` parameter. If `ordered` is `true`, then the `concurrency` option is not allowed.
 *
 * @example
 * ```ts
 * const result = await collection.insertMany([
 *   { name: 'John', age: 30 },
 *   { name: 'Jane', age: 25 },
 * ], {
 *   ordered: true,
 *   timeout: 60000,
 * });
 * ```
 *
 * @see GenericInsertManyOptions
 *
 * @public
 */
export declare interface GenericInsertManyOrderedOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * If `true`, the records are inserted in the order provided. If an error occurs, the operation stops and the
     * remaining records are not inserted.
     */
    ordered: true;
    /**
     * The number of records to upload per request. Defaults to 50.
     *
     * If you have large records, you may find it beneficial to reduce this number and increase concurrency to
     * improve throughput. Leave it unspecified (recommended) to use the system default.
     *
     * @defaultValue 50
     */
    chunkSize?: number;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Set the `$vector` field in the docs directly.
     */
    vector?: 'ERROR: Set the `$vector` field in the docs directly';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Set the `$vectorize` field in the docs directly.
     */
    vectorize?: 'ERROR: Set the `$vectorize` field in the docs directly';
}

/**
 * ##### Overview
 *
 * The options for a generic `insertMany` command performed on the Data API when `ordered` is `true`.
 *
 * > **🚨Important:** The options depend on the `ordered` parameter. If `ordered` is `true`, then the `concurrency` option is not allowed.
 *
 * @example
 * ```ts
 * const result = await table.insertMany([
 *   { id: uuid.v4(), name: 'John' },
 *   { id: uuid.v7(), name: 'Jane' },
 * ], {
 *   concurrency: 16, // ordered implicitly `false` if unset
 * });
 * ```
 *
 * @see GenericInsertManyOptions
 *
 * @public
 */
export declare interface GenericInsertManyUnorderedOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * If `false`, the records are inserted in an arbitrary order. If an error occurs, the operation does not stop
     * and the remaining records are inserted. This allows the operation to be parallelized for better performance.
     */
    ordered?: false;
    /**
     * The maximum number of concurrent requests to make at once.
     */
    concurrency?: number;
    /**
     * The number of records to upload per request. Defaults to 50.
     *
     * If you have large records, you may find it beneficial to reduce this number and increase concurrency to
     * improve throughput. Leave it unspecified (recommended) to use the system default.
     *
     * @defaultValue 50
     */
    chunkSize?: number;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Set the `$vector` field in the docs directly.
     */
    vector?: 'ERROR: Set the `$vector` field in the docs directly';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Set the `$vectorize` field in the docs directly.
     */
    vectorize?: 'ERROR: Set the `$vectorize` field in the docs directly';
}

/**
 * ##### Overview
 *
 * The options for a generic `insertOne` command performed on the Data API.
 *
 * @example
 * ```ts
 * const result = await collection.insertOne({
 *   name: 'John',
 *   age: 30,
 * }, {
 *   timeout: 10000,
 * });
 * ```
 *
 * @see CollectionInsertOneOptions
 * @see TableInsertOneOptions
 *
 * @public
 */
export declare type GenericInsertOneOptions = WithTimeout<'generalMethodTimeoutMs'>;

/**
 * Represents the options for some generic `replaceOne` command.
 *
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field sort - The sort order to pick which document to replace if the filter selects multiple documents.
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare interface GenericReplaceOneOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    upsert?: boolean;
    sort?: Sort;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vector: [...] }` instead.
     */
    vector?: 'ERROR: Use `sort: { $vector: [...] }` instead';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vectorize: '...' }` instead.
     */
    vectorize?: 'ERROR: Use `sort: { $vectorize: "..." }` instead';
}

/**
 Options for some generic `updateMany` command
 *
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare interface GenericUpdateManyOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    upsert?: boolean;
}

/**
 * ##### Overview
 *
 * The options for a generic `updateOne` command performed on the Data API.
 *
 * @example
 * ```ts
 * const result = await collection.updateOne(
 *   { name: 'John' },
 *   { $set: { dob: new Date('1990-01-01'), updatedAt: { $currentDate: true } } },
 *   { upsert: true, sort: { $vector: [...] } },
 * );
 * ```
 *
 * @see CollectionUpdateOneOptions
 * @see TableUpdateOneOptions
 *
 * @public
 */
export declare interface GenericUpdateOneOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * If true, perform an insert if no documents match the filter.
     *
     * If false, do not insert if no documents match the filter.
     *
     * Defaults to false.
     *
     * @defaultValue false
     */
    upsert?: boolean;
    /**
     * The order in which to apply the update if the filter selects multiple documents.
     *
     * If multiple documents match the filter, only one will be updated.
     *
     * Defaults to `null`, where the order is not guaranteed.
     *
     * @defaultValue null
     */
    sort?: Sort;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vector: [...] }` instead.
     */
    vector?: 'ERROR: Use `sort: { $vector: [...] }` instead';
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - Use `sort: { $vectorize: '...' }` instead.
     */
    vectorize?: 'ERROR: Use `sort: { $vectorize: "..." }` instead';
}

/**
 * ##### Overview
 *
 * Represents the result of a generic `update*` command performed on the Data API.
 *
 * > **🚨Important:** The exact result type depends on the `upsertedCount` field of the result:
 * - If `upsertedCount` is `0`, the result will be of type {@link GuaranteedUpdateResult} & {@link NoUpsertUpdateResult}.
 * - If `upsertedCount` is `1`, the result will be of type {@link GuaranteedUpdateResult} & {@link UpsertedUpdateResult}.
 *
 *
 * @example
 * ```typescript
 * const result = await collection.updateOne(
 *   { _id: 'abc' },
 *   { $set: { name: 'John' } },
 *   { upsert: true },
 * );
 *
 * if (result.upsertedCount) {
 *   console.log(`Document with ID ${result.upsertedId} was upserted`);
 * }
 * ```
 *
 * @see CollectionUpdateOneResult
 * @see CollectionUpdateManyResult
 *
 * @public
 */
export declare type GenericUpdateResult<ID, N extends number> = (GuaranteedUpdateResult<N> & UpsertedUpdateResult<ID>) | (GuaranteedUpdateResult<N> & NoUpsertUpdateResult);

/* Excluded from this release type: genObjectId */

export declare interface GetHeadersCtx {
    readonly for: 'devops-api' | 'data-api';
}

/**
 * ##### Overview
 *
 * Represents the set of fields that are guaranteed to be present in the result of a generic `update*` command performed on the Data API.
 *
 * > **✏️Note:** Depending on whether the update operation is `updateOne` or `updateMany`, the `N` type parameter can be either `1` or `number`, respectively.
 *
 * @see GenericUpdateResult
 *
 * @public
 */
export declare interface GuaranteedUpdateResult<N extends number> {
    /**
     * The number of records that matched the filter.
     */
    matchedCount: N;
    /**
     * The number of records that were actually modified.
     */
    modifiedCount: N;
}

export declare abstract class HeadersProvider<Tag extends HeadersProviderVariants = any> {
    readonly _phant: `Expected a HeaderProvider specifically for ${Tag}s (e.g. \`class ${Capitalize<Tag>}HeadersProvider extends HeadersProvider<'${Tag}'>\`).`;
    /* Excluded from this release type: opts */
    abstract getHeaders(ctx: GetHeadersCtx): Promise<Record<string, string | undefined>> | Record<string, string | undefined>;
}

export declare type HeadersProviderVariants = 'embedding' | 'reranking';

/* Excluded from this release type: HeadersResolver */

/**
 * ##### Overview
 *
 * A lightweight event system that allows hierarchical event propagation (similar to DOM event bubbling).
 *
 * Events triggered on a child (e.g., a `Collection`) will propagate up to its parent (e.g., the parent `Db` and its parent `DataAPIClient`),
 * unless explicitly stopped.
 *
 * _This allows to quickly (and granular-ly) enable listen for events at any level of the hierarchy_, and stop propagation at any level if needed.
 *
 * ##### Event Hierarchy
 *
 * Events follow a structured hierarchy:
 *
 * - `Collection | Table` → `Db` → `Client`
 * - `AstraAdmin | DbAdmin` → `Client`
 *
 * If, for instance, you have two different `Collection` objects which both point to the same collection, _only the one that triggered the event will be notified._
 *
 * @example
 * ```ts
 * const client = new DataAPIClient({ logging: 'all' });
 *
 * client.on('commandFailed', (event) => {
 *   console.error('Some command failed:', event.commandName, event.error);
 * });
 *
 * const db = client.db('*ENDPOINT*', { token: '*TOKEN*' });
 * const collection = db.collection('test_coll');
 *
 * collection.on('commandFailed', (event) => {
 *   event.stopPropagation(); // Prevents bubbling up to the client
 *   console.error('test_coll command failed:', event.commandName, event.error);
 * });
 *
 * collection.insertOne({ '$invalid-key': 'value' });
 * ```
 *
 * ##### On errors in listeners
 *
 * If an error is thrown in a listener, it will be silently ignored and will not stop the propagation of the event.
 *
 * If you need to handle errors in listeners, you must wrap the listener in a try/catch block yourself.
 *
 * @remarks
 * Having a custom implementation avoids a dependency on `events` for maximum compatibility across environments & module systems.
 *
 * @see DataAPIClientEventMap
 *
 * @public
 */
export declare class HierarchicalLogger<Events extends Record<string, BaseClientEvent>> {
    /* Excluded from this release type: internal */
    /* Excluded from this release type: __constructor */
    updateLoggingConfig(config: LoggingConfig): void;
    /**
     * Subscribe to an event.
     *
     * @param eventName - The event to listen for.
     * @param listener - The callback to invoke when the event is emitted.
     *
     * @returns A function to unsubscribe the listener.
     */
    on<E extends keyof Events>(eventName: E, listener: (event: Events[E]) => void): () => void;
    /**
     * Unsubscribe from an event.
     *
     * @param eventName - The event to unsubscribe from.
     * @param listener - The listener to remove.
     */
    off<E extends keyof Events>(eventName: E, listener: (event: Events[E]) => void): void;
    /**
     * Subscribe to an event once.
     *
     * The listener will be automatically unsubscribed after the first time it is called.
     *
     * Note that the listener will be unsubscribed BEFORE the actual listener callback is invoked.
     *
     * @param eventName - The event to listen for.
     * @param listener - The callback to invoke when the event is emitted.
     *
     * @returns A function to prematurely unsubscribe the listener.
     */
    once<E extends keyof Events>(eventName: E, listener: (event: Events[E]) => void): () => void;
    /**
     * Remove all listeners for an event.
     *
     * If no event is provided, all listeners for all events will be removed.
     *
     * @param eventName - The event to remove listeners for.
     */
    removeAllListeners<E extends keyof Events>(eventName?: E): void;
}

/* Excluded from this release type: HttpClient */

/* Excluded from this release type: HTTPClientOptions */

/* Excluded from this release type: HttpMethods */

/* Excluded from this release type: HttpMethodStrings */

/**
 * ##### Overview
 *
 * The options available for the {@link DataAPIClient} related to making HTTP requests.
 *
 * There are three different behaviors for setting the client:
 * - `client: 'fetch'` or not setting the `httpOptions` at all
 *   - This will use the native `fetch` API
 * - `client: 'fetch-h2'`
 *   - This will use the provided `fetch-h2` module for HTTP/2 requests
 * - `client: 'custom'`
 *   - This will allow you to pass a custom `Fetcher` implementation to the client
 *
 * ##### HTTP/2 support
 *
 * [`fetch-h2`](https://www.npmjs.com/package/fetch-h2) is a fetch implementation that supports HTTP/2, and may offer notable performance gains.
 *
 * However, **it is not included in the SDK by default (for compatability reasons)**; the module will need to be manually provided by the user.
 *
 * Luckily, it takes only a couple of easy steps. See {@link FetchH2HttpClientOptions} for more information.
 *
 * Alternatively, if using Node.js, you may use a custom Undici `Dispatcher` configured to use HTTP/2 with `fetch` instead. See below for more information.
 *
 * ##### Using your own {@link Fetcher} implementation
 *
 * `custom` may be used for advanced users who want to use their own fetch implementation, or modify an existing one to suit their needs.
 *
 * For example, if you want to use a custom HTTP `Agent`/`Dispatcher`, or modify `fetch`'s `RequestInit` in any way, you can easily do so by extending the {@link FetchNative} class.
 *
 * See {@link CustomHttpClientOptions} for more information.
 *
 * ##### Examples & more info
 *
 * *For advanced examples & more information, see the `examples/customize-http` & `examples/using-http2` directories in the [astra-db-ts repository](https://github.com/datastax/astra-db-ts)*
 *
 * @see {@link FetchH2HttpClientOptions}
 *
 * @public
 */
export declare type HttpOptions = FetchH2HttpClientOptions | FetchHttpClientOptions | CustomHttpClientOptions | {
    client: 'default';
    ERROR: 'ERROR: fetch-h2 is no longer the default client; it must be set using `client: "fetch-h2"`. See `FetchH2HttpClientOptions` for more information.';
};

/* Excluded from this release type: HttpOptsHandler */

/* Excluded from this release type: HTTPRequestInfo */

/**
 * @public
 */
export declare type HybridSort = Record<string, SortDirection | string | number[] | DataAPIVector | HybridSortObject> & {
    $hybrid: string | HybridSortObject;
};

export declare interface HybridSortObject {
    $vectorize?: string;
    $lexical?: string;
    $vector?: number[] | DataAPIVector;
    [col: string]: string | number[] | DataAPIVector | undefined;
}

/**
 * Extracts the `_id` type from a given schema, or defaults to `SomeId` if uninferable
 *
 * @public
 */
export declare type IdOf<Doc> = Doc extends {
    _id?: infer Id extends SomeId;
} ? Id : SomeId;

/**
 * A shorthand function for `new DataAPIInet(addr, version?)`
 *
 * @public
 */
export declare const inet: (address: string | DataAPIInet, version?: 4 | 6 | null) => DataAPIInet;

/**
 * ##### Overview
 *
 * Enumerates the possible source types from which a {@link Table}'s TypeScript type can be inferred using {@link InferTableSchema}-like utility types.
 *
 * This means that there are **multiple ways to infer a table's schema**, and the type system will **automatically pick the right one** based on the context in which it is used.
 *
 * ---
 *
 * ##### ✨Inferring from a {@link CreateTableDefinition} (recommended)
 *
 * The recommended way to infer the TS-type of the table is by using the {@link Table.schema} method to create a {@link CreateTableDefinition} object, and then using the {@link InferTableSchema}-like utility types to infer the TS-type from that object.
 *
 * This is recommended over the below inferring methods because this method:
 *   - Allows you to easily define your schemas separate of the table, outside a scoped async context
 *     - Mostly relevant for CJS users, since ESM users can use top-level _await_
 *   - Allows you to override the type of specific datatypes
 *     - (via {@link TableSchemaTypeOverrides})
 *   - Provides localized type errors if any primary keys don't use a valid column
 *     - Not possible with writing the schema inline in {@link Db.createTable}
 *
 * @example
 * ```ts
 * // Table.schema just validates the type of the definition
 * const UserSchema = Table.schema({
 *   columns: {
 *     id: 'text',
 *     dob: 'date',
 *     friends: { type: 'map', keyType: 'text', valueType: 'uuid' },
 *   },
 *   primaryKey: {
 *     partitionBy: ['id'],
 *     partitionSort: { dob: -1 }
 *   },
 * });
 *
 * // equivalent to:
 * // type User = {
 * //   id: string,
 * //   dob: DataAPIDate,
 * //   friends?: Map<string, UUID>, (optional since it's not in the primary key)
 * // }
 * type User = InferTableSchema<typeof UserSchema>;
 *
 * // equivalent to:
 * // type UserPK = Pick<User, 'id' | 'dob'>;
 * type UserPK = InferTablePrimaryKey<typeof mkTable>;
 *
 * // table :: Table<User, UserPK>
 * const table = await db.createTable<User, UserPK>('users', {
 *   definition: UserSchema,
 *   ifNotExists: true,
 * });
 * ```
 *
 * ---
 *
 * ##### Inferring from a {@link Table} instance
 *
 * You can also infer the schema from a {@link Table} instance directly, if necessary.
 *
 * This type provides flexible ways to infer a table’s schema—whether from a {@link Table} instance directly, a `Promise` resolving to a `Table`, or a function returning either of those.
 * - This flexibility is especially helpful in CJS environments, where tables are often created inside async functions.
 *
 * @example
 * ```ts
 * // ESM users can use top-level _await_ to create the table instance
 * // and the type may be declared globally without issue
 * const table = await db.createTable('users', {
 *   definition: {
 *     columns: ...,
 *     primaryKey: ...,
 *   }
 * });
 *
 * type User = InferTableSchema<typeof table>;
 * type UserPK = InferTablePrimaryKey<typeof table>;
 * ```
 *
 *
 * @example
 * ```ts
 * // CJS users may not be able to use top-level _await_ to create the table instance
 * // but may instead create a utility function to create the table instance
 * // and use the type of that function to infer the table's type globally
 * const mkUsersTable = async () => await db.createTable('users', {
 *   definition: ...,
 * });
 *
 * type User = InferTableSchema<typeof mkUsersTable>;
 * type UserPK = InferTablePrimaryKey<typeof mkUsersTable>;
 *
 * async function main() {
 *  const table = await mkUsersTable();
 * }
 * ```
 *
 * @see Table.schema
 * @see InferTableSchema
 * @see InferTablePrimaryKey
 * @see InferTableReadSchema
 *
 * @public
 */
export declare type InferrableTableSchema = CreateTableDefinition | ((..._: any[]) => Promise<Table<SomeRow>>) | ((..._: any[]) => Table<SomeRow>) | Promise<Table<SomeRow>> | Table<SomeRow>;

declare type InferTablePKFromDefinition<FullDef extends CreateTableDefinition<FullDef>, Overrides extends TableSchemaTypeOverrides> = Normalize<MkPrimaryKeyType<FullDef, Cols2CqlTypes<FullDef['columns'], Overrides>>>;

/**
 * ##### Overview
 *
 * Automagically extracts a table's primary key from a {@link CreateTableDefinition} or some Table<Schema>-like type.
 *
 * See {@link InferTableSchema} for more information & examples.
 *
 * @public
 */
export declare type InferTablePrimaryKey<T extends InferrableTableSchema, Overrides extends TableSchemaTypeOverrides = Record<never, never>> = T extends CreateTableDefinition ? InferTablePKFromDefinition<T, Overrides> : Record<never, never> extends Overrides ? T extends (..._: any[]) => Promise<Table<any, infer PKey, any>> ? PKey : T extends (..._: any[]) => Table<any, infer PKey, any> ? PKey : T extends Promise<Table<any, infer PKey, any>> ? PKey : T extends Table<any, infer PKey, any> ? PKey : never : 'ERROR: Can not provide TypeOverrides if not inferring the type from a CreateTableDefinition';

/**
 * ##### Overview
 *
 * Automagically extracts a table's read-schema from a {@link CreateTableDefinition} or some Table<Schema>-like type.
 *
 * See {@link InferTableSchema} for more information & examples.
 *
 * @public
 */
export declare type InferTableReadSchema<T extends InferrableTableSchema, Overrides extends TableSchemaTypeOverrides = Record<never, never>> = T extends CreateTableDefinition ? FoundRow<InferTableSchemaFromDefinition<T, Overrides>> : Record<never, never> extends Overrides ? T extends (..._: any[]) => Promise<Table<any, any, infer Schema>> ? Schema : T extends (..._: any[]) => Table<any, any, infer Schema> ? Schema : T extends Promise<Table<any, any, infer Schema>> ? Schema : T extends Table<any, any, infer Schema> ? Schema : never : 'ERROR: Can not provide TypeOverrides if not inferring the type from a CreateTableDefinition';

/**
 * ##### Overview
 *
 * Automagically extracts a table's schema from a {@link CreateTableDefinition} or some Table<Schema>-like type.
 * - You can think of it as similar to Zod or arktype's `infer<Schema>` types.
 * - This is most useful when creating a new table via {@link Db.createTable}.
 *
 * It accepts various different (contextually) isomorphic types to account for differences in instantiation & usage.
 *
 * > **💡Tip:** Please see {@link InferrableTableSchema} for the different ways to use this utility type, and see {@link TableSchemaTypeOverrides} for how to override the type of specific datatypes.
 *
 * > **✏️Note:** A DB's type information is inferred by `db.createTable` by default. To override this behavior, please provide the table's type explicitly to help with transpilation times (e.g. `db.createTable<SomeRow>(...)`).
 *
 * @example
 * ```ts
 * // Table.schema just validates the type of the definition
 * const UserSchema = Table.schema({
 *   columns: {
 *     id: 'text',
 *     dob: 'date',
 *     friends: { type: 'map', keyType: 'text', valueType: 'uuid' },
 *   },
 *   primaryKey: {
 *     partitionBy: ['id'],
 *     partitionSort: { dob: -1 }
 *   },
 * });
 *
 * // equivalent to:
 * // type User = {
 * //   id: string,
 * //   dob: DataAPIDate,
 * //   friends?: Map<string, UUID>, (optional since it's not in the primary key)
 * // }
 * type User = InferTableSchema<typeof UserSchema>;
 *
 * // equivalent to:
 * // type UserPK = Pick<User, 'id' | 'dob'>;
 * type UserPK = InferTablePrimaryKey<typeof mkTable>;
 *
 * // table :: Table<User, UserPK>
 * const table = await db.createTable<User, UserPK>('users', {
 *   definition: UserSchema,
 *   ifNotExists: true,
 * });
 * ```
 *
 * @see InferrableTableSchema
 * @see TableSchemaTypeOverrides
 * @see Table.schema
 * @see InferTablePrimaryKey
 * @see InferTableReadSchema
 *
 * @public
 */
export declare type InferTableSchema<T extends InferrableTableSchema, Overrides extends TableSchemaTypeOverrides = Record<never, never>> = T extends CreateTableDefinition ? InferTableSchemaFromDefinition<T, Overrides> : Record<never, never> extends Overrides ? T extends (..._: any[]) => Promise<Table<infer Schema, any, any>> ? Schema : T extends (..._: any[]) => Table<infer Schema, any, any> ? Schema : T extends Promise<Table<infer Schema, any, any>> ? Schema : T extends Table<infer Schema, any, any> ? Schema : never : 'ERROR: Can not provide TypeOverrides if not inferring the type from a CreateTableDefinition';

declare type InferTableSchemaFromDefinition<FullDef extends CreateTableDefinition<FullDef>, Overrides extends TableSchemaTypeOverrides> = Normalize<MkColumnTypes<FullDef['columns'], MkPrimaryKeyType<FullDef, Cols2CqlTypes<FullDef['columns'], Overrides>>, Overrides>>;

/* Excluded from this release type: InternalLogger */

/**
 * An exception thrown when certain operations are attempted in a {@link DataAPIEnvironment} that is not valid.
 *
 * @field currentEnvironment - The environment that was attempted to be used
 * @field expectedEnvironments - The environments that are valid for the operation
 *
 * @public
 */
export declare class InvalidEnvironmentError extends Error {
    /**
     * The environment that was attempted to be used.
     */
    readonly currentEnvironment: string;
    /**
     * The environments that are valid for the operation.
     */
    readonly expectedEnvironments: string[];
    /* Excluded from this release type: __constructor */
}

/**
 * Checks if a type is any
 *
 * @public
 */
export declare type IsAny<T> = true extends false & T ? true : false;

/**
 * Checks if a type can possibly be a date
 *
 * @example
 * ```typescript
 * IsDate<string | Date> === boolean
 * ```
 *
 * @public
 */
export declare type IsDate<T> = IsAny<T> extends true ? true : T extends Date | {
    $date: number;
} ? true : false;

/**
 * Checks if a type can possibly be some number
 *
 * @example
 * ```typescript
 * IsNum<string | number> === true
 * ```
 *
 * @public
 */
export declare type IsNum<T> = number extends T ? true : bigint extends T ? true : false;

/* Excluded from this release type: KeyspaceRef */

/**
 * Represents the replication options for a keyspace.
 *
 * Two replication strategies are available:
 *
 * - SimpleStrategy: Use only for a single datacenter and one rack. If you ever intend more than one datacenter, use the `NetworkTopologyStrategy`.
 *
 * - NetworkTopologyStrategy: Highly recommended for most deployments because it is much easier to expand to multiple datacenters when required by future expansion.
 *
 * If no replication options are provided, it will default to `'SimpleStrategy'` with a replication factor of `1`.
 *
 * @example
 * ```typescript
 * await dbAdmin.createKeyspace('my_keyspace');
 *
 * await dbAdmin.createKeyspace('my_keyspace', {
 *   replication: {
 *     class: 'SimpleStrategy',
 *     replicatonFactor: 3,
 *   },
 * });
 *
 * await dbAdmin.createKeyspace('my_keyspace', {
 *   replication: {
 *     class: 'NetworkTopologyStrategy',
 *     datacenter1: 3,
 *     datacenter1: 2,
 *   },
 * });
 * ```
 *
 * See the [datastax docs](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/architecture/archDataDistributeReplication.html) for more info.
 *
 * @public
 */
export declare type KeyspaceReplicationOptions = {
    class: 'SimpleStrategy';
    replicationFactor: number;
} | {
    class: 'NetworkTopologyStrategy';
    [datacenter: string]: number | 'NetworkTopologyStrategy';
};

export declare interface LexicalDoc {
    $lexical?: string;
}

/**
 * The name of the library.
 *
 * @public
 */
export declare const LIB_NAME = "astra-db-ts";

/**
 * The version of the library.
 *
 * @public
 */
export declare const LIB_VERSION = "2.0.1";

/**
 * Represents the options for listing databases.
 *
 * @field include - Allows filtering so that databases in listed states are returned.
 * @field provider - Allows filtering so that databases from a given provider are returned.
 * @field limit - Specify the number of items for one page of data.
 * @field skip - Starting value for retrieving a specific page of results.
 *
 * @public
 */
export declare interface ListAstraDatabasesOptions extends WithTimeout<'databaseAdminTimeoutMs'> {
    /**
     * Allows filtering so that databases in listed states are returned.
     */
    include?: AstraDatabaseStatusFilter;
    /**
     * Allows filtering so that databases from a given provider are returned.
     */
    provider?: AstraDatabaseCloudProviderFilter;
    /**
     * Optional parameter for pagination purposes. Specify the number of items for one page of data.
     *
     * Should be between 1 and 100.
     *
     * Defaults to 25.
     *
     * @defaultValue 25
     */
    limit?: number;
    /**
     * Optional parameter for pagination purposes. Pass the UUID of the last item on the previous page to get the next page.
     */
    startingAfter?: string;
}

/**
 * Options for listing collections.
 *
 * @field nameOnly - If true, only the name of the collections is returned. If false, the full collections info is returned. Defaults to true.
 * @field keyspace - Overrides the keyspace to list collections from. If not provided, the default keyspace is used.
 * @field timeout - The timeout override for this method
 *
 * @see Db.listCollections
 *
 * @public
 */
export declare interface ListCollectionsOptions extends WithTimeout<'collectionAdminTimeoutMs'>, WithKeyspace {
    /**
     * If true, only the name of the collections is returned.
     *
     * If false, the full collections info is returned.
     *
     * Defaults to true.
     *
     * @example
     * ```typescript
     * const names = await db.listCollections({ nameOnly: true });
     * console.log(names); // [{ name: 'my_coll' }]
     *
     * const info = await db.listCollections({ nameOnly: false });
     * console.log(info); // [{ name: 'my_coll', options: { ... } }]
     * ```
     *
     * @defaultValue true
     */
    nameOnly?: boolean;
}

/**
 * ##### Overview
 *
 * The column definitions for a table, used in {@link ListTableDefinition}.
 *
 * The keys are the column names, and the values are the column definitions.
 *
 * ##### No shorthand
 *
 * Unlike {@link CreateTableDefinition}, `ListTableColumnDefinitions` does not return column definitions in their shorthand notation, even if they were created with them.
 *
 * See {@link ListTableDefinition} for more information.
 *
 * ##### `apiSupport`
 *
 * The column definitions may or may not include the `apiSupport` field, depending on the column's type.
 *
 * See {@link ListTableDefinition} for more information.
 *
 * @public
 */
export declare type ListTableColumnDefinitions = Record<string, ListTableKnownColumnDefinition | ListTableUnsupportedColumnDefinition>;

/**
 * ##### Overview
 *
 * The response type of {@link Db.listTables} (without `nameOnly: true`), which is very similar to {@link CreateTableDefinition}, except
 * for a couple key differences.
 *
 * ##### No shorthands
 *
 * Unlike {@link CreateTableDefinition}, `ListTableDefinition` does not return column nor primary key definitions in their shorthand notation, even if they were created with them.
 *
 * Instead, their full definitions are always returned, meaning, if you defined a table like so:
 *
 * ```ts
 * const table = db.schema.createTable('my_table', {
 *   definition: {
 *     columns: {
 *       id: 'uuid',
 *       name: 'text',
 *     }
 *     primaryKey: 'id',
 *   }
 * });
 * ```
 *
 * The returned `ListTableDefinition` would look like this:
 *
 * ```ts
 * {
 *   columns: {
 *     id: { type: 'uuid' },
 *     name: { type: 'text' },
 *   },
 *   primaryKey: {
 *     partitionKey: ['id'],
 *     partitionSort: {},
 *   },
 * }
 * ```
 *
 * ##### `apiSupport`
 *
 * If the table was created with any partially-supported or fully-unsupported types, the `apiSupport` field will be present on the column definition.
 *
 * If the column is unable to be created through the Data API, the column `type` will be exactly `'UNSUPPORTED'` and the `apiSupport` field will be present.
 *
 * However, it is possible for columns created through the Data API to also have the `apiSupport` field, if the column was created with a type that is partially unsupported.
 *
 * The `apiSupport` block dictates which operations are supported for the column; for example, if the column is unsupported for filtering on, the `filter` field will be `false`. Not all unsupported types are completely unusable.
 *
 * @field columns - The columns of the tables.
 * @field primaryKey - The primary key of the tables.
 *
 * @see CreateTableDefinition
 * @see ListTablesOptions
 * @see Db.listTables
 *
 * @public
 */
export declare interface ListTableDefinition {
    columns: ListTableColumnDefinitions;
    primaryKey: ListTablePrimaryKeyDefinition;
}

/**
 * ##### Overview
 *
 * The column definition for a table, used in {@link ListTableColumnDefinitions}.
 *
 * The definition is very similar to {@link StrictCreateTableColumnDefinition}, except for the potential of having a `apiSupport` field.
 *
 * ##### No shorthand
 *
 * Unlike {@link StrictCreateTableColumnDefinition}, `ListTableKnownColumnDefinition` does not return column definitions in their shorthand notation, even if they were created with them.
 *
 * See {@link ListTableDefinition} for more information.
 *
 * ##### `apiSupport`
 *
 * If the column can not be created through the Data API, the column `type` will be exactly `'UNSUPPORTED'` and the `apiSupport` field will be present. See {@link ListTableUnsupportedColumnDefinition} for more information.
 *
 * However, it is possible for columns created through the Data API to also have the `apiSupport` field, if the column was created with a type that is partially unsupported.
 *
 * The `apiSupport` block dictates which operations are supported for the column; for example, if the column is unsupported for filtering on, the `filter` field will be `false`. Not all unsupported types are completely unusable.
 *
 * @field apiSupport - The API support for the column.
 *
 * @see ListTableUnsupportedColumnDefinition
 *
 * @public
 */
export declare type ListTableKnownColumnDefinition = StrictCreateTableColumnDefinition & {
    apiSupport?: ListTableUnsupportedColumnApiSupport;
};

/**
 * ##### Overview
 *
 * The primary key definition for a table, used in {@link ListTableDefinition}.
 *
 * The definition is very similar to {@link FullCreateTablePrimaryKeyDefinition}, except that the `partitionSort` field is always present.
 *
 * ##### No shorthand
 *
 * Unlike {@link TablePrimaryKeyDefinition}, `ListTablePrimaryKeyDefinition` does not return primary key definitions in their shorthand notation, even if they were created with them.
 *
 * See {@link ListTableDefinition} for more information.
 *
 * @public
 */
export declare type ListTablePrimaryKeyDefinition = Required<FullCreateTablePrimaryKeyDefinition<any>>;

/**
 * Options for listing tables.
 *
 * @field nameOnly - If true, only the name of the tables is returned. If false, the full tables info is returned. Defaults to true.
 * @field keyspace - Overrides the keyspace to list tables from. If not provided, the default keyspace is used.
 * @field timeout - The timeout override for this method
 *
 * @see Db.listTables
 *
 * @public
 */
export declare interface ListTablesOptions extends WithTimeout<'tableAdminTimeoutMs'>, WithKeyspace {
    /**
     * If true, only the name of the tables is returned.
     *
     * If false, the full tables info is returned.
     *
     * Defaults to true.
     *
     * @example
     * ```typescript
     * const names = await db.listTables({ nameOnly: true });
     * console.log(names); // [{ name: 'my_table' }]
     *
     * const info = await db.listTables({ nameOnly: false });
     * console.log(info); // [{ name: 'my_table', options: { ... } }]
     * ```
     *
     * @defaultValue true
     */
    nameOnly?: boolean;
}

/**
 * ##### Overview
 *
 * The API support for a column that is partially-supported or fully-unsupported by the Data API, used in {@link ListTableUnsupportedColumnDefinition}.
 *
 * ##### `cqlDefinition`
 *
 * The `cqlDefinition` column displays how the column is defined in CQL, e.g. `frozen<tuple<text, int>>`.
 *
 * This will be present for all columns with the `apiSupport` block, regardless of whether they can be represented by the Data API or not.
 *
 * ##### Other fields
 *
 * The other fields in the `apiSupport` block dictate which operations are supported for the column; for example, if the column is unsupported for filtering on, the `filter` field will be `false`. Not all unsupported types are completely unusable.
 *
 * @field createTable - Whether the column can be created through the Data API.
 * @field insert - Whether the column can be inserted into through the Data API.
 * @field read - Whether the column can be read from through the Data API.
 * @field filter - Whether the column can be filtered on through the Data API.
 * @field cqlDefinition - The CQL definition of the column.
 *
 * @public
 */
export declare interface ListTableUnsupportedColumnApiSupport {
    createTable: boolean;
    insert: boolean;
    read: boolean;
    filter: boolean;
    cqlDefinition: string;
}

/**
 * ##### Overview
 *
 * The column definition for a table that is unsupported by the Data API, used in {@link ListTableColumnDefinitions}.
 *
 * The `apiSupport` block dictates which operations are supported for the column; for example, if the column is unsupported for filtering on, the `filter` field will be `false`. Not all unsupported types are completely unusable.
 *
 * @field type - The type of the column, which is always `'UNSUPPORTED'`.
 * @field apiSupport - The API support for the column.
 *
 * @public
 */
export declare interface ListTableUnsupportedColumnDefinition {
    type: 'UNSUPPORTED';
    apiSupport: ListTableUnsupportedColumnApiSupport;
}

/**
 * Vendored from [type-fest](https://github.com/sindresorhus/type-fest/blob/main/source/literal-union.d.ts)
 *
 * Utility type to represent a union of literal types or a base type without sacrificing intellisense.
 *
 * @public
 */
export declare type LitUnion<LiteralType, BaseType = string> = LiteralType | (BaseType & Record<never, never>);

/* Excluded from this release type: LoggingCfgHandler */

/**
 * ##### Overview
 *
 * The configuration for logging events that may be logged or emitted by the {@link DataAPIClient} or any of its children classes.
 *
 * This can be set at any level of the major class hierarchy, and will be inherited by all child classes.
 *
 * ##### Configuration inheritance
 *
 * Logging is configured through a list of hierarchical _rules_, determining which events to emit where. Each rule layer overrides previous rules for the same events.
 *
 * Logging configuration is inherited by child classes, but may be overridden at any level (e.g. pass a base config to the `DataAPIClient` constructor, and then override it for a specific `Collection`).
 *
 * ##### Configuration & shorthands
 *
 * There are multiple ways to configure logging, and the rules may be combined in various ways:
 *
 * `logging: 'all'`
 * - This will enable all events with default behaviors (see below)
 *
 * `logging: [{ events: 'all', emits: 'event' }]`
 * - This will enable all events, but only emit them as events
 *
 * `logging: '<event>' | ['<events>']`
 * - This will enable only the specified event(s) with default behaviors
 *
 * `logging: /<regex>/ | [/<regex>/]`
 * - This will enable only the matching event(s) with default behaviors
 *
 * `logging: [{ events: ['<events>'], emits: ['<outputs>'] }]`
 * - This will allow you to define the specific outputs for specific events
 *
 * `logging: ['all', { events: ['<events>'], emits: [] }]`
 * - Example of how `'all'` may be used as a base configuration, to be overridden by specific rules
 * - The empty `emits` array effectively disables outputs for the specified events
 *
 * ##### Event types & defaults
 *
 * See {@link DataAPIClientEventMap} for more information on the types of events emitted & their defaults.
 *
 * As a TL;DR, when enabled, all events are emitted as events by default, and `commandStarted` and `commandSucceeded` are the only events not logged to `stderr` as well by default; all other events are logged to `stderr`.
 *
 * ##### Output types
 *
 * The `emits` field can be set to either `'event'`, `'stdout'`, `'stderr'`, or their verbose variants.
 *
 * - `'event'` will emit the event to each {@link HierarchicalLogger} in the hierarchy
 *   - e.g. first to the `Collection`, then the `Db`, then the `DataAPIClient`
 *   - See {@link HierarchicalLogger} for more information on how events are emitted
 * - `'stdout'` & `'stderr'` will log the event to stdout or stderr, respectively
 *   - The `'stdout:verbose'` & `'stderr:verbose'` variants will use a verbose format containing all the events properties
 *   - These are useful for debugging, but may be overwhelming for normal use
 *
 * You may use {@link BaseClientEvent.setDefaultFormatter} to change the format of the events as they're logged to `stdout`/`stderr`. See {@link EventFormatter} for more information.
 *
 * ##### Examples
 *
 * *For more advanced examples, see the `examples/logging` directory in the [astra-db-ts repository](https://github.com/datastax/astra-db-ts)*
 *
 * Hierarchical usage example:
 *
 * @example
 * ```ts
 * // Create a `DataAPIClient` with emission enabled for all failed/warning commands
 * const client = new DataAPIClient('*TOKEN*', {
 *   logging: [{ events: /.*(Failed|Warning)/, emits: ['stderr:verbose', 'event']}],
 * });
 *
 * client.on('commandFailed', (event) => {
 *   console.error('Some command failed:', event.commandName);
 * });
 *
 * // Override the logging config for this `Db` to emit *all* events as events
 * const db = client.db('*ENDPOINT*', {
 *   logging: [{ events: 'all', emits: 'event' }],
 * });
 *
 * db.on('commandStarted', (event) => {
 *   console.log('Command started:', event.commandName);
 * });
 *
 * db.on('commandSucceeded', (event) => {
 *   console.log('Command succeeded:', event.commandName);
 * });
 *
 * // Resulting output:
 * // 'Command started: "createCollection"'
 * // 'Some command failed: "createCollection"'
 * await db.createCollection('$invalid-name$');
 * ```
 *
 * Various configuration examples:
 *
 * @example
 * ```ts
 * // Set sane defaults for logging
 * const client = new DataAPIClient({
 *   logging: 'all',
 * });
 *
 * // Just emit all events as events
 * const client = new DataAPIClient({
 *   logging: [{ events: 'all', emits: 'event' }],
 * });
 *
 * // Define specific outputs for specific events
 * const client = new DataAPIClient({
 *   logging: [
 *     { events: ['commandStarted', 'commandSucceeded'], emits: ['stdout', 'event'] },
 *     { events: ['commandFailed'], emits: ['stderr', 'event'] },
 *   ],
 * });
 *
 * // Use 'all' as a base configuration, and override specific events
 * const client = new DataAPIClient({
 *   logging: ['all', { events: /.*(Started|Succeeded)/, emits: [] }],
 * });
 *
 * // Enable specific events with default behaviors
 * const client = new DataAPIClient({
 *   logging: ['commandSucceeded', 'adminCommandStarted'],
 * });
 * ```
 *
 * @see DataAPIClientEventMap
 * @see LoggingEvent
 * @see LoggingOutput
 *
 * @public
 */
export declare type LoggingConfig = LoggingEvent | readonly (LoggingEvent | ExplicitLoggingConfig)[];

/**
 * ##### Overview
 *
 * Represents the different events that can be emitted/logged by the {@link DataAPIClient},
 * or any of its children classes.
 *
 * Additionally, you may use regular expressions or `'all'` to match multiple events at once.
 *
 * See {@link DataAPIClientEventMap} & {@link LoggingConfig} for much more info.
 *
 * ##### Regex matching
 *
 * Regular expressions are a way to match multiple events at once. For example:
 *
 * ```ts
 * const client = new DataAPIClient({
 *   logging: [{ events: `/.*(Started|Succeeded)/`, emits: 'stderr:verbose' }],
 * });
 * ```
 *
 * is equivalent to:
 *
 * ```ts
 * const client = new DataAPIClient({
 *   logging: [{
 *     events:
 *       [ 'commandStarted', 'commandSucceeded'
 *       , 'adminCommandStarted', 'adminCommandSucceeded'
 *       ],
 *     emits: 'stderr:verbose',
 *   }],
 * });
 * ```
 *
 * ##### Using `'all'`
 *
 * `'all'` is simply a more semantic alternative to using the regex `/.*／` to match all events. There is no functional difference between the two.
 *
 * You may use it to enable all events at once with sane defaults:
 *
 * ```ts
 * logging: 'all'
 * ```
 *
 * Or to specify the output for all events at once:
 *
 * ```ts
 * logging: [{ events: 'all', emits: 'stderr:verbose' }]
 * ```
 *
 * Or even as a base config to override with specific rules later:
 *
 * ```ts
 * logging: ['all', { events: ['commandStarted', 'commandSucceeded'], emits: [] }]
 * ```
 *
 * @see LoggingConfig
 * @see LoggingOutput
 *
 * @public
 */
export declare type LoggingEvent = 'all' | keyof DataAPIClientEventMap | RegExp;

/**
 * A list of all possible logging events.
 *
 * @public
 */
export declare const LoggingEvents: readonly ["adminCommandStarted", "adminCommandPolling", "adminCommandSucceeded", "adminCommandFailed", "adminCommandWarnings", "commandStarted", "commandFailed", "commandSucceeded", "commandWarnings"];

/**
 * ##### Overview
 *
 * Represents the different outputs that can be logged/emitted by the {@link DataAPIClient}, or any of its children classes.
 *
 * This can be set to either `'event'`, `'stdout'`, `'stderr'`, `'stdout:verbose'`, or `'stderr:verbose'`.
 *
 * See {@link DataAPIClientEventMap} & {@link LoggingConfig} for much more info.
 *
 * See {@link BaseClientEvent.setDefaultFormatter} for information on how to change the format of the events as they're logged to `stdout`/`stderr`.
 *
 * @see LoggingConfig
 * @see LoggingEvent
 *
 * @public
 */
export declare type LoggingOutput = 'event' | 'stdout' | 'stderr' | 'stdout:verbose' | 'stderr:verbose';

/**
 * A list of all possible logging outputs.
 *
 * @public
 */
export declare const LoggingOutputs: readonly ["event", "stdout", "stderr", "stdout:verbose", "stderr:verbose"];

/**
 * ##### Overview
 *
 * The loose column definition is a shorthand for the strict version, and follows the following example form:
 *
 * ```ts
 * columns: {
 *   textCol: 'text',
 *   uuidCol: 'uuid',
 * }
 * ```
 *
 * In this form, the key is the column name, and the value is the type of the scalar column.
 *
 * If you need to define a column with a more complex type (i.e. for maps, sets, lists, and vectors), you must use the strict column definition.
 *
 * Plus, while it still provides autocomplete, the loose column definition does not statically enforce the type of the column, whereas the strict column definition does.
 *
 * @public
 */
export declare type LooseCreateTableColumnDefinition = TableScalarType | (string & Record<never, never>);

/**
 * Represents a `Buffer` type, if available.
 *
 * @public
 */
export declare type MaybeBuffer = typeof globalThis extends {
    Buffer: infer B extends SomeConstructor;
} ? InstanceType<B> : never;

/**
 * Allows the given type to include an `_id` or not, even if it's not declared in the type
 *
 * @public
 */
export declare type MaybeId<T> = NoId<T> & {
    _id?: IdOf<T>;
};

declare type MDN = [number, number, bigint];

declare type Merge<Ts> = Expand<UnionToIntersection<Ts>>;

declare type MkColumnTypes<Cols extends CreateTableColumnDefinitions, PK extends Record<string, any>, Overrides extends TableSchemaTypeOverrides> = {
    -readonly [P in keyof Cols as P extends keyof PK ? P : never]-?: CqlType2TSType<Cols[P], Overrides> & {};
} & {
    -readonly [P in keyof Cols as P extends keyof PK ? never : P]+?: CqlType2TSType<Cols[P], Overrides>;
};

declare type MkPrimaryKeyType<FullDef extends CreateTableDefinition, Schema, PK extends FullCreateTablePrimaryKeyDefinition<any> = NormalizePK<FullDef['primaryKey']>> = Normalize<{
    -readonly [P in PK['partitionBy'][number]]: P extends keyof Schema ? Schema[P] & {} : TypeErr<`Field \`${P & string}\` not found as property in table definition`>;
} & (PK['partitionSort'] extends object ? {
    -readonly [P in keyof PK['partitionSort']]: P extends keyof Schema ? Schema[P] & {} : TypeErr<`Field \`${P & string}\` not found as property in table definition`>;
} : EmptyObj)>;

/* Excluded from this release type: MkTimeoutError */

/* Excluded from this release type: Monoid */

/* Excluded from this release type: monoid */

/* Excluded from this release type: monoid_2 */

/* Excluded from this release type: monoid_3 */

/* Excluded from this release type: monoid_4 */

/* Excluded from this release type: MonoidalOptionsHandler */

/* Excluded from this release type: MonoidType */

/**
 * Represents a doc that doesn't have an `_id`
 *
 * @public
 */
export declare type NoId<Doc> = Omit<Doc, '_id'>;

/**
 * @public
 */
export declare interface NominalCodecOpts<SerCtx, DesCtx> {
    serialize?: SerDesFn<SerCtx>;
    deserialize?: SerDesFn<DesCtx>;
}

/**
 * Utility type to represent a non-empty array.
 *
 * @public
 */
export declare type NonEmpty<T> = [T, ...T[]];

declare type Normalize<T> = {
    [K in keyof T]: T[K];
} & EmptyObj;

declare type NormalizePK<PK extends TablePrimaryKeyDefinition<any>> = PK extends string ? {
    partitionBy: [PK];
} : PK extends object ? PK : never;

/**
 * ##### Overview
 *
 * Represents the set of fields that are present in the result of a generic `update*` command performed on the Data API, when:
 * - The `upsert` option is `false`, _or_
 * - The `upsert` option is `true`, but no upsert occurred.
 *
 * @see GenericUpdateResult
 * @see UpsertedUpdateResult
 *
 * @public
 */
export declare interface NoUpsertUpdateResult {
    /**
     * The number of records that were upserted. This will always be 0, since none occurred.
     */
    upsertedCount: 0;
    /**
     * This field is never present.
     */
    upsertedId?: never;
}

/**
 * Shorthand type to represent some nullish value.
 *
 * @public
 */
export declare type nullish = null | undefined;

/**
 * @public
 */
export declare class NumCoercionError extends Error {
    readonly path: readonly PathSegment[];
    readonly value: number | BigNumber;
    readonly from: 'number' | 'bignumber';
    readonly to: CollNumCoercion;
    /* Excluded from this release type: __constructor */
}

/* Excluded from this release type: ObjBasedTypes */

/* Excluded from this release type: ObjectBasedHeadersProviderOptsHandler */

/**
 * Represents an ObjectId that can be used as an _id in the DataAPI.
 *
 * Provides methods for generating ObjectIds and getting the timestamp of an ObjectId.
 *
 * @example
 * ```typescript
 * const collections = await db.createCollection('myCollection'. {
 *   defaultId: {
 *     type: 'objectId',
 *   },
 * });
 *
 * await collections.insertOne({ album: 'Inhuman Rampage' });
 *
 * const doc = await collections.findOne({ album: 'Inhuman Rampage' });
 *
 * // Prints the ObjectId of the document
 * console.log(doc._id.toString());
 *
 * // Prints the timestamp when the document was created (server time)
 * console.log(doc._id.getTimestamp());
 * ```
 *
 * @example
 * ```typescript
 * await collections.insertOne({ _id: new ObjectId(), album: 'Sacrificium' });
 *
 * const doc = await collections.findOne({ album: 'Sacrificium' });
 *
 * // Prints the ObjectId of the document
 * console.log(doc._id.toString());
 *
 * // Prints the timestamp when the document was created (server time)
 * console.log(doc._id.getTimestamp());
 * ```
 *
 * @public
 */
export declare class ObjectId implements CollectionCodec<typeof ObjectId> {
    private readonly _raw;
    /**
     * Errorful implementation of `$SerializeForTable` for {@link TableCodec}
     *
     * Throws a human-readable error message warning that this datatype may not be used with tables without writing a custom ser/des codec.
     */
    [$SerializeForTable](): void;
    /**
     * Implementation of `$SerializeForCollection` for {@link TableCodec}
     */
    [$SerializeForCollection](ctx: CollectionSerCtx): readonly [0, ({
        $objectId: string;
    } | undefined)?];
    /**
     * Implementation of `$DeserializeForCollection` for {@link TableCodec}
     */
    static [$DeserializeForCollection](value: any, ctx: CollectionDesCtx): readonly [0, (ObjectId | undefined)?];
    /**
     * Creates a new ObjectId instance.
     *
     * If `id` is provided, it must be a 24-character hex string. Otherwise, a new ObjectId is generated.
     *
     * @param id - The ObjectId string.
     * @param validate - Whether to validate the ObjectId string. Defaults to `true`.
     */
    constructor(id?: string | number | ObjectId | null, validate?: boolean);
    /**
     * Compares this ObjectId to another ObjectId.
     *
     * **The other ObjectId can be an ObjectId instance or a string.**
     *
     * An ObjectId is considered equal to another ObjectId if their string representations are equal.
     *
     * @param other - The ObjectId to compare to.
     *
     * @returns `true` if the ObjectIds are equal, `false` otherwise.
     */
    equals(other: unknown): boolean;
    /**
     * Returns the timestamp of the ObjectId.
     *
     * @returns The timestamp of the ObjectId.
     */
    getTimestamp(): Date;
    /**
     * Returns the string representation of the ObjectId.
     */
    toString(): string;
}

/**
 * A shorthand function for `new ObjectId(oid?)`
 *
 * @public
 */
export declare const oid: (id?: string | number | null | ObjectId) => ObjectId;

/**
 * Utility type to represent a value that can be either a single value or an array of values.
 *
 * @public
 */
export declare type OneOrMany<T> = T | readonly T[];

/**
 * Unstable backdoor to some class's internal HTTP client. No guarantees are made about this type.
 *
 * @public
 */
export declare type OpaqueHttpClient = any;

/* Excluded from this release type: OptionsHandler */

/* Excluded from this release type: OptionsHandlerTypes */

/* Excluded from this release type: Parsed */

/* Excluded from this release type: ParsedAdminOptions */

/* Excluded from this release type: ParsedCaller */

/* Excluded from this release type: ParsedDbOptions */

/* Excluded from this release type: ParsedEnvironment */

/* Excluded from this release type: ParsedHeadersProviders */

/* Excluded from this release type: ParsedLoggingConfig */

/* Excluded from this release type: ParsedRootClientOpts */

/* Excluded from this release type: ParsedSerDesConfig_2 */

/* Excluded from this release type: ParsedTimeoutDescriptor_2 */

/* Excluded from this release type: ParsedTokenProvider */

/**
 * Represents a path segment, when representing paths as arrays.
 *
 * For example, `['products', 0, 'price.usd']`, which equals the string path `products.0.price&.usd`.
 *
 * @public
 */
export declare type PathSegment = string | number;

/**
 * Picks the array types from a type that may be an array.
 *
 * @public
 */
export declare type PickArrayTypes<Schema> = Extract<Schema, any[]> extends (infer E)[] ? E : never;

declare type PickCqlType<Def> = Def extends {
    type: infer Type;
} ? Type : Def;

/**
 * Specifies which fields should be included/excluded in the returned documents.
 *
 * Can use `1`/`0`, or `true`/`false`.
 *
 * There's a special field `'*'` that can be used to include/exclude all fields.
 *
 * @example
 * ```typescript
 * // Include _id, name, and address.state
 * const projection1: Projection = {
 *   _id: 0,
 *   name: 1,
 *   'address.state': 1,
 * }
 *
 * // Exclude the $vector
 * const projection2: Projection = {
 *   $vector: 0,
 * }
 *
 * // Return array indices 2, 3, 4, and 5
 * const projection3: Projection = {
 *   test_scores: { $slice: [2, 4] },
 * }
 * ```
 *
 * @public
 */
export declare type Projection = Record<string, 1 | 0 | boolean | ProjectionSlice>;

/**
 * Specifies the number of elements in an array to return in the query result.
 *
 * Has one of the following forms:
 * ```
 * // Return the first two elements
 * { $slice: 2 }
 *
 * // Return the last two elements
 * { $slice: -2 }
 *
 * // Skip 4 elements (from 0th index), return the next 2
 * { $slice: [4, 2] }
 *
 * // Skip backward 4 elements, return next 2 elements (forward)
 * { $slice: [-4, 2] }
 * ```
 *
 * @example
 * ```typescript
 * await collections.insertOne({ arr: [1, 2, 3, 4, 5] });
 *
 * // Return [1, 2]
 * await collections.findOne({}, {
 *   projection: {
 *     arr: { $slice: 2 },
 *   },
 * });
 *
 * // Return [3, 4]
 * await collections.findOne({}, {
 *   projection: {
 *     arr: { $slice: [-3, 2] },
 *   },
 * });
 * ```
 *
 * @public
 */
export declare interface ProjectionSlice {
    /**
     * Either of the following:
     * - A positive integer to return the first N elements
     * - A negative integer to return the last N elements
     * - A tuple of two integers to skip the first N elements and return the next M elements
     */
    $slice: number | [number, number];
}

/* Excluded from this release type: PropagationState */

export declare abstract class PureHeadersProvider<Tag extends HeadersProviderVariants = any> extends HeadersProvider<Tag> {
    abstract getHeaders(ctx: GetHeadersCtx): Record<string, string | undefined>;
}

/* Excluded from this release type: QueryState */

/**
 * @public
 */
export declare type RawCodec<SerCtx = any, DesCtx = any> = {
    tag: 'forName';
    name: string;
    opts: NominalCodecOpts<SerCtx, DesCtx>;
} | {
    tag: 'forPath';
    path: readonly PathSegment[];
    opts: NominalCodecOpts<SerCtx, DesCtx>;
} | {
    tag: 'forType';
    type: string;
    opts: TypeCodecOpts<SerCtx, DesCtx>;
} | {
    tag: 'custom';
    opts: CustomCodecOpts<SerCtx, DesCtx>;
};

/**
 * @beta
 */
export declare type RawCollCodecs = readonly RawCodec<CollectionSerCtx, CollectionDesCtx>[] & {
    phantom?: 'This codec is only valid for collections';
};

/**
 * The response format of a 2XX-status Data API call
 *
 * @public
 */
export declare interface RawDataAPIResponse {
    /**
     * A response data holding documents that were returned as the result of a command.
     */
    readonly status?: Record<string, any>;
    /**
     * Status objects, generally describe the side effects of commands, such as the number of updated or inserted documents.
     */
    readonly errors?: DataAPIErrorDescriptor[];
    /**
     * Array of objects or null (Error)
     */
    readonly data?: Record<string, any>;
    /**
     * Array of objects or null (Error)
     */
    readonly warnings?: DataAPIWarningDescriptor[];
}

/**
 * @beta
 */
export declare type RawTableCodecs = readonly RawCodec<TableSerCtx, TableDesCtx>[] & {
    phantom?: 'This codec is only valid for tables';
};

/**
 * Utility type to represent a readonly non-empty array.
 *
 * @public
 */
export declare type ReadonlyNonEmpty<T> = readonly [T, ...T[]];

/* Excluded from this release type: Ref */

/**
 * ##### Overview
 *
 * Represents a single document returned from some generic `findAndRerank` operation on the Data API.
 * This is the individual item type emitted by a {@link FindAndRerankCursor}.
 *
 * Each result contains:
 * - the original document returned by the Data API (after projection), and
 * - an optional set of scores yielded during reranking (if `includeScores` was set on the cursor).
 *
 * ---
 *
 * ##### Reranking
 *
 * When hybrid search is performed using the `$hybrid` operator, the Data API returns candidate documents
 * based on vector and/or lexical similarity, before reranking them using a reranking model.
 *
 * If `includeScores` was enabled when the cursor was created, then the scores from each stage
 * of the ranking pipeline will be included in the `scores` object for every result.
 *
 * ---
 *
 * ##### Example
 *
 * ```ts
 * const cursor = collection.findAndRerank({}, {
 *   sort: { $hybrid: 'What is a tree?' },
 *   includeScores: true,
 * });
 *
 * for await (const result of cursor) {
 *   console.log(result.document); // The document
 *   console.log(result.scores);   // { $rerank: .12, $vector: .78, ... }
 * }
 * ```
 *
 * @see {@link FindAndRerankCursor}
 *
 * @public
 */
export declare class RerankedResult<TRaw> {
    /**
     * The document returned from the `findAndRerank` query.
     *
     * If a projection was applied, this will reflect only the projected fields.
     */
    readonly document: TRaw;
    /**
     * The set of scores used during the hybrid search and reranking process.
     *
     * For collections, keys may include:
     * - `$vector`: the score from the vector similarity search
     * - `$lexical`: the score from the lexical similarity search
     * - `$reranker`: the score from the reranking step
     *
     * This will be an empty object unless `includeScores: true` was set on the cursor.
     */
    readonly scores: Record<string, number>;
    constructor(document: TRaw, scores: Record<string, number>);
}

/**
 * ##### Overview
 *
 * The most basic reranking header provider, used for the vast majority of providers.
 *
 * Generally, anywhere this can be used in the public `astra-db-ts` interfaces, you may also pass in a plain
 * string or null/undefined, which is transformed into an {@link RerankingAPIKeyHeaderProvider} under the hood.
 *
 * @example
 * ```typescript
 * const provider = new RerankingAPIKeyHeaderProvider('api-key');
 * const collections = await db.collections('my_coll', { rerankingApiKey: provider });
 *
 * // or just
 * const collections = await db.collections('my_coll', { rerankingApiKey: 'api-key' });
 * ```
 *
 * @see RerankingHeadersProvider
 *
 * @public
 */
export declare class RerankingAPIKeyHeaderProvider extends StaticHeadersProvider<'reranking'> {
    /**
     * Constructs an instead of the {@link RerankingAPIKeyHeaderProvider}.
     *
     * @param apiKey - The api-key/token to regurgitate in `getToken`
     */
    constructor(apiKey: string | nullish);
    /* Excluded from this release type: parse */
}

export declare type RerankingHeadersProvider = HeadersProvider<'reranking'>;

/**
 * @public
 */
export declare interface RerankServiceOptions {
    provider: string;
    modelName: string;
    authentication?: Record<string, unknown>;
    parameters?: Record<string, unknown>;
}

/**
 * The default admin options as can be specified in the {@link DataAPIClientOptions}.
 *
 * See {@link AdminOptions} for more information on the available options.
 *
 * @public
 */
export declare type RootAdminOptions = Omit<AdminOptions, 'logging' | 'timeoutDefaults'>;

/**
 * The default db options as can be specified in the {@link DataAPIClientOptions}.
 *
 * See {@link DbOptions} for more information on the available options.
 *
 * @public
 */
export declare type RootDbOptions = Omit<DbOptions, 'logging' | 'timeoutDefaults'>;

/**
 * Options for executing some arbitrary command.
 *
 * @see Db.command
 *
 * @public
 */
export declare interface RunCommandOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * The collection to run the command on.
     *
     * If not provided, the command will run on the keyspace, or directly on the database if `keyspace` is `null`.
     *
     * Only one of this or {@link RunCommandOptions.table} should be provided.
     */
    collection?: string;
    /**
     * The collection to run the command on.
     *
     * If not provided, the command will run on the keyspace, or directly on the database if `keyspace` is `null`.
     *
     * Only one of this or {@link RunCommandOptions.table} should be provided.
     */
    table?: string;
    /**
     * Overrides the keyspace to run the command on.
     *
     * If undefined/not provided, the command will run on the db's default working keyspace.
     *
     * **This may be set to `null` to run the command directly on the database.**
     */
    keyspace?: string | null;
    /**
     * A small string to add to the log message for this command (only if you're printing to `stdout`/`stderr` using {@link LoggingConfig}).
     */
    extraLogInfo?: Record<string, unknown>;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - The `namespace` terminology has been removed, and replaced with `keyspace` throughout the client.
     */
    namespace?: 'ERROR: The `namespace` terminology has been removed, and replaced with `keyspace` throughout the client';
}

/* Excluded from this release type: SerDes */

/**
 * @public
 */
export declare type SerDesFn<Ctx> = (value: any, ctx: Ctx) => SerDesFnRet | 'Return ctx.done(val?), ctx.recurse(val?), or ctx.continue(val?)';

/**
 * @public
 */
export declare type SerDesFnRet = readonly [0 | 1 | 2 | 3, any?];

/**
 * @public
 */
export declare type SerDesGuard<Ctx> = (value: any, ctx: Ctx) => boolean;

/**
 * @public
 */
export declare const SerDesTarget: {
    readonly Sort: number;
    readonly Record: number;
    readonly Filter: number;
    readonly Update: number;
    readonly Projection: number;
    readonly InsertedId: number;
};

/**
 * @public
 */
export declare type SerDesTarget = typeof SerDesTarget[keyof typeof SerDesTarget];

/* Excluded from this release type: SerializedFilter */

/**
 * @public
 */
export declare interface Serializers<SerCtx> {
    forName: Record<string, SerDesFn<SerCtx>[]>;
    forPath: Record<number, {
        path: readonly PathSegment[];
        fns: SerDesFn<SerCtx>[];
    }[]>;
    forClass: {
        class: SomeConstructor;
        fns: SerDesFn<SerCtx>[];
    }[];
    forGuard: {
        guard: SerDesGuard<SerCtx>;
        fn: SerDesFn<SerCtx>;
    }[];
}

/**
 * Represents some, _any_, constructor (e.g. `Error`, `Map`, or `MyCustomClass`).
 *
 * @public
 */
export declare type SomeConstructor = abstract new (...args: any[]) => any;

/**
 * Represents *some document*. It's not a base type, but rather more of a
 * bottom type which can represent any legal document, to give more dynamic
 * typing flexibility at the cost of enhanced typechecking/autocomplete.
 *
 * {@link Collection}s will default to this if no specific type is provided.
 *
 * @public
 */
export declare type SomeDoc = Record<string, any>;

/**
 * ##### Overview
 *
 * Represents all possible types for a document ID, including any JSON scalar types, `Date`, `UUID`, and `ObjectId`.
 *
 * > **⚠️Warning:** The `_id` *can* be set to null `null`.
 * >
 * > Setting `_id: null` doesn't mean "auto-generate an ID" like it may in some other databases; it quite literally means "set the id to be `null`".
 *
 * It's heavily recommended to properly type this in your Schema, so you know what to expect for your `_id` field.
 *
 * > **💡Tip:** You may mitigate this concern on an untyped collections by using a type such as—substituting `string` for your desired id type—`{ _id: string } & SomeDoc`, which would allow the collection to remain untyped while still statically enforcing the `_id` type.
 *
 * @example
 * ```ts
 * interface User {
 *   _id: string,
 *   name: string,
 * }
 *
 * const result = await db.collection<User>('users').insertOne({
 *   name: 'John',
 * });
 *
 * console.log(result.insertedId.toLowerCase()); // no issue; _id is string
 * ```
 *
 * @example
 * ```ts
 * const result = await db.collection<{ _id: string } & SomeDoc>('users').insertOne({
 *   name: 'John',
 * });
 *
 * console.log(result.insertedId.toLowerCase()); // also okay; _id is string
 * ```
 *
 * @example
 * ```ts
 * const result = await db.collection('users').insertOne({
 *   name: 'John',
 * });
 *
 * console.log(result.insertedId.toLowerCase()); // type error; _id may not be string
 * ```
 *
 * ---
 *
 * ##### The default ID
 *
 * By default, if no `_id` field is provided in an inserted document, it will be automatically generated and set as a string UUID (not an actual {@link UUID} type).
 *
 * You can modify this behavior by changing the {@link CollectionDefinition.defaultId} type when creating the collection; this allows it to generate a {@link UUID} or {@link ObjectId} instead of a string UUID.
 *
 * See {@link CollectionDefaultIdOptions.type} for the exact types available.
 *
 * @example
 * ```ts
 * import { UUID } from '@datastax/astra-db-ts';
 *
 * const collection = db.collection('users', {
 *   defaultId: { type: 'uuid' },
 * });
 *
 * const result = await collection.insertOne({
 *   name: 'John',
 * });
 *
 * console.log(result.insertedId); // UUID('123e4567-e89b-12d3-a456-426614174000')
 * ```
 *
 * ---
 *
 * ##### Expanding {@link SomeId}
 *
 * In case you need to expand the enumeration of valid types for `_id`, you can do so by expanding the {@link SomeIdTypes} interface via declaration merging.
 *
 * > **⚠️Warning:** This is an advanced feature, and should only be used if you really need to use a type for the `_id` field which _isn't_ present in {@link SomeId} for whatever reason.
 *
 * See {@link SomeIdTypes} for more information.
 *
 * @public
 */
export declare type SomeId = SomeIdTypes[keyof SomeIdTypes];

/**
 * ##### Overview
 *
 * An interface which allows you to extend the types of {@link SomeId} to include your own custom types via declaration merging.
 *
 * > **⚠️Warning:** This is an advanced feature, and should only be used if you really need to use a type for the `_id` field which _isn't_ present in {@link SomeId} for whatever reason.
 *
 * To use this, you may merge the `SomeIdTypes` interface into your own project to specify additional allowed types for document IDs.
 * - This is especially useful if your system uses custom scalar representations (e.g. branded types or custom datatypes) that are not part of the default set.
 *
 * The field may be called anything except for `baseTypes`, as that is reserved for the default types.
 *
 * > **✏️Note:** This is a global declaration merging, so you should only do this once in your project.
 *
 * ---
 *
 * ##### Examples
 *
 * In this example after declaration merging, the {@link SomeId} will now also accept `{ $uuid: string }` and `BigNumber` as valid values for `_id`.
 *
 * @example
 * ```ts
 * import { BigNumber, SomeId } from '@datastax/astra-db-ts';
 *
 * declare module '@datastax/astra-db-ts' {
 *   interface SomeIdTypes {
 *     myTypes: { $uuid: string } | BigNumber,
 *   }
 * }
 *
 * const id1: SomeId = { $uuid: '123e4567-e89b-12d3-a456-426614174000' }; // OK
 * const id2: SomeId = BigNumber(123456789); // OK
 * const id3: SomeId = { $car: 123 }; // Type Error
 * ```
 *
 * In this example, {@link SomeId} will be set to `any`.
 *
 * @example
 * ```ts
 * import { SomeId } from '@datastax/astra-db-ts';
 *
 * declare module '@datastax/astra-db-ts' {
 *   interface SomeIdTypes {
 *     myTypes: any,
 *   }
 * }
 *
 * const id1: SomeId = { $uuid: '123e4567-e89b-12d3-a456-426614174000' }; // OK
 * const id2: SomeId = BigNumber(123456789); // OK
 * const id3: SomeId = { $car: 123 }; // OK
 * ```
 *
 * @see SomeId
 *
 * @public
 */
export declare interface SomeIdTypes {
    baseTypes: string | number | bigint | boolean | Date | UUID | ObjectId | null;
}

/**
 * ##### Overview
 *
 * Represents *some primary key* in a table. This is a generic type that represents some (any) table primary key with any number & types
 * of columns. All it asks for is that the primary key be an object with string keys and any values.
 *
 * Keep in mind the logical constraints, however:
 * - This should be a subset of the table's schema
 * - Primary key values must be only scalar types
 *
 * > **✏️Note:** There is no distinction between partition and clustering keys in this type.
 *
 * ---
 *
 * ##### Constructing this type
 *
 * Often, you may want to construct this type using the {@link Pick} utility type, to select only the fields of the schema which are in the primary key.
 *
 * @example
 * ```ts
 * interface MyTableSchema {
 *   partitionKey: string;
 *   clusteringKey: number;
 *   otherField: Map<string, string>;
 * }
 *
 * type MyTablePrimaryKey = Pick<MyTableSchema, 'partitionKey' | 'clusteringKey'>;
 *
 * const table = db.table<MyTableSchema, MyTablePrimaryKey>('my_table');
 * ```
 *
 * However, if you are constructing a table with {@link Db.createTable}, you may use the {@link InferTablePrimaryKey} utility type to infer the TS-equivalent type of the primary key from the {@link CreateTableDefinition}.
 *
 * @example
 * ```ts
 * const MyTableSchema = Table.schema({
 *   columns: {
 *     partitionKey: 'text',
 *     clusteringKey: 'int',
 *     otherField: 'map<text, text>',
 *   },
 *   primaryKey: {
 *     partitionBy: ['partitionKey'],
 *     partitionSort: { clusteringKey: 1 },
 *   },
 * });
 *
 * type MyTableSchema = typeof MyTableSchema;
 * type MyTablePrimaryKey = InferTablePrimaryKey<typeof MyTableSchema>;
 *
 * const table = db.createTable<MyTableSchema, MyTablePrimaryKey>('my_table', {
 *   definition: MyTableSchema,
 * });
 * ```
 *
 * ##### Using this type
 *
 * This type is used as the second type parameter of the {@link Table} class.
 *
 * If this is not provided, then the table's primary key type will default to `Partial<Schema>` where `Schema` is the schema of the table.
 *
 * @see InferTablePrimaryKey
 * @see Db.createTable
 * @see SomeRow
 * @see Table
 */
export declare type SomePKey = Record<string, any>;

/**
 * ##### Overview
 *
 * Represents *some row* in a table. This is a generic type that represents some (any) table row with any number & types
 * of columns. All it asks for is that the row be an object with string keys and any values.
 *
 * Equivalent to {@link SomeDoc} for collections.
 *
 * This can/will often be used as the "default", or "untyped" generic type when no specific/static type is provided/desired.
 * (e.g. `class Table<Schema extends SomeRow = SomeRow> { ... }`)
 *
 * ##### Disclaimer
 *
 * **Be careful when using this, as it is untyped and can lead to runtime errors if the row's structure is not as expected.**
 *
 * It can be an effective footgun (especially for tables, which are inherently typed), so it is recommended to use a
 * more specific type when possible.
 *
 * That is not to say it does not have its uses, from flexibility, to prototyping, to convenience, to working with
 * dynamic data, etc. Just be aware of the risks, especially for tables.
 *
 * @example
 * ```ts
 * const table = db.table<SomeRow>('my_table');
 *
 * await table.insertOne({
 *   'lets.you$insert': function () { return 'whatever you want' },
 * });
 * ```
 *
 * @see Table
 * @see SomeDoc
 * @see SomeTableKey
 *
 * @public
 */
export declare type SomeRow = Record<string, any>;

/**
 * Specifies the sort criteria for selecting documents.
 *
 * Can use `1`/`-1` for ascending/descending, or `$vector` for sorting by vector distance.
 *
 * See {@link SortDirection} for all possible sort values.
 *
 * **NB. The order of the fields in the sort option is significant—fields are sorted in the order they are listed.**
 *
 * @example
 * ```typescript
 * // Sort by name in ascending order, then by age in descending order
 * const sort1: Sort = {
 *   name: 1,
 *   age: -1,
 * }
 *
 * // Sort by vector distance
 * const sort2: Sort = {
 *   $vector: [0.23, 0.38, 0.27, 0.91, 0.21],
 * }
 * ```
 *
 * @see SortDirection
 *
 * @public
 */
export declare type Sort = Record<string, SortDirection | string | number[] | DataAPIVector>;

/**
 * Allowed types to specify an ascending or descending sort.
 *
 * @public
 */
export declare type SortDirection = 1 | -1;

export declare class StaticHeadersProvider<Tag extends HeadersProviderVariants = any> extends PureHeadersProvider<Tag> {    constructor(headers: Record<string, string | undefined>);
    getHeaders(_: GetHeadersCtx): Record<string, string | undefined>;
}

/**
 * The most basic token provider, which simply returns the token it was instantiated with.
 *
 * Generally, anywhere this can be used in the public `astra-db-ts` interfaces, you may also pass in a plain
 * string or null/undefined, which is transformed into a {@link StaticTokenProvider} under the hood.
 *
 * @example
 * ```typescript
 * const provider = new StaticTokenProvider('token');
 * const client = new DataAPIClient(provider);
 *
 * // or just
 *
 * const client = new DataAPIClient('token');
 * ```
 *
 * @see TokenProvider
 *
 * @public
 */
export declare class StaticTokenProvider extends TokenProvider {    /**
     * Constructs an instead of the {@link StaticTokenProvider}.
     *
     * @param token - The token to regurgitate in `getTokenAsString`
     */
    constructor(token: string);
    /**
     * Returns the string the token provider was instantiated with.
     *
     * @returns the string the token provider was instantiated with.
     */
    getToken(): string;
    /* Excluded from this release type: toHeadersProvider */
}

/* Excluded from this release type: StrBasedTypes */

/**
 * ##### Overview
 *
 * The strict column definition is the more structured way to define a column, and follows the following example form:
 *
 * ```ts
 * columns: {
 *   uuidCol: { type: 'uuid' },
 *   mapCol: { type: 'map', keyType: 'text', valueType: 'int' },
 *   listCol: { type: 'list', valueType: 'text' },
 *   vectorCol: { type: 'vector', dimension: 3 },
 * }
 * ```
 *
 * In this form, the key is the column name, and the value is an object with a `type` field that specifies the type of the column.
 *
 * The object may also contain additional fields that are specific to the type of the column:
 * - For `map`, you _must_ specify the `keyType` and `valueType` fields.
 *   - The `keyType` must, for the time being, be either `'text'` or `'ascii'`.
 *   - The `valueType` must be a scalar type.
 * - For `list`s and `set`s, you _must_ specify the `valueType` field.
 *   - The `valueType` must be a scalar type.
 * - For `vector`s, you _must_ specify the `dimension` field.
 *   - You may optionally provide a `service` field to enable vectorize.
 *   - Note that you still need to create a vector index on the column to actually use vector search.
 *
 * ##### The "loose" shorthand syntax
 *
 * If you're simply defining a scalar column, you can use the shorthand "loose" syntax instead, which is equivalent to the above for `uuidCol`:
 *
 * ```ts
 * columns: {
 *   uuidCol: 'uuid',
 * }
 * ```
 *
 * @public
 */
export declare type StrictCreateTableColumnDefinition = TableScalarColumnDefinition | TableMapColumnDefinition | TableListColumnDefinition | TableSetColumnDefinition | TableVectorColumnDefinition;

/* Excluded from this release type: StringBasedHeadersProviderOptsHandler */

/**
 * ##### Overview
 *
 * Represents the interface to a table in a Data-API-enabled database.
 *
 * > **⚠️Warning**: This isn't directly instantiated, but spawned via {@link Db.createTable} or {@link Db.table}.
 *
 * @example
 * ```ts
 * const table = db.table<Type?>('my_table');
 * ```
 *
 * ---
 *
 * ##### Typing the table
 *
 * > **🚨Important:** For most intents & purposes, you can ignore the (generally negligible) difference between _WSchema_ and _RSchema_, and treat {@link Table} as if it were typed as `Table<Schema, PKey>`.
 *
 * A `Table` is typed as `Table<WSchema, PKey, RSchema>`, where:
 *  - `WSchema` is the type of the row as it's written to the table (the "write" schema)
 *    - This includes inserts, filters, sorts, etc.
 *  - `PKey` (optional) is the type of the primary key of the table as it's returned
 *  - `RSchema` is the type of the row as it's read from the table (the "read" schema)
 *    - This includes finds
 *    - Unless custom ser/des is used, it is nearly exactly the same as `WSchema`
 *    - This defaults to `FoundRow<WSchema>` (see {@link FoundRow})
 *
 * ---
 *
 * ##### Typing the primary key
 *
 * The primary key of the table should be provided as a second type parameter to `Table`.
 *
 * This is a special type that is used to reconstruct the TS type of the primary key in insert operations. It should be an object with the same keys as the primary key columns, and the same types as the schema.
 *
 * Note that there is no distinction between partition and clustering keys in this type.
 *
 * @example
 * ```ts
 * interface User {
 *   id: string,   // Partition key
 *   dob: DataAPIDate, // Clustering (partition sort) key
 *   friends: Map<string, UUID>,
 * }
 *
 * type UserPK = Pick<User, 'id' | 'dob'>;
 *
 * // res.insertedId is of type { id: string }
 * const res = await db.table<User, UserPK>('users').insertOne({
 *   id: '123',
 *   dob: date(), // or new DataAPIDate(new Date())
 *   friends: new Map([['Alice', uuid.v4()]]), // or UUID.v4()
 * });
 * ```
 *
 * ---
 *
 * ##### `db.createTable` type inference
 *
 * > **💡Tip:** When creating a table through {@link Db.createTable}, you can automagically infer the TS-equivalent type of the table from the {@link CreateTableDefinition} via the {@link InferTableSchema} & {@link InferTablePrimaryKey} utility types.
 *
 * @example
 * ```ts
 * const UserSchema = Table.schema({
 *   columns: {
 *     id: 'text',
 *     dob: 'date',
 *     friends: { type: 'map', keyType: 'text', valueType: 'uuid' },
 *   },
 *   primaryKey: {
 *     partitionBy: ['id'],
 *     partitionSort: { dob: -1 }
 *   },
 * });
 *
 * // equivalent to:
 * // type User = {
 * //   id: string,
 * //   dob: DataAPIDate,
 * //   friends?: Map<string, UUID>, // Optional since it's not in the primary key
 * // }
 * type User = InferTableSchema<typeof UserSchema>;
 *
 * // equivalent to:
 * // type UserPK = Pick<User, 'id' | 'dob'>;
 * type UserPK = InferTablePrimaryKey<typeof mkTable>;
 *
 * async function main() {
 *   const table = await db.createTable<User, UserPK>('users', {
 *     definition: UserSchema,
 *   });
 * }
 * ```
 *
 * ---
 *
 * ##### Datatypes
 *
 * Certain datatypes may be represented as TypeScript classes (some native, some provided by the client).
 *
 * For example:
 *  - `'map<k, v>'` is represented by a native JS {@link Map}
 *  - `'vector'` is represented by an `astra-db-ts` provided {@link DataAPIVector}
 *  - `'date'` is represented by an `astra-db-ts` provided {@link DataAPIDate}
 *
 * You may also provide your own datatypes by providing some custom serialization logic as well (see later section).
 *
 * @example
 * ```ts
 * interface User {
 *   id: string,
 *   friends: Map<string, UUID>, // UUID is also `astra-db-ts` provided
 *   vector: DataAPIVector,
 * }
 *
 * await db.table<User>('users').insertOne({
 *   id: '123',
 *   friends: new Map([['Alice', uuid.v4()]]), // or UUID.v4()
 *   vector: vector([1, 2, 3]), // or new DataAPIVector([...])
 * });
 * ```
 *
 * The full list of relevant datatypes (for tables) includes: {@link DataAPIBlob}, {@link DataAPIDate}, {@link DataAPITime}, {@link DataAPIVector}, {@link DataAPIInet}, {@link DataAPIDuration}, {@link UUID}, {@link Map}, {@link Set}, and {@link BigNumber}.
 *
 * ---
 *
 * ##### Big numbers disclaimer
 *
 * When `varint`s or `decimal`s are present in the schema (when you're serializing `bigint`s and {@link BigNumber}s), it will automatically enable usage of a bignumber-friendly JSON library which is capable of serializing/deserializing these numbers without loss of precision, but is much slower than the native JSON library (but, realistically, the difference is likely negligible).
 *
 * ---
 *
 * ##### Custom datatypes
 *
 * You can plug in your own custom datatypes, as well as enable many other features by providing some custom serialization/deserialization logic through the `serdes` option in {@link TableOptions}, {@link DbOptions}, and/or {@link DataAPIClientOptions.dbOptions}.
 *
 * Note however that this is currently not entirely stable, and should be used with caution.
 *
 * ---
 *
 * ##### 🚨Disclaimers
 *
 * *It is on the user to ensure that the TS type of the `Table` corresponds with the actual CQL table schema, in its TS-deserialized form. Incorrect or dynamic tying could lead to surprising behaviors and easily-preventable errors.*
 *
 * See {@link Db.createTable}, {@link Db.table}, and {@link InferTableSchema} for much more information about typing.
 *
 * @see SomeRow
 * @see Db.createTable
 * @see Db.table
 * @see InferTableSchema
 * @see InferTablePrimaryKey
 * @see TableSerDesConfig
 * @see TableOptions
 *
 * @public
 */
export declare class Table<WSchema extends SomeRow, PKey extends SomePKey = Partial<FoundRow<WSchema>>, RSchema extends SomeRow = FoundRow<WSchema>> extends HierarchicalLogger<CommandEventMap> {    /**
     * ##### Overview
     *
     * The user-provided, case-sensitive. name of the table
     *
     * This is unique among all tables and collections in its keyspace, but not necessarily unique across the entire database.
     *
     * It is up to the user to ensure that this table really exists.
     */
    readonly name: string;
    /**
     * ##### Overview
     *
     * The keyspace where the table resides in.
     *
     * It is up to the user to ensure that this keyspace really exists, and that this table is in it.
     */
    readonly keyspace: string;
    /**
     * ##### Overview
     *
     * Strongly types the creation of a `const` new {@link CreateTableDefinition} schema.
     *
     * Unlike writing the table definition inline in `createTable` and using `InferTableSchema` on the `Table` itself, this method:
     *   - Allows you to define your schemas separately, outside an async context
     *   - Allows you to override the type of specific datatypes
     *   - Provides type errors if any primary keys don't use a valid column
     *
     * Similar to using `const Schema = { ... } as const [satisfies CreateTableDefinition<any>]`.
     *
     * @example
     * ```ts
     * // Define the table schema
     * const UserSchema = Table.schema({
     *   columns: {
     *     name: 'text',
     *     dob: {
     *       type: 'timestamp',
     *     },
     *     friends: {
     *       type: 'set',
     *       valueType: 'text',
     *     },
     *   },
     *   primaryKey: {
     *     partitionBy: ['name', 'height'], // type error: 'height' is not a valid column
     *     partitionSort: { dob: 1 },
     *   },
     * });
     *
     * // Type inference is as simple as that
     * type User = InferTableSchema<typeof UserSchema>;
     *
     * // And now `User` can be used wherever.
     * const main = async () => {
     *   const table = await db.createTable('users', { definition: UserSchema });
     *   const found: User | null = await table.findOne({});
     * };
     * ```
     *
     * @param schema - The schema to strongly type.
     *
     * @returns The exact same object passed in. This method simply exists for the strong typing.
     */
    static schema<const Def extends CreateTableDefinition<Def>>(schema: Def): Def;
    /* Excluded from this release type: __constructor */
    /**
     * ##### Overview
     *
     * Atomically upserts a single row into the table.
     *
     * See {@link TableInsertOneOptions} and {@link TableInsertOneResult} as well for more information.
     *
     * @example
     * ```ts
     * import { UUID, vector, ... } from '@datastax/astra-db-ts';
     *
     * // Insert a row with a specific ID
     * await table.insertOne({ id: 'text-id', name: 'John Doe' });
     * await table.insertOne({ id: UUID.v7(), name: 'Dane Joe' }); // or uuid.v7()
     *
     * // Insert a row with a vector
     * // DataAPIVector class enables faster ser/des
     * const vec = vector([.12, .52, .32]); // or new DataAPIVector([.12, .52, .32])
     * await table.insertOne({ id: 1, name: 'Jane Doe', vector: vec });
     *
     * // or if vectorize (auto-embedding-generation) is enabled for the column
     * await table.insertOne({ id: 1, name: 'Jane Doe', vector: "Hey there!" });
     * ```
     *
     * ---
     *
     * ##### Upsert behavior
     *
     * When inserting a row with a primary key that already exists, the new row will be merged with the existing row, with the new values taking precedence.
     *
     * If you want to delete old values, you must explicitly set them to `null` (not `undefined`).
     *
     * @example
     * ```ts
     * await table.insertOne({ id: '123', col1: 'I exist' });
     * await table.findOne({ id: '123' }); // { id: '123', col1: 'I exist' }
     *
     * await table.insertOne({ id: '123', col1: 'I am new' });
     * await table.findOne({ id: '123' }); // { id: '123', col1: 'I am new' }
     *
     * await table.insertOne({ id: '123', col2: 'me2' });
     * await table.findOne({ id: '123' }); // { id: '123', col1: 'I am new', col2: 'me2' }
     *
     * await table.insertOne({ id: '123', col1: null });
     * await table.findOne({ id: '123' }); // { id: '123', col2: 'me2' }
     * ```
     *
     * ---
     *
     * ##### The primary key
     *
     * The type of the primary key of the table is inferred from the second `PKey` type-param of the table.
     *
     * If not present, it defaults to `Partial<RSchema>` to keep the result type consistent.
     *
     * @example
     * ```ts
     * interface User {
     *   id: string,
     *   name: string,
     *   dob?: DataAPIDate,
     * }
     *
     * type UserPKey = Pick<User, 'id'>;
     *
     * const table = db.table<User, UserPKey>('table');
     *
     * // res.insertedId is of type { id: string }
     * const res = await table.insertOne({ id: '123', name: 'Alice' });
     * console.log(res.insertedId.id); // '123'
     * ```
     *
     * @param row - The row to insert.
     * @param options - The options for this operation.
     *
     * @returns The primary key of the inserted row.
     *
     * @see TableInsertOneOptions
     * @see TableInsertOneResult
     */
    insertOne(row: WSchema, options?: TableInsertOneOptions): Promise<TableInsertOneResult<PKey>>;
    /**
     * ##### Overview
     *
     * Upserts many rows into the table.
     *
     * See {@link TableInsertManyOptions} and {@link TableInsertManyResult} as well for more information.
     *
     * @example
     * ```ts
     * import { uuid } from '@datastax/astra-db-ts';
     *
     * await table.insertMany([
     *   { id: uuid.v4(), name: 'John Doe' }, // or UUID.v4()
     *   { id: uuid.v7(), name: 'Jane Doe' },
     * ]);
     * ```
     *
     * ---
     *
     * ##### Chunking
     *
     * > **🚨Important:** This function inserts rows in chunks to avoid exceeding insertion limits, which means it may make multiple requests to the server. As a result, this operation is **not necessarily atomic.**
     * >
     * > If the dataset is large or the operation is ordered, it may take a relatively significant amount of time. During this time, rows inserted by other concurrent processes may be written to the database, potentially causing duplicate id conflicts. In such cases, it's not guaranteed which write will succeed.
     *
     * By default, it inserts rows in chunks of 50 at a time. You can fine-tune the parameter through the `chunkSize` option. Note that increasing chunk size won't always increase performance. Instead, increasing concurrency may help.
     *
     * You can set the `concurrency` option to control how many network requests are made in parallel on unordered insertions. Defaults to `8`.
     *
     * @example
     * ```ts
     * const rows = Array.from({ length: 100 }, (_, i) => ({ id: i }));
     * await table.insertMany(rows, { concurrency: 16 });
     * ```
     *
     * ---
     *
     * ##### Upsert behavior
     *
     * > **🚨Important:** When inserting a row with a primary key that already exists, the new row will be _merged_ with the existing row, with the new values taking precedence.
     * >
     * > If you want to delete old values, you must explicitly set them to `null` (not `undefined`).
     *
     * @example
     * ```ts
     * // Since insertion is ordered, the last unique value for each
     * // primary key will be the one that remains in the table.
     * await table.insertMany([
     *   { id: '123', col1: 'I exist' },
     *   { id: '123', col1: `I'm new` },
     *   { id: '123', col2: 'me2' },
     * ], { ordered: true });
     *
     * await table.findOne({ id: '123' }); // { id: '123', col1: 'I'm new', col2: 'me2' }
     *
     * // Since insertion is unordered, it is not entirely guaranteed
     * // which value will remain in the table for each primary key,
     * // as concurrent insertions may occur.
     * await table.insertMany([
     *   { id: '123', col1: null },
     *   { id: '123', col1: 'hi' },
     * ]);
     *
     * // coll1 may technically be either 'hi' or null
     * await table.findOne({ id: '123' }); // { id: '123', col1: ? }
     * ```
     *
     * ---
     *
     * ##### Ordered insertions
     *
     * You may set the `ordered` option to `true` to stop the operation after the first error; otherwise rows may be parallelized and processed in arbitrary order, improving, perhaps vastly, performance.
     *
     * Setting the `ordered` operation disables any parallelization so insertions truly are stopped after the very first error.
     *
     * Setting `ordered` also guarantees the order of the aforementioned upsert behavior.
     *
     * ---
     *
     * ##### The primary key
     *
     * The type of the primary key of the table is inferred from the second `PKey` type-param of the table.
     *
     * If not present, it defaults to `Partial<RSchema>` to keep the result type consistent.
     *
     * @example
     * ```ts
     * interface User {
     *   id: string,
     *   name: string,
     *   dob?: DataAPIDate,
     * }
     *
     * type UserPKey = Pick<User, 'id'>;
     *
     * const table = db.table<User, UserPKey>('table');
     *
     * // res.insertedIds is of type { id: string }[]
     * const res = await table.insertMany([
     *   { id: '123', thing: 'Sunrise' },
     *   { id: '456', thing: 'Miso soup' },
     * ]);
     * console.log(res.insertedIds[0].id); // '123'
     * ```
     *
     * ---
     *
     * ##### `TableInsertManyError`
     *
     * If some rows can't be inserted, (e.g. they have the wrong data type for a column or lack the primary key), the Data API validation check will fail for those entire specific requests containing the faulty rows.
     *
     * Depending on concurrency & the `ordered` parameter, some rows may still have been inserted.
     *
     * In such cases, the operation will throw a {@link TableInsertManyError} containing the partial result.
     *
     * If a thrown exception is not due to an insertion error, e.g. a `5xx` error or network error, the operation will throw the underlying error.
     *
     * In case of an unordered request, if the error was a simple insertion error, the {@link TableInsertManyError} will be thrown after every row has been attempted to be inserted. If it was a `5xx` or similar, the error will be thrown immediately.
     *
     * @param rows - The rows to insert.
     * @param options - The options for this operation.
     *
     * @returns The primary keys of the inserted rows (and the count)
     *
     * @throws TableInsertManyError - If the operation fails.
     *
     * @see TableInsertManyOptions
     * @see TableInsertManyResult
     */
    insertMany(rows: readonly WSchema[], options?: TableInsertManyOptions): Promise<TableInsertManyResult<PKey>>;
    /**
     * ##### Overview
     *
     * Updates a single row in the table. Under certain conditions, it may insert or delete a row as well.
     *
     * See {@link TableFilter}, {@link TableUpdateFilter}, and {@link TableUpdateOneOptions} as well for more information.
     *
     * @example
     * ```ts
     * await table.insertOne({ key: '123', name: 'Jerry' });
     * await table.updateOne({ key: '123' }, { $set: { name: 'Geraldine' } });
     * ```
     *
     * ---
     *
     * ##### Filtering
     *
     * > **🚨Important:** The filter must contain an **exact primary key** to update a row.
     * >
     * > Attempting to pass an empty filter, filtering by only part of the primary key, or filtering by a non-primary key column will result in an error.
     *
     * ---
     *
     * ##### Upserting
     *
     * If the row doesn't exist, *and you're `$set`-ing at least one row to a non-null value,* an upsert will occur.
     *
     * @example
     * ```ts
     * // No upsert will occur here since only nulls are being set
     * // (this is equivalent to `{ $unset: { name: '' } }`)
     * await table.updateOne({ key: '123' }, { $set: { name: null } });
     *
     * // An upsert will occur here since at least one non-null value is being set
     * await table.updateOne({ key: '123' }, { $set: { name: 'Eleanor', age: null } });
     * ```
     *
     * ---
     *
     * ##### Updating
     *
     * Updates may perform either `$set` or `$unset` operations on the row.
     *
     * > **✏️Note:** `$set`-ing a row to `null` is equivalent to `$unset`-ing it.
     *
     * ---
     *
     * ##### Deleting
     *
     * If a row was **only ever upserted**, and all of its **non-primary fields** are later set to `null` (or unset), **the row will be deleted**.
     *
     * However, if the row was **explicitly inserted at any point**—even if it was originally upserted—it will **not** be deleted in this way.
     *
     * @example
     * ```ts
     * // Upserts row { key: '123', name: 'Michael', age: 3 } into the table
     * await table.updateOne({ key: '123' }, { $set: { name: 'Michael', age: 3 } });
     *
     * // Sets row to { key: '123', name: 'Michael', age: null }
     * // (Would be the same with $unset)
     * await table.updateOne({ key: '123' }, { $set: { age: null } });
     *
     * // Deletes row from the table as all non-primary keys are set to null
     * // (Would be the same with $unset)
     * await table.updateOne({ key: '123' }, { $set: { name: null } });
     * ```
     *
     * @param filter - A filter to select the row to update.
     * @param update - The update to apply to the selected row.
     * @param options - The options for this operation.
     *
     * @returns A promise which resolves once the operation is completed.
     *
     * @see TableFilter
     * @see TableUpdateFilter
     * @see TableUpdateOneOptions
     */
    updateOne(filter: TableFilter<WSchema>, update: TableUpdateFilter<WSchema>, options?: TableUpdateOneOptions): Promise<void>;
    /**
     * ##### Overview
     *
     * Deletes a single row from the table.
     *
     * See {@link TableFilter} and {@link TableDeleteOneOptions} as well for more information.
     *
     * @example
     * ```ts
     * await table.insertOne({ pk: 'abc', ck: 3 });
     * await table.deleteOne({ pk: 'abc', ck: 3 });
     * ```
     *
     * ---
     *
     * ##### Filtering
     *
     * > **🚨Important:** The filter must contain an **exact primary key** to delete a row.
     * >
     * > Attempting to pass an empty filter, filtering by only part of the primary key, or filtering by a non-primary key column will result in an error.
     *
     * @param filter - A filter to select the row to delete.
     * @param options - The options for this operation.
     *
     * @returns A promise which resolves once the operation is completed.
     *
     * @see TableFilter
     * @see TableDeleteOneOptions
     */
    deleteOne(filter: TableFilter<WSchema>, options?: TableDeleteOneOptions): Promise<void>;
    /**
     * ##### Overview
     *
     * Atomically deletes many rows from the table.
     *
     * See {@link TableFilter} and {@link TableDeleteManyOptions} as well for more information.
     *
     * @example
     * ```ts
     * await table.insertMany([
     *   { pk: 'abc', ck: 1, name: 'John' },
     *   { pk: 'abc', ck: 2, name: 'Jane' },
     * ]);
     *
     * await table.deleteMany({ pk: 'abc' });/
     * ```
     *
     * ---
     *
     * ##### Filtering
     *
     * There are different forms of accepted filters:
     * - Providing the full primary key to delete a single row
     * - With some or all of the `partitionSort` columns not provided
     *   - The least significant of them can also use an inequality/range predicate
     * - Using an empty filter to truncate the entire table
     *
     * > **🚨Important:** If an empty filter is passed, **all rows in the tables will table be deleted in a single API call**. Proceed with caution.
     *
     * @param filter - A filter to select the row(s) to delete.
     * @param options - The options for this operation.
     *
     * @returns A promise which resolves once the operation is completed.
     *
     * @see TableFilter
     * @see TableDeleteManyOptions
     */
    deleteMany(filter: TableFilter<WSchema>, options?: TableDeleteManyOptions): Promise<void>;
    /**
     * ##### Overview
     *
     * Find rows in the table, optionally matching the provided filter.
     *
     * See {@link TableFilter}, {@link TableFindOptions}, and {@link FindCursor} as well for more information.
     *
     * @example
     * ```ts
     * const cursor = await table.find({ name: 'John Doe' });
     * const docs = await cursor.toArray();
     * ```
     *
     * ---
     *
     * ##### Projection
     *
     * > **🚨Important:** When projecting, it is _heavily_ recommended to provide an explicit type override representing the projected schema, to prevent any type-mismatches when the schema is strictly provided.
     * >
     * > Otherwise, the rows will be typed as the full `Schema`, which may lead to runtime errors when trying to access properties that are not present in the projected rows.
     *
     * > **💡Tip:** Use the {@link Pick} or {@link Omit} utility types to create a type representing the projected schema.
     *
     * @example
     * ```ts
     * interface User {
     *   id: string,
     *   name: string,
     *   car: { make: string, model: string },
     * }
     *
     * const table = db.table<User>('users');
     *
     * // --- Not providing a type override ---
     *
     * const cursor = await table.find({}, {
     *   projection: { car: 1 },
     * });
     *
     * const next = await cursor.next();
     * console.log(next.car.make); // OK
     * console.log(next.name); // Uh oh! Runtime error, since tsc doesn't complain
     *
     * // --- Explicitly providing the projection type ---
     *
     * const cursor = await table.find<Pick<User, 'car'>>({}, {
     *   projection: { car: 1 },
     * });
     *
     * const next = await cursor.next();
     * console.log(next.car.make); // OK
     * console.log(next.name); // Type error; won't compile
     * ```
     *
     * ---
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the rows. See {@link TableFilter} for much more information.
     *
     * > **⚠️Warning:** If the filter is empty, all rows in the table will be returned (up to any provided or server limit).
     *
     * ---
     *
     * ##### Find by vector search
     *
     * If the table has vector search enabled, you can find the most relevant rows by providing a vector in the sort option.
     *
     * Vector ANN searches cannot return more than a set number of rows, which, at the time of writing, is 1000 items.
     *
     * @example
     * ```ts
     * await table.insertMany([
     *   { name: 'John Doe', vector: [.12, .52, .32] },
     *   { name: 'Jane Doe', vector: [.32, .52, .12] },
     *   { name: 'Dane Joe', vector: [.52, .32, .12] },
     * ]);
     *
     * const cursor = table.find({}, {
     *   sort: { vector: [.12, .52, .32] },
     * });
     *
     * // Returns 'John Doe'
     * console.log(await cursor.next());
     * ```
     *
     * ---
     *
     * ##### Sorting
     *
     * The sort option can be used to sort the rows returned by the cursor. See {@link Sort} for more information.
     *
     * If the sort option is not provided, there is no guarantee as to the order of the rows returned.
     *
     * > **🚨Important:** When providing a non-vector sort, the Data API will return a smaller number of rows (20, at the time of writing), and stop there. The returned rows are the top results across the whole table according to the requested criterion.
     *
     * @example
     * ```ts
     * await table.insertMany([
     *   { name: 'John Doe', age: 1, height: 168 },
     *   { name: 'John Doe', age: 2, height: 42 },
     * ]);
     *
     * const cursor = table.find({}, {
     *   sort: { age: 1, height: -1 },
     * });
     *
     * // Returns 'John Doe' (age 2, height 42), 'John Doe' (age 1, height 168)
     * console.log(await cursor.toArray());
     * ```
     *
     * ---
     *
     * ##### Other options
     *
     * Other available options include `skip`, `limit`, `includeSimilarity`, and `includeSortVector`. See {@link TableFindOptions} and {@link FindCursor} for more information.
     *
     * If you prefer, you may also set these options using a fluent interface on the {@link FindCursor} itself.
     *
     * @example
     * ```ts
     * // cursor :: FindCursor<string>
     * const cursor = table.find({})
     *   .sort({ vector: [.12, .52, .32] })
     *   .projection<{ name: string, age: number }>({ name: 1, age: 1 })
     *   .includeSimilarity(true)
     *   .map(doc => `${doc.name} (${doc.age})`);
     * ```
     *
     * @remarks
     * When not specifying sorting criteria at all (by vector or otherwise),
     * the cursor can scroll through an arbitrary number of rows as
     * the Data API and the client periodically exchange new chunks of rows.
     *
     * --
     *
     * It should be noted that the behavior of the cursor in the case rows
     * have been added/removed after the `find` was started depends on database
     * internals, and it is not guaranteed, nor excluded, that such "real-time"
     * changes in the data would be picked up by the cursor.
     *
     * @param filter - A filter to select the rows to find. If not provided, all rows will be returned.
     * @param options - The options for this operation.
     *
     * @returns a FindCursor which can be iterated over.
     *
     * @see TableFilter
     * @see TableFindOptions
     * @see FindCursor
     */
    find<T extends SomeRow = WithSim<RSchema>, TRaw extends T = T>(filter: TableFilter<WSchema>, options?: TableFindOptions): TableFindCursor<T, TRaw>;
    /**
     * ##### Overview
     *
     * Find a single row in the table, optionally matching the provided filter.
     *
     * See {@link TableFilter} and {@link TableFindOneOptions} as well for more information.
     *
     * @example
     * ```ts
     * const doc = await table.findOne({ name: 'John Doe' });
     * ```
     *
     * ---
     *
     * ##### Projection
     *
     * > **🚨Important:** When projecting, it is _heavily_ recommended to provide an explicit type override representing the projected schema, to prevent any type-mismatches when the schema is strictly provided.
     * >
     * > Otherwise, the rows will be typed as the full `Schema`, which may lead to runtime errors when trying to access properties that are not present in the projected rows.
     *
     * > **💡Tip:** Use the {@link Pick} or {@link Omit} utility types to create a type representing the projected schema.
     *
     * @example
     * ```ts
     * interface User {
     *   id: string,
     *   name: string,
     *   car: { make: string, model: string },
     * }
     *
     * const table = db.table<User>('users');
     *
     *
     * // --- Not providing a type override ---
     *
     * const row = await table.findOne({}, {
     *   projection: { car: 1 },
     * });
     *
     * console.log(row.car.make); // OK
     * console.log(row.name); // Uh oh! Runtime error, since tsc doesn't complain
     *
     * // --- Explicitly providing the projection type ---
     *
     * const row = await table.findOne<Pick<User, 'car'>>({}, {
     *   projection: { car: 1 },
     * });
     *
     * console.log(row.car.make); // OK
     * console.log(row.name); // Type error; won't compile
     * ```
     *
     * ---
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the row. See {@link TableFilter} for much more information.
     *
     * > **⚠️Warning:** If the filter is empty, and no {@link Sort} is present, it's undefined as to which row is selected.
     *
     * ---
     *
     * ##### Find by vector search
     *
     * If the table has vector search enabled, you can find the most relevant row by providing a vector in the sort option.
     *
     * @example
     * ```ts
     * await table.insertMany([
     *   { name: 'John Doe', vector: [.12, .52, .32] },
     *   { name: 'Jane Doe', vector: [.32, .52, .12] },
     *   { name: 'Dane Joe', vector: [.52, .32, .12] },
     * ]);
     *
     * const doc = table.findOne({}, {
     *   sort: { vector: [.12, .52, .32] },
     * });
     *
     * // 'John Doe'
     * console.log(doc.name);
     * ```
     *
     * ---
     *
     * ##### Sorting
     *
     * The sort option can be used to pick the most relevant row. See {@link Sort} for more information.
     *
     * If the sort option is not provided, there is no guarantee as to which of the rows which matches the filter is returned.
     *
     * @example
     * ```ts
     * await table.insertMany([
     *   { name: 'John Doe', age: 1, height: 168 },
     *   { name: 'John Doe', age: 2, height: 42 },
     * ]);
     *
     * const doc = table.findOne({}, {
     *   sort: { age: 1, height: -1 },
     * });
     *
     * // 'John Doe' (age 2, height 42)
     * console.log(doc.name);
     * ```
     *
     * ---
     *
     * ##### Other options
     *
     * Other available options include `includeSimilarity`. See {@link TableFindOneOptions} for more information.
     *
     * If you want to get `skip` or `includeSortVector` as well, use {@link Table.find} with a `limit: 1` instead.
     *
     * @example
     * ```ts
     * const doc = await cursor.findOne({}, {
     *   sort: { vector: [.12, .52, .32] },
     *   includeSimilarity: true,
     * });
     * ```
     *
     * @param filter - A filter to select the rows to find. If not provided, all rows will be returned.
     * @param options - The options for this operation.
     *
     * @returns A row matching the criterion, or `null` if no such row exists.
     *
     * @see TableFilter
     * @see TableFindOneOptions
     */
    findOne<TRaw extends SomeRow = WithSim<RSchema>>(filter: TableFilter<WSchema>, options?: TableFindOneOptions): Promise<TRaw | null>;
    /**
     * ##### Overview
     *
     * Performs one of the six available table-alteration operations:
     * - `add` (adds columns to the table)
     * - `drop` (removes columns from the table)
     * - `addVectorize` (enabled auto-embedding-generation on existing vector columns)
     * - `dropVectorize` (disables vectorize on existing enabled columns)
     * - `addReranking` (enables reranking on the table)
     * - `dropReranking` (disables reranking on the table)
     *
     * See {@link AlterTableOptions} as well for more information.
     *
     * @example
     * ```ts
     * interface User {
     *   id: UUID,
     *   vector: DataAPIVector,
     * }
     * const table = db.table<User>('users');
     *
     * // Add a column to the table
     * type NewUser = User & { name: string };
     *
     * const newTable = await table.alter<NewUser>({
     *  operation: {
     *    add: {
     *      columns: { name: 'text' },
     *    },
     *  },
     * });
     *
     * // Drop a column from the table (resets it to how it was originally)
     * const oldTable = await newTable.alter<User>({
     *   operation: {
     *     drop: {
     *       columns: ['name'],
     *     },
     *   },
     * });
     * ```
     *
     * ---
     *
     * ##### On returning `Table`
     *
     * The `alter` operation returns the table itself, with the new schema type.
     *
     * It is heavily recommended to store the result of the `alter` operation in a new variable, as the old table will not have the new schema type.
     *
     * You should provide the exact new type of the schema, or it'll just default to `SomeRow`.
     *
     * @param options - The options for this operation.
     *
     * @returns The table with the new schema type.
     *
     * @see TableAlterTableOptions
     */
    alter<NewWSchema extends SomeRow, NewRSchema extends SomeRow = FoundRow<NewWSchema>>(options: AlterTableOptions<WSchema>): Promise<Table<NewWSchema, PKey, NewRSchema>>;
    /**
     * ##### Overview
     *
     * Creates a secondary index on the table.
     *
     * The operation blocks until the index is created and ready to use.
     *
     * See {@link Table.createVectorIndex} for creating vector indexes, and {@link Table.createTextIndex} for creating lexical indexes.
     *
     * ---
     *
     * ##### Text indexes
     *
     * `text` and `ascii`-based indexes have access to a few additional options:
     * - `caseSensitive` (default: `true`)
     *   - Allows searches to be case-insensitive, if false
     * - `normalize` (default: `true`)
     *   - Normalize Unicode characters and diacritics before indexing, if true
     * - `ascii` (default: `false`)
     *   - Converts non-ASCII characters to their US-ASCII equivalent before indexing, if true
     *
     * @param name - The name of the index
     * @param column - The column to index
     * @param options - Options for this operation
     *
     * @returns A promise which resolves once the index is created.
     */
    createIndex(name: string, column: TableCreateIndexColumn<WSchema>, options?: TableCreateIndexOptions): Promise<void>;
    /**
     * ##### Overview
     *
     * Creates an index on an existing vector column in the table.
     *
     * The operation blocks until the index is created and ready to use.
     *
     * See {@link Table.createIndex} for creating non-vector indexes.
     *
     * @param name - The name of the index
     * @param column - The vector column to index
     * @param options - Options for this operation
     *
     * @returns A promise which resolves once the index is created.
     */
    createVectorIndex(name: string, column: keyof WSchema, options?: TableCreateVectorIndexOptions): Promise<void>;
    /**
     * ##### Overview
     *
     * Creates a lexical index on an existing text column in the table.
     *
     * The operation blocks until the index is created and ready to use.
     *
     * See {@link Table.createIndex} for creating non-lexical indexes.
     *
     * @param name - The name of the index
     * @param column - The text column to index
     * @param options - Options for this operation
     *
     * @returns A promise which resolves once the index is created.
     */
    createTextIndex(name: string, column: keyof WSchema, options?: TableCreateTextIndexOptions): Promise<void>;
    /**
     * ##### Overview
     *
     * Get the table definition, i.e. it's columns and primary key definition.
     *
     * The method issues a request to the Data API each time it is invoked, without caching mechanisms;
     * this ensures up-to-date information for usages such as real-time table validation by the application.
     *
     * @example
     * ```ts
     * const definition = await table.definition();
     * console.log(definition.columns);
     * ```
     *
     * @param options - The options for this operation.
     *
     * @returns The definition of the table.
     */
    definition(options?: WithTimeout<'tableAdminTimeoutMs'>): Promise<ListTableDefinition>;
    /**
     * ##### Overview
     *
     * Drops the table from the database, including all the rows it contains.
     *
     * @example
     * ```typescript
     * const table = await db.table('my_table');
     * await table.drop();
     * ```
     *
     * ---
     *
     * ##### Disclaimer 🚨
     *
     * > **🚨Important**: Once the table is dropped, this object is still technically "usable", but any further operations on it will fail at the Data API level; thus, it's the user's responsibility to make sure that the {@link Table} object is no longer used.
     *
     * @param options - The options for this operation.
     *
     * @returns A promise which resolves when the table has been dropped.
     *
     * @remarks Use with caution. Wear your safety goggles. Don't say I didn't warn you.
     */
    drop(options?: Omit<DropTableOptions, keyof WithKeyspace>): Promise<void>;
    /**
     * Backdoor to the HTTP client for if it's absolutely necessary. Which it almost never (if even ever) is.
     */
    get _httpClient(): OpaqueHttpClient;
}

/**
 * @public
 */
export declare type TableCodec<Class extends TableCodecClass> = InstanceType<Class>;

/**
 * @public
 */
export declare type TableCodecClass = (abstract new (...args: any[]) => {
    [$SerializeForTable]: (ctx: TableSerCtx) => ReturnType<SerDesFn<any>>;
}) & {
    [$DeserializeForTable]: SerDesFn<TableDesCtx>;
};

/**
 * @beta
 */
export declare class TableCodecs {
    static Defaults: {
        bigint: RawTableCodecs;
        blob: RawTableCodecs;
        counter: RawTableCodecs;
        date: RawTableCodecs;
        decimal: RawTableCodecs;
        double: RawTableCodecs;
        duration: RawTableCodecs;
        float: RawTableCodecs;
        int: RawTableCodecs;
        inet: RawTableCodecs;
        smallint: RawTableCodecs;
        time: RawTableCodecs;
        timestamp: RawTableCodecs;
        timeuuid: RawTableCodecs;
        tinyint: RawTableCodecs;
        uuid: RawTableCodecs;
        vector: RawTableCodecs;
        varint: RawTableCodecs;
        map: RawTableCodecs;
        list: RawTableCodecs;
        set: RawTableCodecs;
    };
    static forName(name: string, optsOrClass: TableNominalCodecOpts | TableCodecClass): RawTableCodecs;
    /**
     * @deprecated
     */
    static forPath(path: readonly PathSegment[], optsOrClass: TableNominalCodecOpts | TableCodecClass): RawTableCodecs;
    static forType<const Type extends string>(type: Type, optsOrClass: TableTypeCodecOpts | TableCodecClass): RawTableCodecs;
    static custom(opts: TableCustomCodecOpts): RawTableCodecs;
    static asCodecClass<Class extends SomeConstructor>(clazz: Class, fns?: AsTableCodecClassFns<Class>): TableCodecClass;
}

/**
 * @public
 */
export declare type TableCreateIndexColumn<WSchema> = keyof WSchema | Partial<Record<(keyof WSchema & string), `$${string}`>>;

/**
 * Options for creating a new index via {@link Table.createIndex}
 *
 * @public
 */
export declare interface TableCreateIndexOptions extends WithTimeout<'tableAdminTimeoutMs'> {
    /**
     * Options available for `text` and `ascii` indexes
     */
    options?: TableIndexOptions;
    /**
     * If `true`, no error will be thrown if the index already exists.
     *
     * Note that this does not check if the existing index is the same as the one attempting to be created; it simply
     * checks if the name is already in use.
     */
    ifNotExists?: boolean;
}

/**
 * Options for creating a new index via {@link Table.createTextIndex}
 *
 * @public
 */
export declare interface TableCreateTextIndexOptions extends WithTimeout<'tableAdminTimeoutMs'> {
    /**
     * Options available for `text` and `ascii` indexes
     */
    options?: TableTextIndexOptions;
    /**
     * If `true`, no error will be thrown if the index already exists.
     *
     * Note that this does not check if the existing index is the same as the one attempting to be created; it simply
     * checks if the name is already in use.
     */
    ifNotExists?: boolean;
}

/**
 * Options for creating a new index via {@link Table.createVectorIndex}
 *
 * @public
 */
export declare interface TableCreateVectorIndexOptions extends WithTimeout<'tableAdminTimeoutMs'> {
    /**
     * Options available for the vector index.
     */
    options?: TableVectorIndexOptions;
    /**
     * If `true`, no error will be thrown if the index already exists.
     *
     * Note that this does not check if the existing index is the same as the one attempting to be created; it simply
     * checks if the name is already in use.
     */
    ifNotExists?: boolean;
}

/**
 * @beta
 */
export declare type TableCustomCodecOpts = CustomCodecOpts<TableSerCtx, TableDesCtx>;

export declare type TableDeleteManyOptions = GenericDeleteManyOptions;

/**
 * Represents the options for the deleteOne command.
 *
 * @field sort - The sort order to pick which document to delete if the filter selects multiple documents.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.deleteOne
 *
 * @public
 */
export declare type TableDeleteOneOptions = Omit<GenericDeleteOneOptions, 'sort' | 'vector' | 'vectorize'>;

/**
 * Information about a table, used when `nameOnly` is false in {@link ListTablesOptions}.
 *
 * The definition is very similar to {@link CreateTableDefinition}, except for a couple key differences. See {@link ListTableDefinition} for more information.
 *
 * @field name - The name of the tables.
 * @field options - The creation options for the tables.
 *
 * @see ListTablesOptions
 * @see Db.listTables
 *
 * @public
 */
export declare interface TableDescriptor {
    /**
     * The name of the table.
     */
    name: string;
    /**
     * The definition of the table (i.e. the `columns` and `primaryKey` fields).
     *
     * Very similar to {@link CreateTableDefinition}, except for a couple key differences. See {@link ListTableDefinition} for more information.
     */
    definition: ListTableDefinition;
}

/**
 * @beta
 */
export declare interface TableDesCtx extends BaseDesCtx<TableDesCtx> {
    tableSchema: ListTableColumnDefinitions;
}

/**
 * Options for dropping an index via {@link Table.dropIndex}
 *
 * @public
 */
export declare interface TableDropIndexOptions extends WithKeyspace, WithTimeout<'tableAdminTimeoutMs'> {
    /**
     * If `true`, an error will not be thrown if the index attempting to be dropped does not exist.
     */
    ifExists?: boolean;
}

/**
 * Represents some filter operation for a given document schema.
 *
 * @example
 * ```typescript
 * interface BasicSchema {
 *   arr: string[],
 *   num: number,
 * }
 *
 * db.Tables<BasicSchema>('coll_name').findOne({
 *   $and: [
 *     { _id: { $in: ['abc', 'def'] } },
 *     { $not: { arr: { $size: 0 } } },
 *   ]
 * });
 * ```
 *
 * @public
 */
export declare type TableFilter<Schema extends SomeRow> = {
    [K in keyof Schema]?: TableFilterExpr<Schema[K]>;
} & {
    $and?: TableFilter<Schema>[];
    $or?: TableFilter<Schema>[];
    $not?: TableFilter<Schema>;
    [key: string]: any;
};

/**
 * Represents an expression in a filter statement, such as an exact value, or a filter operator
 *
 * @public
 */
export declare type TableFilterExpr<Elem> = Elem | TableFilterOps<Elem>;

/**
 * Represents filter operators such as `$eq` and `$in` (but not statements like `$and`)
 *
 * @public
 */
export declare interface TableFilterOps<Elem> {
    $eq?: Elem;
    $ne?: Elem;
    $in?: Elem[];
    $nin?: Elem[];
    $exists?: boolean;
    $lt?: Elem;
    $lte?: Elem;
    $gt?: Elem;
    $gte?: Elem;
}

/* Excluded from this release type: TableFindAndRerankCursor */

/**
 * Options for the table `findAndRerank` method.
 *
 * @see Table.findAndRerank
 *
 * @public
 */
export declare type TableFindAndRerankOptions = GenericFindAndRerankOptions;

/**
 * ##### Overview
 *
 * A lazy iterator over the results of a `find` operation on a {@link Table}.
 *
 * > **⚠️Warning**: Shouldn't be directly instantiated, but rather spawned via {@link Table.find}.
 *
 * ---
 *
 * ##### Typing
 *
 * > **🚨Important:** For most intents and purposes, you may treat the cursor as if it is typed simply as `Cursor<T>`.
 * >
 * > If you're using a projection, it is heavily recommended to provide an explicit type representing the type of the document after projection.
 *
 * In full, the cursor is typed as `TableFindCursor<T, TRaw>`, where
 * - `T` is the type of the mapped records, and
 * - `TRaw` is the type of the raw records before any mapping.
 *
 * If no mapping function is provided, `T` and `TRaw` will be the same type. Mapping is done using the {@link TableFindCursor.map} method.
 *
 * ---
 *
 * ##### Options
 *
 * Options may be set either through the `find({}, options)` method, or through the various fluent **builder
 * methods**, which, *unlike Mongo*, **do not mutate the existing cursor**, but rather return a new, uninitialized cursor
 * with the new option(s) set.
 *
 * @example
 * ```typescript
 * interface Person {
 *   firstName: string,
 *   lastName: string,
 *   age: number,
 * }
 *
 * const table = db.table<Person>('people');
 * const cursor1: Cursor<Person> = table.find({ firstName: 'John' });
 *
 * // Lazily iterate all rows matching the filter
 * for await (const row of cursor1) {
 *   console.log(row);
 * }
 *
 * // Rewind the cursor to be able to iterate again
 * cursor1.rewind();
 *
 * // Get all rows matching the filter as an array
 * const rows = await cursor1.toArray();
 *
 * // Immutably set options & map as needed (changing options returns a new, uninitialized cursor)
 * const cursor2: Cursor<string> = cursor
 *   .project<Omit<Person, 'age'>>({ age: 0 })
 *   .map(row => row.firstName + ' ' + row.lastName);
 *
 * // Get next row from cursor
 * const row = await cursor2.next();
 * ```
 *
 * @see Table.findCursor
 * @see FindCursor
 *
 * @public
 */
export declare class TableFindCursor<T, TRaw extends SomeRow = SomeRow> extends FindCursor<T, TRaw> {
    /**
     * ##### Overview
     *
     * Returns the {@link Table} which spawned this cursor.
     *
     * @example
     * ```ts
     * const table = db.table(...);
     * const cursor = coll.find({});
     * cursor.dataSource === table; // true
     * ```
     */
    get dataSource(): Table<SomeRow>;
    /**
     * ##### Overview
     *
     * Sets the filter for the cursor, overwriting any previous filter.
     *
     * *Note: this method does **NOT** mutate the cursor; it simply returns a new, uninitialized cursor with the given new filter set.*
     *
     * @example
     * ```ts
     * await table.insertOne({ name: 'John', ... });
     *
     * const cursor = table.find({})
     *   .filter({ name: 'John' });
     *
     * // The cursor will only return records with the name 'John'
     * const john = await cursor.next();
     * john.name === 'John'; // true
     * ```
     *
     * @param filter - A filter to select which records to return.
     *
     * @returns A new cursor with the new filter set.
     */
    filter(filter: TableFilter<TRaw>): this;
    project: <RRaw extends SomeRow = Partial<TRaw>>(projection: Projection) => TableFindCursor<RRaw, RRaw>;
    includeSimilarity: (includeSimilarity?: boolean) => TableFindCursor<WithSim<TRaw>, WithSim<TRaw>>;
    map: <R>(map: (doc: T) => R) => TableFindCursor<R, TRaw>;
}

/**
 * Represents the options for the table `findOne` command.
 *
 * @field sort - The sort order to pick which document to return if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field includeSimilarity - If true, include the similarity score in the result via the `$similarity` field.
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare type TableFindOneOptions = GenericFindOneOptions;

/**
 * Options for the table `find` method.
 *
 * @field sort - The sort order to pick which document to return if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field limit - Max number of documents to return in the lifetime of the cursor.
 * @field skip - Number of documents to skip if using a sort.
 * @field includeSimilarity - If true, include the similarity score in the result via the `$similarity` field.
 *
 * @see Table.find
 *
 * @public
 */
export declare type TableFindOptions = GenericFindOptions;

/**
 * Options available for `text` and `ascii` indexes
 *
 * @public
 */
export declare interface TableIndexOptions {
    /**
     * If `false`, enables searches on the column to be case-insensitive.
     *
     * Defaults to `true`.
     */
    caseSensitive?: boolean;
    /**
     * Whether to normalize Unicode characters and diacritics before indexing.
     *
     * Defaults to `false`.
     */
    normalize?: boolean;
    /**
     * Whether to convert non-ASCII characters to their US-ASCII equivalent before indexing.
     *
     * Defaults to `false`.
     */
    ascii?: boolean;
}

/**
 * ##### Overview
 *
 * Represents an error that occurred during a (potentially paginated) `insertMany` operation on a {@link Table}.
 *
 * Contains the inserted primary keys of the documents that were successfully inserted, as well as the cumulative errors
 * that occurred during the operation.
 *
 * If the operation was ordered, the `insertedIds` will be in the same order as the documents that were attempted to
 * be inserted.
 *
 * @example
 * ```ts
 * try {
 *   await table.insertMany([
 *     { id: 'id1', desc: 'An innocent little document' },
 *     { id: 'id2', desc: 'Another little document minding its own business' },
 *     { id: 'id2', desc: 'A mean document commiting _identity theft' },
 *     { id: 'id3', desc: 'A document that will never see the light of day-tabase' },
 *   ], { ordered: true });
 * } catch (e) {
 *   if (e instanceof TableInsertManyError) {
 *     console.log(e.message); // "Document already exists with the given _id"
 *     console.log(e.insertedIds()); // [{ id: 'id1' }, { id: 'id2' }]
 *     console.log(e.errors()); // [DataAPIResponseError(...)]
 *   }
 * }
 * ```
 *
 * ---
 *
 * ##### Collections vs Tables
 *
 * There is a sister {@link CollectionInsertManyError} class that is used for `insertMany` operations on collections. It's identical in structure, but uses the appropriate {@link SomeId} type for the IDs.
 *
 * @see Table.insertMany
 * @see CollectionInsertManyError
 *
 * @public
 */
export declare class TableInsertManyError extends DataAPIError {    /**
     * The name of the error. This is always 'InsertManyError'.
     */
    name: string;
    /* Excluded from this release type: __constructor */
    insertedIds(): SomePKey[];
    errors(): Error[];
}

/**
 * ##### Overview
 *
 * The options for an `insertMany` command on a table.
 *
 * > **🚨Important:** The options depend on the `ordered` parameter. If `ordered` is `true`, then the `concurrency` option is not allowed.
 *
 * @example
 * ```ts
 * const result = await table.insertMany([
 *   { id: uuid.v4(), name: 'John' },
 *   { id: uuid.v7(), name: 'Jane' },
 * ], {
 *   ordered: true,
 *   timeout: 60000,
 * });
 * ```
 *
 * @example
 * ```ts
 * const result = await table.insertMany([
 *   { id: uuid.v4(), name: 'John' },
 *   { id: uuid.v7(), name: 'Jane' },
 * ], {
 *   concurrency: 16, // ordered implicitly `false` if unset
 * });
 * ```
 *
 * ---
 *
 * ##### Datatypes
 *
 * See {@link Table}'s documentation for information on the available datatypes for tables.
 *
 * @see Table.insertMany
 * @see TableInsertManyResult
 *
 * @public
 */
export declare type TableInsertManyOptions = GenericInsertManyOptions;

/**
 * ##### Overview
 *
 * Represents the result of an `insertMany` command on a {@link Table}.
 *
 * @example
 * ```ts
 * try {
 *   const result = await table.insertMany([
 *     { id: uuid.v4(), name: 'John'},
 *     { id: uuid.v7(), name: 'Jane'},
 *   ]);
 *   console.log(result.insertedIds);
 * } catch (e) {
 *   if (e instanceof TableInsertManyError) {
 *     console.log(e.insertedIds())
 *     console.log(e.errors())
 *   }
 * }
 * ```
 *
 * ---
 *
 * ##### The primary key type
 *
 * The type of the primary key of the table is inferred from the second type-param of the {@link Table}.
 *
 * If not set, it defaults to `Partial<RSchema>` to keep the result type consistent.
 *
 * > **💡Tip:** See the {@link SomePKey} type for more information, and concrete examples, on this subject.
 *
 * @see Table.insertMany
 * @see TableInsertManyOptions
 *
 * @public
 */
export declare interface TableInsertManyResult<PKey extends SomePKey> {
    /**
     * The primary key of the inserted (or upserted) row. These will be the same values as the primary keys which were present in the rows which were just inserted.
     *
     * See {@link TableInsertManyResult} for more information about the primary key.
     */
    insertedIds: PKey[];
    /**
     * The number of documents that were inserted into the table.
     *
     * This is **always** equal to the length of the `insertedIds` array.
     */
    insertedCount: number;
}

/**
 * ##### Overview
 *
 * The options for an `insertOne` command on a {@link Table}.
 *
 * @example
 * ```ts
 * const result = await table.insertOne({
 *   id: 'john1234'
 *   name: 'John',
 * }, {
 *   timeout: 10000,
 * });
 * ```
 *
 * ---
 *
 * ##### Datatypes
 *
 * See {@link Table}'s documentation for information on the available datatypes for tables.
 *
 * @see Table.insertOne
 * @see TableInsertOneResult
 *
 * @public
 */
export declare type TableInsertOneOptions = GenericInsertOneOptions;

/**
 * ##### Overview
 *
 * Represents the result of an `insertOne` command on a {@link Table}.
 *
 * @example
 * ```ts
 * const result = await table.insertOne({
 *   id: '123',
 *   name: 'John'
 * });
 *
 * console.log(result.insertedId); // { id: '123' }
 * ```
 *
 * ---
 *
 * ##### The primary key type
 *
 * The type of the primary key of the table is inferred from the second type-param of the {@link Table}.
 *
 * If not set, it defaults to `Partial<RSchema>` to keep the result type consistent.
 *
 * > **💡Tip:** See the {@link SomePKey} type for more information, and concrete examples, on this subject.
 *
 * @see Table.insertOne
 * @see TableInsertOneOptions
 *
 * @public
 */
export declare interface TableInsertOneResult<PKey extends SomePKey> {
    /**
     * The primary key of the inserted (or upserted) row. This will be the same value as the primary key which was present in the row which was just inserted.
     *
     * See {@link TableInsertOneResult} for more information about the primary key.
     */
    insertedId: PKey;
}

/**
 * ##### Overview
 *
 * Represents the syntax for defining a `list` column in a table, which has no shorthand/"loose" equivalent.
 *
 * Of the example format:
 *
 * ```ts
 * columns: {
 *   listCol: { type: 'list', valueType: 'text' },
 * }
 * ```
 *
 * This may then be used through `astra-db-ts` as n `Array<ValueType>` (aka `ValueType[]`):
 *
 * ```ts
 * await table.insertOne({
 *   listCol: ['value1', 'value2', 'value3'],
 * });
 * ```
 *
 * ##### The value type
 *
 * The `valueType` may be any scalar type, such as `'int'`, `'text'`, or `'uuid'`.
 *
 * Nested collection types are not supported.
 *
 * @example
 * ```ts
 * import { uuid } from '@datastax/astra-db-ts';
 *
 * await table.insertOne({
 *   listCol: [uuid.v4(), uuid.v4(), uuid.v7()],
 * });
 * ```
 *
 * @public
 */
export declare interface TableListColumnDefinition {
    type: 'list';
    valueType: TableScalarType;
}

/**
 * ##### Overview
 *
 * Represents the syntax for defining a `map` column in a table, which has no shorthand/"loose" equivalent.
 *
 * Of the example format:
 *
 * ```ts
 * columns: {
 *   mapCol: { type: 'map', keyType: 'text', valueType: 'int' },
 * }
 * ```
 *
 * This may then be used through `astra-db-ts` as a `Map<KeyType, ValueType>`:
 *
 * ```ts
 * await table.insertOne({
 *   mapCol: new Map([['key1', 1], ['key2', 2]]),
 * });
 * ```
 *
 * ##### The key type
 *
 * The `keyType` must, for the time being, be either `'text'` or `'ascii'`.
 *
 * Other fields, even those which are still represented as strings in the serialized JSON form (such as `uuid`) are not supported as key types.
 *
 * ##### The value type
 *
 * The `valueType` may be any scalar type, such as `'int'`, `'text'`, or `'uuid'`.
 *
 * Nested collection types are not supported.
 *
 * @example
 * ```ts
 * import { uuid } from '@datastax/astra-db-ts';
 *
 * await table.insertOne({
 *   mapCol: new Map([['key1', uuid.v4()], ['key2', uuid.v4()]]);
 * });
 * ```
 *
 * @public
 */
export declare interface TableMapColumnDefinition {
    type: 'map';
    keyType: 'text' | 'ascii';
    valueType: TableScalarType;
}

/**
 * @beta
 */
export declare type TableNominalCodecOpts = NominalCodecOpts<TableSerCtx, TableDesCtx>;

/**
 * Options for spawning a new `Table` instance through {@link db.table} or {@link db.createTable}.
 *
 * Note that these are not all the options available for when you're actually creating a table—see {@link CreateTableOptions} for that.
 *
 * @field embeddingApiKey - The embedding service's API-key/headers (for $vectorize)
 * @field timeoutDefaults - Default timeouts for all table operations
 * @field logging - Logging configuration overrides
 * @field serdes - Additional serialization/deserialization configuration
 * @field keyspace - Overrides the keyspace for the table (from the `Db`'s working keyspace).
 *
 * @public
 */
export declare interface TableOptions extends WithKeyspace {
    /**
     * The API key for the embedding service to use, or the {@link EmbeddingHeadersProvider} if using
     * a provider that requires it (e.g. AWS bedrock).
     */
    embeddingApiKey?: string | EmbeddingHeadersProvider;
    /**
     * The API key for the reranking service to use, or the {@link RerankingHeadersProvider} if using
     * a provider that requires it (e.g. AWS bedrock).
     */
    rerankingApiKey?: string | RerankingHeadersProvider;
    /**
     * The configuration for logging events emitted by the {@link DataAPIClient}.
     *
     * This can be set at any level of the major class hierarchy, and will be inherited by all child classes.
     *
     * See {@link LoggingConfig} for *much* more information on configuration, outputs, and inheritance.
     */
    logging?: LoggingConfig;
    /**
     * Advanced & currently somewhat unstable features related to customizing the table's ser/des behavior at a lower level.
     *
     * Use with caution. See official DataStax documentation for more info.
     *
     * @beta
     */
    serdes?: TableSerDesConfig;
    /**
     * ##### Overview
     *
     * The default timeout options for any operation performed on this {@link Table} instance.
     *
     * See {@link TimeoutDescriptor} for much more information about timeouts.
     *
     * @example
     * ```ts
     * // The request timeout for all operations is set to 1000ms.
     * const client = new DataAPIClient('...', {
     *   timeoutDefaults: { requestTimeoutMs: 1000 },
     * });
     *
     * // The request timeout for all operations borne from this Db is set to 2000ms.
     * const db = client.db('...', {
     *   timeoutDefaults: { requestTimeoutMs: 2000 },
     * });
     * ```
     *
     * ##### Inheritance
     *
     * The timeout options are inherited by all child classes, and can be overridden at any level, including the individual method level.
     *
     * Individual-method-level overrides can vary in behavior depending on the method; again, see {@link TimeoutDescriptor}.
     *
     * ##### Defaults
     *
     * The default timeout options are as follows:
     * - `requestTimeoutMs`: 15000
     * - `generalMethodTimeoutMs`: 30000
     * - `collectionAdminTimeoutMs`: 60000
     * - `tableAdminTimeoutMs`: 30000
     * - `databaseAdminTimeoutMs`: 600000
     * - `keyspaceAdminTimeoutMs`: 30000
     *
     * @see TimeoutDescriptor
     */
    timeoutDefaults?: Partial<TimeoutDescriptor>;
}

/**
 * ##### Overview
 *
 * Represents the syntax for defining the primary key of a table through the bespoke Data API schema definition syntax,
 * in which there are two branching ways to define the primary key.
 *
 * @example
 * ```ts
 * await db.createTable('my_table', {
 *   definition: {
 *     columns: ...,
 *     primaryKey: {
 *       partitionBy: ['pt_key'],
 *       partitionSort: { cl_key: 1 },
 *     },
 *   },
 * });
 * ```
 *
 * ##### The shorthand definition
 *
 * If your table only has a single partition key, then you can define the partition key as simply
 *
 * ```ts
 * primaryKey: 'pt_key',
 * ```
 *
 * This is equivalent to the following full definition:
 *
 * ```ts
 * primaryKey: {
 *   partitionBy: ['pt_key'],
 *   partitionSort: {}, // note that this field is also optional if it's empty
 * }
 * ```
 *
 * ##### The full definition
 *
 * If your table has multiple columns in its primary key, you may use the full primary key definition syntax to express that:
 *
 * ```ts
 * primaryKey: {
 *   partitionBy: ['pt_key1', 'pt_key2'],
 *   partitionSort: { cl_key1: 1, cl_key2: -1 },
 * }
 * ```
 *
 * A sort of `1` on the clustering column means ascending, and a sort of -1 means descending.
 *
 * Note that, if you don't have any clustering keys (partition sorts), you can omit the `partitionSort` field entirely:
 *
 * ```ts
 * primaryKey: {
 *   partitionBy: ['pt_key1', 'pt_key2'],
 * }
 * ```
 *
 * @see FullCreateTablePrimaryKeyDefinition
 *
 * @public
 */
export declare type TablePrimaryKeyDefinition<PKCols extends string> = PKCols | FullCreateTablePrimaryKeyDefinition<PKCols>;

/**
 * ##### Overview
 *
 * Represents the "strict" column type definition for a scalar column.
 *
 * Of the example format:
 *
 * ```ts
 * columns: {
 *   uuidCol: { type: 'uuid' },
 *   textCol: { type: 'text' },
 * }
 * ```
 *
 * ##### The "loose" syntax
 *
 * If you prefer, you can use the shorthand "loose" syntax instead, which is equivalent to the above:
 *
 * ```ts
 * columns: {
 *   uuidCol: 'uuid',
 *   textCol: 'text',
 * }
 * ```
 *
 * The only difference is that the "loose" syntax does not statically enforce the type of the column, whereas the "strict" syntax does.
 *
 * However, the loose syntax still provides autocomplete for the scalar types' names.
 *
 * @see StrictCreateTableColumnDefinition
 *
 * @public
 */
export declare interface TableScalarColumnDefinition {
    type: TableScalarType;
}

/**
 * ##### Overview
 *
 * Represents the scalar types that can be used to define a column in a table.
 *
 * ##### Disclaimer
 *
 * _Note that there may be other scalar types not present in this union that have partial Data API support, but may not be created through the Data API (such as `timeuuid` or `varchar`)._
 *
 * @public
 */
export declare type TableScalarType = 'ascii' | 'bigint' | 'blob' | 'boolean' | 'date' | 'decimal' | 'double' | 'duration' | 'float' | 'int' | 'inet' | 'smallint' | 'text' | 'time' | 'timestamp' | 'tinyint' | 'uuid' | 'varint';

/**
 * ##### Overview
 *
 * Provides a way to override the type of specific datatypes in the {@link InferTableSchema}-like utility types.
 *
 * ##### Use-case: Custom ser/des
 *
 * This is especially useful when working with custom ser/des, necessitating you to use a different type for a specific datatype.
 *
 * @example
 * ```ts
 * const BigIntAsBigNumberCodec = TableCodecs.forType('bigint', {
 *   deserialize: (value, ctx) => ctx.done(BigNumber(value)),
 * });
 *
 * const ProductSchema = Table.schema({
 *   columns: {
 *     id: 'bigint',
 *     description: 'text',
 *     price: 'bigint',
 *   },
 *   primaryKey: 'id',
 * });
 *
 * // type Product = {
 * //   id: BigNumber, (primary key is always non-null)
 * //   description?: string | null,
 * //   price?: BigNumber | null,
 * // }
 * type Product = InferTableSchema<typeof ProductSchema, { bigint: BigNumber | null }>;
 *
 * const table = await db.createTable('products', {
 *   definition: ProductSchema,
 *   serdes: {
 *     codecs: [BigIntAsBigNumberCodec],
 *   },
 * });
 * ```
 *
 * ##### Use-case: Removing `| null`
 *
 * If you really want a column to be non-null, you can use the `TypeOverrides` type to override the type of a specific datatype to be non-null.
 *
 * @example
 * ```ts
 * const ProductSchema = Table.schema({
 *   columns: {
 *     id: 'bigint',
 *     description: 'text',
 *     price: 'bigint',
 *   },
 *   primaryKey: 'id',
 * });
 *
 * // type Product = {
 * //   id: BigNumber, (primary key is always non-null)
 * //   description?: string,
 * //   price?: BigNumber,
 * // }
 * type Product = InferTableSchema<typeof ProductSchema, {
 *   bigint: BigNumber,
 *   text: string,
 * }>;
 * ```
 *
 * ##### Use-case: Adding datatypes
 *
 * You can also add typing support for a datatype which isn't yet supported by the client.
 *
 * @example
 * ```ts
 * const ProductSchema = Table.schema({
 *   columns: {
 *     id: 'bigint',
 *     description: 'text',
 *     price: 'super_duper_bigint',
 *   },
 *   primaryKey: 'id',
 * });
 *
 * // type Product = {
 * //   id: BigNumber,
 * //   description?: string,
 * //   price?: BigNumber,
 * // }
 * type Product = InferTableSchema<typeof ProductSchema, {
 *   super_duper_bigint: BigNumber,
 * }>;
 * ```
 *
 * ##### Overriding collection types
 *
 * > **🚨Important:** Because TypeScript does not _natively_ support higher-kinded types, it is not yet possible to **polymorphically** override the type of collection types (e.g. `list`, `set`, `map`).
 *
 * However, you can still technically override the type of a collection datatype monomorphically.
 *
 * @example
 * ```ts
 * const ExampleSchema = Table.schema({
 *   columns: {
 *     id: 'uuid',
 *     map: { type: 'map', keyType: 'text', valueType: 'int' },
 *   },
 *   primaryKey: 'id',
 * });
 *
 * // type Example = {
 * //   id: UUID,
 * //   map?: Record<string, number>,
 * // }
 * type Example = InferTableSchema<typeof ExampleSchema, {
 *   map: Map<string, number>,
 * }>;
 * ```
 *
 *
 * @public
 */
export declare type TableSchemaTypeOverrides = Partial<Record<LitUnion<keyof CqlNonGenericType2TSTypeDict | keyof CqlGenericType2TSTypeDict<any, any>>, unknown>>;

/**
 * @beta
 */
export declare interface TableSerCtx extends BaseSerCtx<TableSerCtx> {
    bigNumsPresent: boolean;
}

/**
 * @beta
 */
export declare interface TableSerDesConfig extends BaseSerDesConfig<TableSerCtx, TableDesCtx> {
    sparseData?: boolean;
    codecs?: RawTableCodecs[];
}

/**
 * ##### Overview
 *
 * Represents the syntax for defining a `set` column in a table, which has no shorthand/"loose" equivalent.
 *
 * Of the example format:
 *
 * ```ts
 * columns: {
 *   setCol: { type: 'set', valueType: 'text' },
 * }
 * ```
 *
 * This may then be used through `astra-db-ts` as n `Set<ValueType>`:
 *
 * ```ts
 * await table.insertOne({
 *   setCol: new Set(['value1', 'value2', 'value3']),
 * });
 * ```
 *
 * ##### The value type
 *
 * The `valueType` may be any scalar type, such as `'int'`, `'text'`, or `'uuid'`.
 *
 * Nested collection types are not supported.
 *
 * @example
 * ```ts
 * import { uuid } from '@datastax/astra-db-ts';
 *
 * await table.insertOne({
 *   setCol: new Set([uuid.v4(), uuid.v4(), uuid.v7()]),
 * });
 * ```
 *
 * @public
 */
export declare interface TableSetColumnDefinition {
    type: 'set';
    valueType: TableScalarType;
}

/**
 * Options available for `text` and `ascii` indexes
 *
 * @public
 */
export declare interface TableTextIndexOptions {
    analyzer?: string | Record<string, unknown>;
}

/**
 * @beta
 */
export declare type TableTypeCodecOpts = TypeCodecOpts<TableSerCtx, TableDesCtx>;

/**
 * Represents the update filter to specify how to update a document.
 *
 * @example
 * ```typescript
 * const updateFilter: TableUpdateFilter<SomeDoc> = {
 *   $set: {
 *     'customer': 'Jim B.'
 *   },
 *   $unset: {
 *     'customer': ''
 *   },
 * }
 * ```
 *
 * @field $set - Set the value of a field in the document.
 * @field $unset - Remove the field from the document.
 *
 * @public
 */
export declare interface TableUpdateFilter<Schema extends SomeRow> {
    /**
     * Set the value of a field in the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $set: {
     *     'customer.name': 'Jim B.'
     *   }
     * }
     * ```
     */
    $set?: Partial<Schema> & SomeRow;
    /**
     * Remove the field from the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $unset: {
     *     'customer.phone': ''
     *   }
     * }
     * ```
     */
    $unset?: Record<string, '' | true | 1>;
}

/**
 * Options for an `updateOne` command on a collection.
 *
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field sort - The sort order to pick which document to update if the filter selects multiple documents.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.updateOne
 *
 * @public
 */
export declare type TableUpdateOneOptions = Omit<GenericUpdateOneOptions, 'upsert' | 'sort' | 'vector' | 'vectorize'>;

/**
 * ##### Overview
 *
 * Represents the syntax for defining a `vector` column in a table, which has no shorthand/"loose" equivalent.
 *
 * Of the example format:
 *
 * ```ts
 * columns: {
 *   vectorCol: { type: 'vector', dimension: 3 },
 * }
 * ```
 *
 * This may then be used through `astra-db-ts` as a `DataAPIVector`:
 *
 * ```ts
 * import { vector } from '@datastax/astra-db-ts';
 *
 * await table.insertOne({
 *   vectorCol: vector([1, 2, 3]),
 * });
 *
 * // Or, if vectorize (auto-embedding-generation) is enabled:
 * await table.insertOne({
 *   vectorCol: 'Alice went to the beach',
 * });
 * ```
 *
 * Keep in mind though, that a vector index must still be created on this column (through {@link Table.createVectorIndex} or CQL directly) to enable vector search on this column.
 *
 * ##### The dimension
 *
 * The `dimension` must be a positive integer, and represents the number of elements in the vector.
 *
 * Note that, at the time of writing, the dimension must still be specified, even if a `service` block is present.
 *
 * ##### The service block
 *
 * You may specify the `service` block to enable vectorize (auto-embedding-generation) for the column.
 *
 * If this is configured, then you can pass a `string` to the vector column instead of a vector directly, and have the Data API automatically embed it for you, using the model of your choice.
 *
 * If the `service` field is present, then {@link InferTableSchema} will also type the column as `string | DataAPIVector | null` instead of just `DataAPIVector | null`.
 *
 * @see Table.createVectorIndex
 * @see DataAPIVector
 *
 * @public
 */
export declare interface TableVectorColumnDefinition {
    type: 'vector';
    dimension: number;
    service?: VectorizeServiceOptions;
}

/**
 * Options aviailable for the vector index
 *
 * @public
 */
export declare interface TableVectorIndexOptions {
    /**
     * The similarity metric to use for the index.
     */
    metric?: 'cosine' | 'euclidean' | 'dot_product';
    /**
     * Enable certain vector optimizations on the index by specifying the source model for your vectors, such as (not exhaustive) `'openai_v3_large'`, `'openai_v3_small'`, `'ada002'`, `'gecko'`, `'bert'`, or `'other'` (default).
     */
    sourceModel?: LitUnion<'other'>;
}

/**
 * ##### Overview
 *
 * A shorthand function-object for {@link DataAPITime}. May be used anywhere when creating new `DataAPITime`s.
 *
 * See {@link DataAPITime} and its methods for information about input parameters, formats, functions, etc.
 *
 * @example
 * ```ts
 * // equiv. to `new DataAPITime('12:34:56')`
 * time('12:34:56')
 *
 * // equiv. to `new DataAPITime(12, 34)
 * time(12, 34)
 *
 * // equiv. to `DataAPITime.now()`
 * time.now()
 * ```
 *
 * @public
 */
export declare const time: ((...params: [string] | [DataAPITime] | [Date] | [number, number, number?, number?]) => DataAPITime) & {
    now: typeof DataAPITime.now;
    utcnow: typeof DataAPITime.utcnow;
    ofNanoOfDay: typeof DataAPITime.ofNanoOfDay;
    ofSecondOfDay: typeof DataAPITime.ofSecondOfDay;
};

/**
 * ##### Overview
 *
 * The timeouts that timed out.
 *
 * Depending on what causes the timeout, the value can be an array of timeout categories, or the string `'provided'`
 *
 * ##### Array of timeout categories
 *
 * If the timeout occurred due to one or more timeouts from the {@link TimeoutDescriptor},
 * the array will contain the names of the timeout categories that caused the timeout.
 *
 * @example
 * ```ts
 * error.timedOutCategories = ['requestTimeoutMs', 'generalMethodTimeoutMs']
 * ```
 *
 * ##### Provided timeout
 *
 * If the timeout occurred due to a timeout provided by the user in a **single-call** method, the value will be the literal string `'provided'`.
 *
 * The timeout must've been set like the following, for this to be the case:
 *
 * ```ts
 * await coll.insertOne({ ... }, { timeout: 1000 });
 * ```
 *
 * @see DataAPITimeoutError
 * @see DevOpsAPITimeoutError
 *
 * @public
 */
export declare type TimedOutCategories = ReadonlyNonEmpty<keyof TimeoutDescriptor> | 'provided';

/* Excluded from this release type: TimeoutCfgHandler */

/**
 * #### Overview
 *
 * The generic timeout descriptor that is used to define the timeout for all the various operations supported by
 * the {@link DataAPIClient} and its children.
 *
 * ###### Inheritance
 *
 * The {@link TimeoutDescriptor}, or a subset of it, may be specified at any level of the client hierarchy, all the
 * way from the {@link DataAPIClient} down to the individual methods. The timeout specified at a lower level will
 * override the timeout specified at a higher level (through a typical object merge).
 *
 * @example
 * ```ts
 * // The request timeout for all operations is set to 1000ms.
 * const client = new DataAPIClient('...', {
 *   timeoutDefaults: { requestTimeoutMs: 1000 },
 * });
 *
 * // The request timeout for all operations borne from this Db is set to 2000ms.
 * const db = client.db('...', {
 *   timeoutDefaults: { requestTimeoutMs: 2000 },
 * });
 * ```
 *
 * ###### The `WithTimeout` interface
 *
 * The {@link WithTimeout} interface lets you specify timeouts for individual methods, in two different formats:
 * - A subtype of {@link TimeoutDescriptor}, which lets you specify the timeout for specific categories.
 * - A number, which specifies the "happy path" timeout for the method.
 *   - In single-call methods, this sets both the request & overall method timeouts.
 *   - In multi-call methods, this sets the overall method timeout (request timeouts are kept as default).
 *
 * @example
 * ```ts
 * // Both `requestTimeoutMs` and `generalMethodTimeoutMs` are set to 1000ms.
 * await coll.insertOne({ ... }, { timeout: 1000 });
 *
 * // `requestTimeoutMs` is left as default, `generalMethodTimeoutMs` is set to 2000ms.
 * await coll.insertOne({ ... }, { timeout: { generalMethodTimeoutMs: 2000 } });
 *
 * // Both `requestTimeoutMs` and `generalMethodTimeoutMs` are set to 2000ms.
 * await coll.insertMany([...], {
 *   timeout: { requestTimeoutMs: 2000, generalMethodTimeoutMs: 2000 },
 * });
 * ```
 *
 * @example
 * ```ts
 * // `requestTimeoutMs` is left as default, `generalMethodTimeoutMs` is set to 2000ms.
 * await coll.insertMany([...], { timeout: 2000 });
 *
 * // `requestTimeoutMs` is left as default, `generalMethodTimeoutMs` is set to 2000ms.
 * await coll.insertMany([...], { timeout: { generalMethodTimeoutMs: 2000 } });
 *
 * // Both `requestTimeoutMs` and `generalMethodTimeoutMs` are set to 2000ms.
 * await coll.insertMany([...], {
 *   timeout: { requestTimeoutMs: 2000, generalMethodTimeoutMs: 2000 },
 * });
 * ```
 *
 * #### Timeout types
 *
 * There are 6 generalized categories of timeouts, each with its own default values.
 *
 * In general though, two types of timeouts are always in play:
 * - `requestTimeoutMs`, which is the maximum time the client will wait for a response from the server.
 * - The overall method timeout, which is the maximum time the client will wait for the entire method to complete.
 *
 * Timeout behavior depends on the type of method being called:
 * - In single-call methods, the minimum of these two values is used as the timeout.
 * - In multi-call methods, the `requestTimeoutMs` is used as the timeout for each individual call, and the overall method timeout is used as the timeout for the entire method.
 *
 * This two-part timeout system is used in all methods but, but for a special few, where the overall method timeout is the only one used (only `createCollection`, at the moment). This is because the method is a single call, but it takes a long time for the server to complete.
 *
 * If any timeout is set to `0`, that category is effectively disabled.
 *
 * ###### Timeout categories
 *
 * See each individual field for more information, but in general, the timeouts are as follows:
 * - `requestTimeoutMs`:
 *   - The maximum time the client will wait for a response from the server.
 *   - Default: 10 seconds
 * - `generalMethodTimeoutMs`:
 *   - The overall method timeout for methods that don't have a specific overall method timeout.
 *   - (mostly applies to document/row-level operations)
 *   - Default: 30 seconds
 * - `collectionAdminTimeoutMs`:
 *   - The overall method timeout for collection admin operations.
 *   - (create, drop, list, etc.)
 *   - Default: 1 minute
 * - `tableAdminTimeoutMs`:
 *   - The overall method timeout for table admin operations.
 *   - (create, drop, list, alter, create/dropIndex, etc.)
 *   - Default: 30 seconds
 * - `databaseAdminTimeoutMs`:
 *   - The overall method timeout for database admin operations.
 *   - (create, drop, list, info, findEmbeddingProviders, etc.)
 *   - Default: 10 minutes
 * - `keyspaceAdminTimeoutMs`:
 *   - The overall method timeout for keyspace admin operations.
 *   - (create, drop, list)
 *   - Default: 30 seconds
 *
 * @see WithTimeout
 *
 * @public
 */
export declare interface TimeoutDescriptor {
    /**
     * The maximum time the client will wait for a response from the server.
     *
     * Note that it is technically possible for a request to time out, but still have the request be processed, and even succeed, on the server.
     *
     * Every HTTP call will use a `requestTimeout`, except for very special cases (at the moment, only `createCollection`, where the request may take a long time to return).
     *
     * Default: 10 seconds
     */
    requestTimeoutMs: number;
    /**
     * The overall method timeout for methods that don't have a specific overall method timeout.
     *
     * Mostly applies to document/row-level operations. DDL-esque operations (working with collections, tables, databases, keyspaces, indexes, etc.) have their own overall method timeouts.
     *
     * In single-call methods, such as `insertOne`, the minimum of `requestTimeoutMs` and `generalMethodTimeoutMs` is used as the timeout.
     *
     * In multi-call methods, such as `insertMany`, the `requestTimeoutMs` is used as the timeout for each individual call, and the `generalMethodTimeoutMs` is used as the timeout for the entire method.
     *
     * Default: 30 seconds
     */
    generalMethodTimeoutMs: number;
    /**
     * The overall method timeout for collection admin operations.
     *
     * Such methods include (but may not be limited to):
     * - `db.createCollection()`
     * - `db.dropCollection()`
     * - `db.listCollections()`
     * - `collection.options()`
     *
     * Default: 1 minute
     */
    collectionAdminTimeoutMs: number;
    /**
     * The overall method timeout for table admin operations.
     *
     * Such methods include (but may not be limited to):
     * - `db.createTable()`
     * - `db.dropTable()`
     * - `db.listTables()`
     * - `table.alter()`
     * - `table.createIndex()`
     * - `db.dropTableIndex()`
     * - `table.definition()`
     *
     *
     * Default: 30 seconds
     */
    tableAdminTimeoutMs: number;
    /**
     * The overall method timeout for database admin operations.
     *
     * Such methods include (but may not be limited to):
     * - `admin.createDatabase()`
     * - `admin.dropDatabase()`
     * - `admin.listDatabases()`
     * - `dbAdmin.info()`
     * - `dbAdmin.findEmbeddingProviders()`
     *
     * Default: 10 minutes
     */
    databaseAdminTimeoutMs: number;
    /**
     * The overall method timeout for keyspace admin operations.
     *
     * Such methods include (but may not be limited to):
     * - `admin.createKeyspace()`
     * - `admin.dropKeyspace()`
     * - `admin.listKeyspaces()`
     *
     * Default: 30 seconds
     */
    keyspaceAdminTimeoutMs: number;
}

/* Excluded from this release type: TimeoutManager */

/* Excluded from this release type: Timeouts */

/**
 * Converts some `Schema` into a type representing its dot notation (object paths).
 *
 * If a value is any or SomeDoc, it'll be allowed to be any old object.
 *
 * *Note that this does NOT support indexing into arrays beyond the initial array index itself. Meaning,
 * `arr.0` is supported, but `arr.0.property` is not. Use a more flexible type (such as `any` or `SomeDoc`)
 * to support that.*
 *
 * @example
 * ```typescript
 * interface BasicSchema {
 *   num: number,
 *   arr: string[],
 *   obj: {
 *     nested: string,
 *     someDoc: SomeDoc,
 *   }
 * }
 *
 * interface BasicSchemaInDotNotation {
 *   'num': number,
 *   'arr': string[],
 *   [`arr.${number}`]: string,
 *   'obj': { nested: string, someDoc: SomeDoc }
 *   'obj.nested': string,
 *   'obj.someDoc': SomeDoc,
 *   [`obj.someDoc.${string}`]: any,
 * }
 * ```
 *
 * @public
 */
export declare type ToDotNotation<Schema extends SomeDoc> = Merge<_ToDotNotation<Schema, ''>>;

declare type _ToDotNotation<_Elem extends SomeDoc, Prefix extends string, Elem = Required<_Elem>> = {
    [Key in keyof Elem]: SomeDoc extends Elem ? ((Prefix extends '' ? never : Record<CropTrailingDot<Prefix>, Elem>) | Record<`${Prefix}${string}`, any>) : true extends false & Elem[Key] ? (Record<`${Prefix}${Key & string}`, Elem[Key]> | Record<`${Prefix}${Key & string}.${string}`, Elem[Key]>) : Elem[Key] extends any[] ? (Record<`${Prefix}${Key & string}`, Elem[Key]> | Record<`${Prefix}${Key & string}.${number}`, Elem[Key][number]>) : Elem[Key] extends UUID | ObjectId ? Record<`${Prefix}${Key & string}`, Elem[Key]> : Elem[Key] extends Date ? Record<`${Prefix}${Key & string}`, Date | {
        $date: number;
    }> : Elem[Key] extends SomeDoc ? (Record<`${Prefix}${Key & string}`, Elem[Key]> | _ToDotNotation<Elem[Key], `${Prefix}${Key & string}.`>) : Record<`${Prefix}${Key & string}`, Elem[Key]>;
}[keyof Elem] extends infer Value ? Value : never;

/**
 * The base class for some "token provider", a general concept for anything that provides some token to the client,
 * whether it be a static token, or if the token is dynamically fetched at runtime, or periodically refreshed.
 *
 * The {@link TokenProvider.getToken} function is called any time the token is required, whether it be
 * for the Data API, or the DevOps API.
 *
 * `astra-db-ts` provides all the main token providers you may ever need to use, but you're able to extend this
 * class to create your own if you find it necessary.
 *
 * Generally, where you can pass in a `TokenProvider`, you may also pass in a plain string which is translated
 * into a {@link StaticTokenProvider} under the hood.
 *
 * @example
 * ```typescript
 * const provider = new UsernamePasswordTokenProvider('username', 'password');
 * const client = new DataAPIClient(provider);
 * ```
 *
 * @see StaticTokenProvider
 * @see UsernamePasswordTokenProvider
 *
 * @public
 */
export declare abstract class TokenProvider {
    /* Excluded from this release type: opts */
    /**
     * The function which provides the token. It may do any I/O as it wishes to obtain/refresh the token, as it's called
     * every time the token is required for use, whether it be for the Data API, or the DevOps API.
     */
    abstract getToken(): string | null | undefined | Promise<string | null | undefined>;
    /* Excluded from this release type: toHeadersProvider */
    /* Excluded from this release type: _mkAuthHeader */
}

/* Excluded from this release type: TokenProviderOptsHandler */

/**
 * ##### Overview
 *
 * Caused by a {@link Collection.countDocuments} operation that failed because the resulting number of documents exceeded *either*
 * the upper bound set by the caller, or the hard limit imposed by the Data API.
 *
 * @example
 * ```typescript
 * await collections.insertMany('<100_length_array>');
 *
 * try {
 *   await collections.countDocuments({}, 50);
 * } catch (e) {
 *   if (e instanceof TooManyDocumentsToCountError) {
 *     console.log(e.limit); // 50
 *     console.log(e.hitServerLimit); // false
 *   }
 * }
 * ```
 *
 * @see Collection.countDocuments
 *
 * @public
 */
export declare class TooManyDocumentsToCountError extends DataAPIError {
    /**
     * The limit that was specified by the caller, or the server-imposed limit if the caller's limit was too high.
     */
    readonly limit: number;
    /**
     * Specifies if the server-imposed limit was hit. If this is `true`, the `limit` field will contain the server's
     * limit; otherwise it will contain the caller's limit.
     */
    readonly hitServerLimit: boolean;
    /* Excluded from this release type: __constructor */
}

/* Excluded from this release type: Type */

/**
 * @public
 */
export declare type TypeCodecOpts<SerCtx, DesCtx> = CustomCodecSerOpts<SerCtx> & {
    deserialize?: SerDesFn<DesCtx>;
};

/**
 * Represents some type-level error which forces immediate attention rather than failing at runtime.
 *
 * More inflexible type than `never`, and gives contextual error messages.
 *
 * @example
 * ```typescript
 * function unsupported(): TypeErr<'Unsupported operation'> {
 *   throw new Error('Unsupported operation');
 * }
 *
 * // Doesn't compile with error:
 * // Type TypeErr<'Unsupported operation'> is not assignable to type string
 * const result: string = unsupported();
 * ```
 *
 * @public
 */
declare interface TypeErr<S> {
    [$ERROR]: S;
}

/* Excluded from this release type: Types */

/* Excluded from this release type: Types_2 */

/* Excluded from this release type: Types_3 */

/* Excluded from this release type: Types_4 */

/* Excluded from this release type: Types_5 */

/* Excluded from this release type: Types_6 */

/**
 * ##### Overview
 *
 * Splits a field path into its individual segments, accounting for potentially escaped characters.
 *
 * > **✏️Note:** This is _not_ the exact inverse of {@link escapeFieldNames}, as while the former may encode numbers into strings, this function will always return strings.
 * >
 * >
 *
 * @example
 * ```ts
 * import { unescapeFieldPath } from '@datastax/astra-db-ts';
 *
 * // ['websites', 'www.datastax.com', 'visits']
 * unescapeFieldPath('websites.www&.datastax&.com.visits')
 *
 * // ['shows', 'tom&jerry', 'episodes', '3', 'views']
 * unescapeFieldPath('shows.tom&&jerry.episodes.3.views')
 * ```
 *
 * @public
 */
export declare function unescapeFieldPath(path: string): string[];

/**
 * ##### Overview
 *
 * Error thrown when the Data API response is not as expected. Should never be thrown in normal operation.
 *
 * ##### Possible causes
 *
 * 1. A `Collection` was used on a table, or vice versa.
 *
 * 2. New Data API changes occurred that are not yet supported by the client.
 *
 * 3. There is a bug in the Data API or the client.
 *
 * ##### Possible solutions
 *
 * For #1, ensure that you're using the right `Table` or `Collection` class.
 *
 * If #2 or #3, upgrade your client, and/or open an issue on the [`astra-db-ts` GitHub repository](https://github.com/datastax/astra-db-ts/issues).
 *  - If you open an issue, please include the full error message and any relevant context.
 *  - Please do not hesitate to do so, as there is likely a bug somewhere.
 *
 * @public
 */
export declare class UnexpectedDataAPIResponseError extends Error {
    /**
     * The response that was unexpected.
     */
    readonly rawDataAPIResponse?: unknown;
    /* Excluded from this release type: __constructor */
    static require<T>(val: T | null | undefined, message: string, rawDataAPIResponse?: unknown): T;
}

declare type UnionToIntersection<U> = (U extends any ? (arg: U) => any : never) extends ((arg: infer I) => void) ? I : never;

/* Excluded from this release type: Unparse */

/**
 * Represents a generic update filter type.
 *
 * See {@link CollectionUpdateFilter} & {@link TableUpdateFilter} for the more specific filter types.
 *
 * @public
 */
export declare type UpdateFilter = Record<string, any>;

/**
 * ##### Overview
 *
 * Represents the set of fields that are present in the result of a generic `update*` command performed on the Data API, when:
 * - The `upsert` option is `true`, and
 * - An upsert occurred.
 *
 * @see GenericUpdateResult
 * @see NoUpsertUpdateResult
 *
 * @public
 */
export declare interface UpsertedUpdateResult<ID> {
    /**
     * The number of records that were upserted. Only one record can be upserted in an operation.
     */
    upsertedCount: 1;
    /**
     * The identifier of the upserted record.
     */
    upsertedId: ID;
}

/**
 * A token provider which translates a username-password pair into the appropriate authentication token for DSE, HCD.
 *
 * Uses the format `Cassandra:b64(username):password(username)`
 *
 * @example
 * ```typescript
 * const provider = new UsernamePasswordTokenProvider('username', 'password');
 * const client = new DataAPIClient(provider, { environment: 'dse' });
 * ```
 *
 * @see TokenProvider
 *
 * @public
 */
export declare class UsernamePasswordTokenProvider extends StaticTokenProvider {
    /**
     * Constructs an instead of the {@link TokenProvider}.
     *
     * @param username - The username for the DSE instance
     * @param password - The password for the DSE instance
     */
    constructor(username: string, password: string);
}

/**
 * Represents a UUID that can be used as an _id in the DataAPI.
 *
 * Provides methods for creating v4 and v7 UUIDs, and for parsing timestamps from v7 UUIDs.
 *
 * @example
 * ```typescript
 * const collections = await db.createCollection('myCollection'. {
 *   defaultId: {
 *     type: 'uuidv7',
 *   },
 * });
 *
 * await collections.insertOne({ type: 'Jomsvikings' });
 *
 * const doc = await collections.findOne({ type: 'Jomsvikings' });
 *
 * // Prints the UUID of the document
 * console.log(doc._id.toString());
 *
 * // Prints the timestamp when the document was created (server time)
 * console.log(doc._id.getTimestamp());
 * ```
 *
 * @example
 * ```typescript
 * await collections.insertOne({ _id: UUID.v4(), car: 'toon' });
 *
 * const doc = await collections.findOne({ car: 'toon' });
 *
 * // Prints the UUID of the document
 * console.log(doc._id.toString());
 *
 * // Undefined, as the document was created with a v4 UUID
 * console.log(doc._id.getTimestamp());
 * ```
 *
 * @see ObjectId
 *
 * @public
 */
export declare class UUID implements DataAPICodec<typeof UUID> {
    /**
     * The version of the UUID.
     */
    readonly version: number;
    private readonly _raw;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (string | undefined)?];
    /**
     * Implementation of `$SerializeForCollection` for {@link TableCodec}
     */
    [$SerializeForCollection](ctx: CollectionSerCtx): readonly [0, ({
        $uuid: string;
    } | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: any, ctx: TableDesCtx): readonly [0, (UUID | undefined)?];
    /**
     * Implementation of `$DeserializeForCollection` for {@link TableCodec}
     */
    static [$DeserializeForCollection](value: any, ctx: CollectionDesCtx): readonly [0, (UUID | undefined)?];
    /**
     * Creates a new UUID instance.
     *
     * Use `UUID.v4()` or `UUID.v7()` to generate random new UUIDs.
     *
     * @param uuid - The UUID string.
     * @param validate - Whether to validate the UUID string. Defaults to `true`.
     * @param version - The version of the UUID. If not provided, it is inferred from the UUID string.
     */
    constructor(uuid: string | UUID, validate?: boolean, version?: number);
    /**
     * Compares this UUID to another UUID.
     *
     * **The other UUID can be a UUID instance or a string.**
     *
     * A UUID is considered equal to another UUID if their lowercase string representations are equal.
     *
     * @param other - The UUID to compare to.
     *
     * @returns `true` if the UUIDs are equal, `false` otherwise.
     */
    equals(other: unknown): boolean;
    /**
     * Returns the timestamp of a v1 or v7 UUID. If the UUID is not a v1 or v7 UUID, this method returns `undefined`.
     *
     * @returns The timestamp of the UUID, or `undefined` if the UUID is not a v1 or v7 UUID.
     */
    getTimestamp(): Date | undefined;
    /**
     * Returns the string representation of the UUID in lowercase.
     */
    toString(): string;
    /**
     * Creates a new v1 UUID.
     */
    static v1(this: void, msecs?: number, nsecs?: number): UUID;
    /**
     * Creates a new v4 UUID.
     */
    static v4(this: void): UUID;
    /**
     * Creates a new v6 UUID.
     */
    static v6(this: void, msecs?: number, nsecs?: number): UUID;
    /**
     * Creates a new v7 UUID.
     */
    static v7(this: void, msecs?: number): UUID;
}

/**
 * ##### Overview
 *
 * A shorthand function-object for {@link UUID}. May be used anywhere when creating new `UUID`s.
 *
 * @example
 * ```ts
 * // equiv. to `new UUID('f47ac10b-58cc-4372-a567-0e02b2c3d479')`
 * uuid('f47ac10b-58cc-4372-a567-0e02b2c3d479')
 *
 * // equiv. to `UUID.v4()`
 * uuid.v4()
 * ```
 *
 * @public
 */
export declare const uuid: ((uuid: string | UUID) => UUID) & {
    v1: typeof UUID.v1;
    v4: typeof UUID.v4;
    v6: typeof UUID.v6;
    v7: typeof UUID.v7;
};

/**
 * A shorthand function for `new DataAPIVector(vector)`
 *
 * @public
 */
export declare const vector: (v: DataAPIVectorLike) => DataAPIVector;

/**
 * Utility type for a document that wishes to leverage raw vector capabilities.
 *
 * @example
 * ```typescript
 * export interface Idea extends VectorDoc {
 *   category: string,
 *   idea: string,
 * }
 *
 * db.collections<Idea>('ideas').insertOne({
 *   category: 'doors',
 *   idea: 'Upside down doors',
 *   $vector: [.23, .05, .95, .83, .42],
 * });
 * ```
 *
 * @public
 */
export declare interface VectorDoc {
    /**
     * A raw vector
     */
    $vector?: DataAPIVector;
}

/**
 * Utility type for a document that wishes to leverage automatic vectorization (assuming the collections is vectorize-enabled).
 *
 * @example
 * ```typescript
 * export interface Idea extends VectorizeDoc {
 *   category: string,
 * }
 *
 * db.collections<Idea>('ideas').insertOne({
 *   category: 'doors',
 *   $vectorize: 'Upside down doors',
 * });
 * ```
 *
 * @public
 */
export declare interface VectorizeDoc extends VectorDoc {
    /**
     * A string field to be automatically vectorized
     */
    $vectorize?: string;
}

/**
 * The options for defining the embedding service used for vectorize, to automatically transform your
 * text into a vector ready for semantic vector searching.
 *
 * You can find out more information about each provider/model in the [DataStax docs](https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html),
 * or through {@link DbAdmin.findEmbeddingProviders}.
 *
 * @field provider - The name of the embedding provider which provides the model to use
 * @field model - The specific model to use for embedding, or undefined if it's an endpoint-defined model
 * @field authentication - Object containing any necessary collections-bound authentication, if any
 * @field parameters - Object allowing arbitrary parameters that may be necessary on a per-model basis
 *
 * @public
 */
export declare interface VectorizeServiceOptions {
    /**
     * The name of the embedding provider which provides the model to use.
     *
     * You can find out more information about each provider in the [DataStax docs](https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html),
     * or through  {@link DbAdmin.findEmbeddingProviders}.
     */
    provider: string;
    /**
     * The name of the embedding model to use.
     *
     * You can find out more information about each model in the [DataStax docs](https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html),
     * or through {@link DbAdmin.findEmbeddingProviders}.
     */
    modelName: LitUnion<'endpoint-defined-model'>;
    /**
     * Object containing any necessary collections-bound authentication, if any.
     *
     * Most commonly, `providerKey: '*SHARED_SECRET_NAME*'` may be used here to reference an API key from the Astra KMS.
     *
     * {@link Db.createCollection} and {@link Db.collection} both offer an `embeddingApiKey` parameter which utilizes
     * header-based auth to pass the provider's token/api-key to the Data API on a per-request basis instead, if that
     * is preferred (or necessary).
     */
    authentication?: Record<string, unknown>;
    /**
     * Object allowing arbitrary parameters that may be necessary on a per-model/per-provider basis.
     *
     * Not all providers need this, but some, such as `huggingfaceDedicated` have required parameters, some others have
     * optional parameters (e.g. `openai`), and some don't require any at all.
     *
     * You can find out more information about each provider/model in the [DataStax docs](https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html),
     * or through {@link DbAdmin.findEmbeddingProviders}.
     */
    parameters?: Record<string, unknown>;
}

/**
 * Includes an `_id` in the given type, even if it's not declared in the type
 *
 * @public
 */
export declare type WithId<T> = T & {
    _id: IdOf<T>;
};

/**
 * Allows you to override the keyspace to use for some db operation. If not specified,
 * the db operation will use either the keyspace provided when creating the Db instance, the keyspace
 * provided when creating the DataAPIClient instance, or the default keyspace `'default_keyspace'`.
 * (in that order)
 *
 * @example
 * ```typescript
 * const client = new DataAPIClient('AstraCS:...');
 *
 * // Using 'default_keyspace' as the keyspace
 * const db1 = client.db('https://<db_id>-<region>.apps.astra.datastax.com');
 *
 * // Using 'my_keyspace' as the keyspace
 * const db2 = client.db('https://<db_id>-<region>.apps.astra.datastax.com', {
 *   keyspace: 'my_keyspace',
 * });
 *
 * // Finds 'my_collection' in 'default_keyspace'
 * const coll1 = db1.collection('my_collection');
 *
 * // Finds 'my_collection' in 'my_keyspace'
 * const coll2 = db1.collection('my_collection', {
 *   keyspace: 'my_keyspace',
 * });
 * ```
 *
 * @field keyspace - The keyspace to use for the db operation.
 *
 * @public
 */
export declare interface WithKeyspace {
    /**
     * The keyspace to use for the operation.
     */
    keyspace?: string;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - The `namespace` terminology has been removed, and replaced with `keyspace` throughout the client.
     */
    namespace?: 'ERROR: The `namespace` terminology has been removed, and replaced with `keyspace` throughout the client';
}

/**
 * Adds `$similarity?: number` to the given type, representing the vector similarity score of the document if a vector search was performed.
 *
 * @public
 */
export declare type WithSim<Schema extends SomeDoc> = Schema & {
    $similarity?: number;
};

/**
 * ##### Overview
 *
 * Lets you specify timeouts for individual methods, in two different formats:
 * - A subtype of {@link TimeoutDescriptor}, which lets you specify the timeout for specific categories.
 * - A number, which specifies the "happy path" timeout for the method.
 *   - In single-call methods, this sets both the request & overall method timeouts.
 *   - In multi-call methods, this sets the overall method timeout (request timeouts are kept as default).
 *
 * @example
 * ```ts
 * // Both `requestTimeoutMs` and `generalMethodTimeoutMs` are set to 1000ms.
 * await coll.insertOne({ ... }, { timeout: 1000 });
 *
 * // `requestTimeoutMs` is left as default, `generalMethodTimeoutMs` is set to 2000ms.
 * await coll.insertOne({ ... }, { timeout: { generalMethodTimeoutMs: 2000 } });
 *
 * // Both `requestTimeoutMs` and `generalMethodTimeoutMs` are set to 2000ms.
 * await coll.insertMany([...], {
 *   timeout: { requestTimeoutMs: 2000, generalMethodTimeoutMs: 2000 },
 * });
 * ```
 *
 * @example
 * ```ts
 * // `requestTimeoutMs` is left as default, `generalMethodTimeoutMs` is set to 2000ms.
 * await coll.insertMany([...], { timeout: 2000 });
 *
 * // `requestTimeoutMs` is left as default, `generalMethodTimeoutMs` is set to 2000ms.
 * await coll.insertMany([...], { timeout: { generalMethodTimeoutMs: 2000 } });
 *
 * // Both `requestTimeoutMs` and `generalMethodTimeoutMs` are set to 2000ms.
 * await coll.insertMany([...], {
 *   timeout: { requestTimeoutMs: 2000, generalMethodTimeoutMs: 2000 },
 * });
 * ```
 *
 * See {@link TimeoutDescriptor} for much more information.
 *
 * @see TimeoutDescriptor
 *
 * @public
 */
export declare interface WithTimeout<Timeouts extends keyof TimeoutDescriptor> {
    /**
     * The method timeout override.
     *
     * See {@link TimeoutDescriptor} for much more information.
     */
    timeout?: number | Pick<Partial<TimeoutDescriptor>, 'requestTimeoutMs' | Timeouts>;
    /**
     * *This temporary error-ing property exists for migration convenience, and will be removed in a future version.*
     *
     * @deprecated - The `maxTimeMS` option is no longer available; the timeouts system has been overhauled, and timeouts should now be set using `timeout`, and defaults in `timeoutDefaults`. You may generally Ctrl+R replace `maxTimeMS` with `timeout` to retain the same behavior.
     */
    maxTimeMS?: 'ERROR: The `maxTimeMS` option is no longer available; the timeouts system has been overhauled, and timeouts should now be set using `timeout`';
}

export { }
